import{c as Up,g as Hp}from"./mapbox-gl.95dcea97.js";var ah={exports:{}},oh={exports:{}},Pl={exports:{}};/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */(function(Yt,Mn){(function(u,me){me(Mn)})(Up,function(u){const me="132",he="300 es";class Re{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const n=this._listeners[e];if(n!==void 0){const i=n.indexOf(t);i!==-1&&n.splice(i,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const t=this._listeners[e.type];if(t!==void 0){e.target=this;const n=t.slice(0);for(let i=0,r=n.length;i<r;i++)n[i].call(this,e);e.target=null}}}const it=[];for(let s=0;s<256;s++)it[s]=(s<16?"0":"")+s.toString(16);let st=1234567;const It=Math.PI/180,Nt=180/Math.PI;function Ut(){const s=4294967295*Math.random()|0,e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(it[255&s]+it[s>>8&255]+it[s>>16&255]+it[s>>24&255]+"-"+it[255&e]+it[e>>8&255]+"-"+it[e>>16&15|64]+it[e>>24&255]+"-"+it[63&t|128]+it[t>>8&255]+"-"+it[t>>16&255]+it[t>>24&255]+it[255&n]+it[n>>8&255]+it[n>>16&255]+it[n>>24&255]).toUpperCase()}function Bt(s,e,t){return Math.max(e,Math.min(t,s))}function At(s,e){return(s%e+e)%e}function Vt(s,e,t){return(1-t)*s+t*e}function Tn(s){return(s&s-1)==0&&s!==0}function bn(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function ti(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}var ni=Object.freeze({__proto__:null,DEG2RAD:It,RAD2DEG:Nt,generateUUID:Ut,clamp:Bt,euclideanModulo:At,mapLinear:function(s,e,t,n,i){return n+(s-e)*(i-n)/(t-e)},inverseLerp:function(s,e,t){return s!==e?(t-s)/(e-s):0},lerp:Vt,damp:function(s,e,t,n){return Vt(s,e,1-Math.exp(-t*n))},pingpong:function(s,e=1){return e-Math.abs(At(s,2*e)-e)},smoothstep:function(s,e,t){return s<=e?0:s>=t?1:(s=(s-e)/(t-e))*s*(3-2*s)},smootherstep:function(s,e,t){return s<=e?0:s>=t?1:(s=(s-e)/(t-e))*s*s*(s*(6*s-15)+10)},randInt:function(s,e){return s+Math.floor(Math.random()*(e-s+1))},randFloat:function(s,e){return s+Math.random()*(e-s)},randFloatSpread:function(s){return s*(.5-Math.random())},seededRandom:function(s){return s!==void 0&&(st=s%2147483647),st=16807*st%2147483647,(st-1)/2147483646},degToRad:function(s){return s*It},radToDeg:function(s){return s*Nt},isPowerOfTwo:Tn,ceilPowerOfTwo:bn,floorPowerOfTwo:ti,setQuaternionFromProperEuler:function(s,e,t,n,i){const r=Math.cos,a=Math.sin,l=r(t/2),c=a(t/2),h=r((e+n)/2),d=a((e+n)/2),p=r((e-n)/2),f=a((e-n)/2),m=r((n-e)/2),y=a((n-e)/2);switch(i){case"XYX":s.set(l*d,c*p,c*f,l*h);break;case"YZY":s.set(c*f,l*d,c*p,l*h);break;case"ZXZ":s.set(c*p,c*f,l*d,l*h);break;case"XZX":s.set(l*d,c*y,c*m,l*h);break;case"YXY":s.set(c*m,l*d,c*y,l*h);break;case"ZYZ":s.set(c*y,c*m,l*d,l*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}});class at{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),r=this.x-e.x,a=this.y-e.y;return this.x=r*n-a*i+e.x,this.y=r*i+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}at.prototype.isVector2=!0;class hn{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,r,a,l,c,h){const d=this.elements;return d[0]=e,d[1]=i,d[2]=l,d[3]=t,d[4]=r,d[5]=c,d[6]=n,d[7]=a,d[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],l=n[3],c=n[6],h=n[1],d=n[4],p=n[7],f=n[2],m=n[5],y=n[8],b=i[0],T=i[3],_=i[6],F=i[1],U=i[4],k=i[7],X=i[2],K=i[5],ye=i[8];return r[0]=a*b+l*F+c*X,r[3]=a*T+l*U+c*K,r[6]=a*_+l*k+c*ye,r[1]=h*b+d*F+p*X,r[4]=h*T+d*U+p*K,r[7]=h*_+d*k+p*ye,r[2]=f*b+m*F+y*X,r[5]=f*T+m*U+y*K,r[8]=f*_+m*k+y*ye,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],l=e[5],c=e[6],h=e[7],d=e[8];return t*a*d-t*l*h-n*r*d+n*l*c+i*r*h-i*a*c}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],l=e[5],c=e[6],h=e[7],d=e[8],p=d*a-l*h,f=l*c-d*r,m=h*r-a*c,y=t*p+n*f+i*m;if(y===0)return this.set(0,0,0,0,0,0,0,0,0);const b=1/y;return e[0]=p*b,e[1]=(i*h-d*n)*b,e[2]=(l*n-i*a)*b,e[3]=f*b,e[4]=(d*t-i*c)*b,e[5]=(i*r-l*t)*b,e[6]=m*b,e[7]=(n*c-h*t)*b,e[8]=(a*t-n*r)*b,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,r,a,l){const c=Math.cos(r),h=Math.sin(r);return this.set(n*c,n*h,-n*(c*a+h*l)+a+e,-i*h,i*c,-i*(-h*a+c*l)+l+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),i=this.elements,r=i[0],a=i[3],l=i[6],c=i[1],h=i[4],d=i[7];return i[0]=t*r+n*c,i[3]=t*a+n*h,i[6]=t*l+n*d,i[1]=-n*r+t*c,i[4]=-n*a+t*h,i[7]=-n*l+t*d,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}let Rn;hn.prototype.isMatrix3=!0;class Wn{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Rn===void 0&&(Rn=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),Rn.width=e.width,Rn.height=e.height;const n=Rn.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Rn}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let lr=0;class wn extends Re{constructor(e=wn.DEFAULT_IMAGE,t=wn.DEFAULT_MAPPING,n=1001,i=1001,r=1006,a=1008,l=1023,c=1009,h=1,d=3e3){super(),Object.defineProperty(this,"id",{value:lr++}),this.uuid=Ut(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=h,this.format=l,this.internalFormat=null,this.type=c,this.offset=new at(0,0),this.repeat=new at(1,1),this.center=new at(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new hn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=d,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=Ut()),!t&&e.images[i.uuid]===void 0){let r;if(Array.isArray(i)){r=[];for(let a=0,l=i.length;a<l;a++)i[a].isDataTexture?r.push(Ln(i[a].image)):r.push(Ln(i[a]))}else r=Ln(i);e.images[i.uuid]={uuid:i.uuid,url:r}}n.image=i.uuid}return t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==300)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case 1e3:e.x=e.x-Math.floor(e.x);break;case 1001:e.x=e.x<0?0:1;break;case 1002:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case 1e3:e.y=e.y-Math.floor(e.y);break;case 1001:e.y=e.y<0?0:1;break;case 1002:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}function Ln(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?Wn.getDataURL(s):s.data?{data:Array.prototype.slice.call(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}wn.DEFAULT_IMAGE=void 0,wn.DEFAULT_MAPPING=300,wn.prototype.isTexture=!0;class en{constructor(e=0,t=0,n=0,i=1){this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*i+a[12]*r,this.y=a[1]*t+a[5]*n+a[9]*i+a[13]*r,this.z=a[2]*t+a[6]*n+a[10]*i+a[14]*r,this.w=a[3]*t+a[7]*n+a[11]*i+a[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,r;const c=e.elements,h=c[0],d=c[4],p=c[8],f=c[1],m=c[5],y=c[9],b=c[2],T=c[6],_=c[10];if(Math.abs(d-f)<.01&&Math.abs(p-b)<.01&&Math.abs(y-T)<.01){if(Math.abs(d+f)<.1&&Math.abs(p+b)<.1&&Math.abs(y+T)<.1&&Math.abs(h+m+_-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const U=(h+1)/2,k=(m+1)/2,X=(_+1)/2,K=(d+f)/4,ye=(p+b)/4,we=(y+T)/4;return U>k&&U>X?U<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(U),i=K/n,r=ye/n):k>X?k<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(k),n=K/i,r=we/i):X<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(X),n=ye/r,i=we/r),this.set(n,i,r,t),this}let F=Math.sqrt((T-y)*(T-y)+(p-b)*(p-b)+(f-d)*(f-d));return Math.abs(F)<.001&&(F=1),this.x=(T-y)/F,this.y=(p-b)/F,this.z=(f-d)/F,this.w=Math.acos((h+m+_-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}en.prototype.isVector4=!0;class Nn extends Re{constructor(e,t,n={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new en(0,0,e,t),this.scissorTest=!1,this.viewport=new en(0,0,e,t),this.texture=new wn(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:e,height:t,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0&&n.generateMipmaps,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:1006,this.depthBuffer=n.depthBuffer===void 0||n.depthBuffer,this.stencilBuffer=n.stencilBuffer!==void 0&&n.stencilBuffer,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,n=1){this.width===e&&this.height===t&&this.depth===n||(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Nn.prototype.isWebGLRenderTarget=!0;class Gn extends Nn{constructor(e,t,n){super(e,t);const i=this.texture;this.texture=[];for(let r=0;r<n;r++)this.texture[r]=i.clone()}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone();return this}}Gn.prototype.isWebGLMultipleRenderTargets=!0;class wi extends Nn{constructor(e,t,n){super(e,t,n),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}wi.prototype.isWebGLMultisampleRenderTarget=!0;class In{constructor(e=0,t=0,n=0,i=1){this._x=e,this._y=t,this._z=n,this._w=i}static slerp(e,t,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,i)}static slerpFlat(e,t,n,i,r,a,l){let c=n[i+0],h=n[i+1],d=n[i+2],p=n[i+3];const f=r[a+0],m=r[a+1],y=r[a+2],b=r[a+3];if(l===0)return e[t+0]=c,e[t+1]=h,e[t+2]=d,void(e[t+3]=p);if(l===1)return e[t+0]=f,e[t+1]=m,e[t+2]=y,void(e[t+3]=b);if(p!==b||c!==f||h!==m||d!==y){let T=1-l;const _=c*f+h*m+d*y+p*b,F=_>=0?1:-1,U=1-_*_;if(U>Number.EPSILON){const X=Math.sqrt(U),K=Math.atan2(X,_*F);T=Math.sin(T*K)/X,l=Math.sin(l*K)/X}const k=l*F;if(c=c*T+f*k,h=h*T+m*k,d=d*T+y*k,p=p*T+b*k,T===1-l){const X=1/Math.sqrt(c*c+h*h+d*d+p*p);c*=X,h*=X,d*=X,p*=X}}e[t]=c,e[t+1]=h,e[t+2]=d,e[t+3]=p}static multiplyQuaternionsFlat(e,t,n,i,r,a){const l=n[i],c=n[i+1],h=n[i+2],d=n[i+3],p=r[a],f=r[a+1],m=r[a+2],y=r[a+3];return e[t]=l*y+d*p+c*m-h*f,e[t+1]=c*y+d*f+h*p-l*m,e[t+2]=h*y+d*m+l*f-c*p,e[t+3]=d*y-l*p-c*f-h*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,i=e._y,r=e._z,a=e._order,l=Math.cos,c=Math.sin,h=l(n/2),d=l(i/2),p=l(r/2),f=c(n/2),m=c(i/2),y=c(r/2);switch(a){case"XYZ":this._x=f*d*p+h*m*y,this._y=h*m*p-f*d*y,this._z=h*d*y+f*m*p,this._w=h*d*p-f*m*y;break;case"YXZ":this._x=f*d*p+h*m*y,this._y=h*m*p-f*d*y,this._z=h*d*y-f*m*p,this._w=h*d*p+f*m*y;break;case"ZXY":this._x=f*d*p-h*m*y,this._y=h*m*p+f*d*y,this._z=h*d*y+f*m*p,this._w=h*d*p-f*m*y;break;case"ZYX":this._x=f*d*p-h*m*y,this._y=h*m*p+f*d*y,this._z=h*d*y-f*m*p,this._w=h*d*p+f*m*y;break;case"YZX":this._x=f*d*p+h*m*y,this._y=h*m*p+f*d*y,this._z=h*d*y-f*m*p,this._w=h*d*p-f*m*y;break;case"XZY":this._x=f*d*p-h*m*y,this._y=h*m*p-f*d*y,this._z=h*d*y+f*m*p,this._w=h*d*p+f*m*y;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],r=t[8],a=t[1],l=t[5],c=t[9],h=t[2],d=t[6],p=t[10],f=n+l+p;if(f>0){const m=.5/Math.sqrt(f+1);this._w=.25/m,this._x=(d-c)*m,this._y=(r-h)*m,this._z=(a-i)*m}else if(n>l&&n>p){const m=2*Math.sqrt(1+n-l-p);this._w=(d-c)/m,this._x=.25*m,this._y=(i+a)/m,this._z=(r+h)/m}else if(l>p){const m=2*Math.sqrt(1+l-n-p);this._w=(r-h)/m,this._x=(i+a)/m,this._y=.25*m,this._z=(c+d)/m}else{const m=2*Math.sqrt(1+p-n-l);this._w=(a-i)/m,this._x=(r+h)/m,this._y=(c+d)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Bt(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,r=e._z,a=e._w,l=t._x,c=t._y,h=t._z,d=t._w;return this._x=n*d+a*l+i*h-r*c,this._y=i*d+a*c+r*l-n*h,this._z=r*d+a*h+n*c-i*l,this._w=a*d-n*l-i*c-r*h,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,r=this._z,a=this._w;let l=a*e._w+n*e._x+i*e._y+r*e._z;if(l<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,l=-l):this.copy(e),l>=1)return this._w=a,this._x=n,this._y=i,this._z=r,this;const c=1-l*l;if(c<=Number.EPSILON){const m=1-t;return this._w=m*a+t*this._w,this._x=m*n+t*this._x,this._y=m*i+t*this._y,this._z=m*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(c),d=Math.atan2(h,l),p=Math.sin((1-t)*d)/h,f=Math.sin(t*d)/h;return this._w=a*p+this._w*f,this._x=n*p+this._x*f,this._y=i*p+this._y*f,this._z=r*p+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,n){this.copy(e).slerp(t,n)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}In.prototype.isQuaternion=!0;class H{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(jn.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(jn.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6]*i,this.y=r[1]*t+r[4]*n+r[7]*i,this.z=r[2]*t+r[5]*n+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=e.elements,a=1/(r[3]*t+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*n+r[8]*i+r[12])*a,this.y=(r[1]*t+r[5]*n+r[9]*i+r[13])*a,this.z=(r[2]*t+r[6]*n+r[10]*i+r[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,r=e.x,a=e.y,l=e.z,c=e.w,h=c*t+a*i-l*n,d=c*n+l*t-r*i,p=c*i+r*n-a*t,f=-r*t-a*n-l*i;return this.x=h*c+f*-r+d*-l-p*-a,this.y=d*c+f*-a+p*-r-h*-l,this.z=p*c+f*-l+h*-a-d*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i,this.y=r[1]*t+r[5]*n+r[9]*i,this.z=r[2]*t+r[6]*n+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,r=e.z,a=t.x,l=t.y,c=t.z;return this.x=i*c-r*l,this.y=r*a-n*c,this.z=n*l-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return Ki.copy(this).projectOnVector(e),this.sub(Ki)}reflect(e){return this.sub(Ki.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Bt(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}H.prototype.isVector3=!0;const Ki=new H,jn=new In;class qn{constructor(e=new H(1/0,1/0,1/0),t=new H(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,i=1/0,r=-1/0,a=-1/0,l=-1/0;for(let c=0,h=e.length;c<h;c+=3){const d=e[c],p=e[c+1],f=e[c+2];d<t&&(t=d),p<n&&(n=p),f<i&&(i=f),d>r&&(r=d),p>a&&(a=p),f>l&&(l=f)}return this.min.set(t,n,i),this.max.set(r,a,l),this}setFromBufferAttribute(e){let t=1/0,n=1/0,i=1/0,r=-1/0,a=-1/0,l=-1/0;for(let c=0,h=e.count;c<h;c++){const d=e.getX(c),p=e.getY(c),f=e.getZ(c);d<t&&(t=d),p<n&&(n=p),f<i&&(i=f),d>r&&(r=d),p>a&&(a=p),f>l&&(l=f)}return this.min.set(t,n,i),this.max.set(r,a,l),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Di.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),cr.copy(t.boundingBox),cr.applyMatrix4(e.matrixWorld),this.union(cr));const n=e.children;for(let i=0,r=n.length;i<r;i++)this.expandByObject(n[i]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Di),Di.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Fi),ur.subVectors(this.max,Fi),Qi.subVectors(e.a,Fi),$i.subVectors(e.b,Fi),Oi.subVectors(e.c,Fi),ai.subVectors($i,Qi),_i.subVectors(Oi,$i),Mi.subVectors(Qi,Oi);let t=[0,-ai.z,ai.y,0,-_i.z,_i.y,0,-Mi.z,Mi.y,ai.z,0,-ai.x,_i.z,0,-_i.x,Mi.z,0,-Mi.x,-ai.y,ai.x,0,-_i.y,_i.x,0,-Mi.y,Mi.x,0];return!!Br(t,Qi,$i,Oi,ur)&&(t=[1,0,0,0,1,0,0,0,1],!!Br(t,Qi,$i,Oi,ur)&&(xr.crossVectors(ai,_i),t=[xr.x,xr.y,xr.z],Br(t,Qi,$i,Oi,ur)))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Di.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=.5*this.getSize(Di).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(yi[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),yi[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),yi[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),yi[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),yi[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),yi[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),yi[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),yi[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(yi)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}qn.prototype.isBox3=!0;const yi=[new H,new H,new H,new H,new H,new H,new H,new H],Di=new H,cr=new qn,Qi=new H,$i=new H,Oi=new H,ai=new H,_i=new H,Mi=new H,Fi=new H,ur=new H,xr=new H,Ui=new H;function Br(s,e,t,n,i){for(let r=0,a=s.length-3;r<=a;r+=3){Ui.fromArray(s,r);const l=i.x*Math.abs(Ui.x)+i.y*Math.abs(Ui.y)+i.z*Math.abs(Ui.z),c=e.dot(Ui),h=t.dot(Ui),d=n.dot(Ui);if(Math.max(-Math.max(c,h,d),Math.min(c,h,d))>l)return!1}return!0}const zr=new qn,kr=new H,hr=new H,br=new H;class Si{constructor(e=new H,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):zr.setFromPoints(e).getCenter(n);let i=0;for(let r=0,a=e.length;r<a;r++)i=Math.max(i,n.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){br.subVectors(e,this.center);const t=br.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=.5*(n-this.radius);this.center.add(br.multiplyScalar(i/n)),this.radius+=i}return this}union(e){return hr.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(kr.copy(e.center).add(hr)),this.expandByPoint(kr.copy(e.center).sub(hr)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Cn=new H,Ni=new H,ii=new H,pi=new H,wr=new H,er=new H,_r=new H;class Ti{constructor(e=new H,t=new H(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Cn)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Cn.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Cn.copy(this.direction).multiplyScalar(t).add(this.origin),Cn.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){Ni.copy(e).add(t).multiplyScalar(.5),ii.copy(t).sub(e).normalize(),pi.copy(this.origin).sub(Ni);const r=.5*e.distanceTo(t),a=-this.direction.dot(ii),l=pi.dot(this.direction),c=-pi.dot(ii),h=pi.lengthSq(),d=Math.abs(1-a*a);let p,f,m,y;if(d>0)if(p=a*c-l,f=a*l-c,y=r*d,p>=0)if(f>=-y)if(f<=y){const b=1/d;p*=b,f*=b,m=p*(p+a*f+2*l)+f*(a*p+f+2*c)+h}else f=r,p=Math.max(0,-(a*f+l)),m=-p*p+f*(f+2*c)+h;else f=-r,p=Math.max(0,-(a*f+l)),m=-p*p+f*(f+2*c)+h;else f<=-y?(p=Math.max(0,-(-a*r+l)),f=p>0?-r:Math.min(Math.max(-r,-c),r),m=-p*p+f*(f+2*c)+h):f<=y?(p=0,f=Math.min(Math.max(-r,-c),r),m=f*(f+2*c)+h):(p=Math.max(0,-(a*r+l)),f=p>0?r:Math.min(Math.max(-r,-c),r),m=-p*p+f*(f+2*c)+h);else f=a>0?-r:r,p=Math.max(0,-(a*f+l)),m=-p*p+f*(f+2*c)+h;return n&&n.copy(this.direction).multiplyScalar(p).add(this.origin),i&&i.copy(ii).multiplyScalar(f).add(Ni),m}intersectSphere(e,t){Cn.subVectors(e.center,this.origin);const n=Cn.dot(this.direction),i=Cn.dot(Cn)-n*n,r=e.radius*e.radius;if(i>r)return null;const a=Math.sqrt(r-i),l=n-a,c=n+a;return l<0&&c<0?null:l<0?this.at(c,t):this.at(l,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0?!0:e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,r,a,l,c;const h=1/this.direction.x,d=1/this.direction.y,p=1/this.direction.z,f=this.origin;return h>=0?(n=(e.min.x-f.x)*h,i=(e.max.x-f.x)*h):(n=(e.max.x-f.x)*h,i=(e.min.x-f.x)*h),d>=0?(r=(e.min.y-f.y)*d,a=(e.max.y-f.y)*d):(r=(e.max.y-f.y)*d,a=(e.min.y-f.y)*d),n>a||r>i?null:((r>n||n!=n)&&(n=r),(a<i||i!=i)&&(i=a),p>=0?(l=(e.min.z-f.z)*p,c=(e.max.z-f.z)*p):(l=(e.max.z-f.z)*p,c=(e.min.z-f.z)*p),n>c||l>i?null:((l>n||n!=n)&&(n=l),(c<i||i!=i)&&(i=c),i<0?null:this.at(n>=0?n:i,t)))}intersectsBox(e){return this.intersectBox(e,Cn)!==null}intersectTriangle(e,t,n,i,r){wr.subVectors(t,e),er.subVectors(n,e),_r.crossVectors(wr,er);let a,l=this.direction.dot(_r);if(l>0){if(i)return null;a=1}else{if(!(l<0))return null;a=-1,l=-l}pi.subVectors(this.origin,e);const c=a*this.direction.dot(er.crossVectors(pi,er));if(c<0)return null;const h=a*this.direction.dot(wr.cross(pi));if(h<0||c+h>l)return null;const d=-a*pi.dot(_r);return d<0?null:this.at(d/l,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Dt{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,r,a,l,c,h,d,p,f,m,y,b,T){const _=this.elements;return _[0]=e,_[4]=t,_[8]=n,_[12]=i,_[1]=r,_[5]=a,_[9]=l,_[13]=c,_[2]=h,_[6]=d,_[10]=p,_[14]=f,_[3]=m,_[7]=y,_[11]=b,_[15]=T,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Dt().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/oi.setFromMatrixColumn(e,0).length(),r=1/oi.setFromMatrixColumn(e,1).length(),a=1/oi.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,i=e.y,r=e.z,a=Math.cos(n),l=Math.sin(n),c=Math.cos(i),h=Math.sin(i),d=Math.cos(r),p=Math.sin(r);if(e.order==="XYZ"){const f=a*d,m=a*p,y=l*d,b=l*p;t[0]=c*d,t[4]=-c*p,t[8]=h,t[1]=m+y*h,t[5]=f-b*h,t[9]=-l*c,t[2]=b-f*h,t[6]=y+m*h,t[10]=a*c}else if(e.order==="YXZ"){const f=c*d,m=c*p,y=h*d,b=h*p;t[0]=f+b*l,t[4]=y*l-m,t[8]=a*h,t[1]=a*p,t[5]=a*d,t[9]=-l,t[2]=m*l-y,t[6]=b+f*l,t[10]=a*c}else if(e.order==="ZXY"){const f=c*d,m=c*p,y=h*d,b=h*p;t[0]=f-b*l,t[4]=-a*p,t[8]=y+m*l,t[1]=m+y*l,t[5]=a*d,t[9]=b-f*l,t[2]=-a*h,t[6]=l,t[10]=a*c}else if(e.order==="ZYX"){const f=a*d,m=a*p,y=l*d,b=l*p;t[0]=c*d,t[4]=y*h-m,t[8]=f*h+b,t[1]=c*p,t[5]=b*h+f,t[9]=m*h-y,t[2]=-h,t[6]=l*c,t[10]=a*c}else if(e.order==="YZX"){const f=a*c,m=a*h,y=l*c,b=l*h;t[0]=c*d,t[4]=b-f*p,t[8]=y*p+m,t[1]=p,t[5]=a*d,t[9]=-l*d,t[2]=-h*d,t[6]=m*p+y,t[10]=f-b*p}else if(e.order==="XZY"){const f=a*c,m=a*h,y=l*c,b=l*h;t[0]=c*d,t[4]=-p,t[8]=h*d,t[1]=f*p+b,t[5]=a*d,t[9]=m*p-y,t[2]=y*p-m,t[6]=l*d,t[10]=b*p+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(vi,e,ks)}lookAt(e,t,n){const i=this.elements;return Zn.subVectors(e,t),Zn.lengthSq()===0&&(Zn.z=1),Zn.normalize(),Ei.crossVectors(n,Zn),Ei.lengthSq()===0&&(Math.abs(n.z)===1?Zn.x+=1e-4:Zn.z+=1e-4,Zn.normalize(),Ei.crossVectors(n,Zn)),Ei.normalize(),Mr.crossVectors(Zn,Ei),i[0]=Ei.x,i[4]=Mr.x,i[8]=Zn.x,i[1]=Ei.y,i[5]=Mr.y,i[9]=Zn.y,i[2]=Ei.z,i[6]=Mr.z,i[10]=Zn.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],l=n[4],c=n[8],h=n[12],d=n[1],p=n[5],f=n[9],m=n[13],y=n[2],b=n[6],T=n[10],_=n[14],F=n[3],U=n[7],k=n[11],X=n[15],K=i[0],ye=i[4],we=i[8],Fe=i[12],Te=i[1],Ce=i[5],St=i[9],ht=i[13],je=i[2],ft=i[6],Lt=i[10],Pt=i[14],Ht=i[3],Xt=i[7],Zt=i[11],pt=i[15];return r[0]=a*K+l*Te+c*je+h*Ht,r[4]=a*ye+l*Ce+c*ft+h*Xt,r[8]=a*we+l*St+c*Lt+h*Zt,r[12]=a*Fe+l*ht+c*Pt+h*pt,r[1]=d*K+p*Te+f*je+m*Ht,r[5]=d*ye+p*Ce+f*ft+m*Xt,r[9]=d*we+p*St+f*Lt+m*Zt,r[13]=d*Fe+p*ht+f*Pt+m*pt,r[2]=y*K+b*Te+T*je+_*Ht,r[6]=y*ye+b*Ce+T*ft+_*Xt,r[10]=y*we+b*St+T*Lt+_*Zt,r[14]=y*Fe+b*ht+T*Pt+_*pt,r[3]=F*K+U*Te+k*je+X*Ht,r[7]=F*ye+U*Ce+k*ft+X*Xt,r[11]=F*we+U*St+k*Lt+X*Zt,r[15]=F*Fe+U*ht+k*Pt+X*pt,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],r=e[12],a=e[1],l=e[5],c=e[9],h=e[13],d=e[2],p=e[6],f=e[10],m=e[14];return e[3]*(+r*c*p-i*h*p-r*l*f+n*h*f+i*l*m-n*c*m)+e[7]*(+t*c*m-t*h*f+r*a*f-i*a*m+i*h*d-r*c*d)+e[11]*(+t*h*p-t*l*m-r*a*p+n*a*m+r*l*d-n*h*d)+e[15]*(-i*l*d-t*c*p+t*l*f+i*a*p-n*a*f+n*c*d)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],l=e[5],c=e[6],h=e[7],d=e[8],p=e[9],f=e[10],m=e[11],y=e[12],b=e[13],T=e[14],_=e[15],F=p*T*h-b*f*h+b*c*m-l*T*m-p*c*_+l*f*_,U=y*f*h-d*T*h-y*c*m+a*T*m+d*c*_-a*f*_,k=d*b*h-y*p*h+y*l*m-a*b*m-d*l*_+a*p*_,X=y*p*c-d*b*c-y*l*f+a*b*f+d*l*T-a*p*T,K=t*F+n*U+i*k+r*X;if(K===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const ye=1/K;return e[0]=F*ye,e[1]=(b*f*r-p*T*r-b*i*m+n*T*m+p*i*_-n*f*_)*ye,e[2]=(l*T*r-b*c*r+b*i*h-n*T*h-l*i*_+n*c*_)*ye,e[3]=(p*c*r-l*f*r-p*i*h+n*f*h+l*i*m-n*c*m)*ye,e[4]=U*ye,e[5]=(d*T*r-y*f*r+y*i*m-t*T*m-d*i*_+t*f*_)*ye,e[6]=(y*c*r-a*T*r-y*i*h+t*T*h+a*i*_-t*c*_)*ye,e[7]=(a*f*r-d*c*r+d*i*h-t*f*h-a*i*m+t*c*m)*ye,e[8]=k*ye,e[9]=(y*p*r-d*b*r-y*n*m+t*b*m+d*n*_-t*p*_)*ye,e[10]=(a*b*r-y*l*r+y*n*h-t*b*h-a*n*_+t*l*_)*ye,e[11]=(d*l*r-a*p*r-d*n*h+t*p*h+a*n*m-t*l*m)*ye,e[12]=X*ye,e[13]=(d*b*i-y*p*i+y*n*f-t*b*f-d*n*T+t*p*T)*ye,e[14]=(y*l*i-a*b*i-y*n*c+t*b*c+a*n*T-t*l*T)*ye,e[15]=(a*p*i-d*l*i+d*n*c-t*p*c-a*n*f+t*l*f)*ye,this}scale(e){const t=this.elements,n=e.x,i=e.y,r=e.z;return t[0]*=n,t[4]*=i,t[8]*=r,t[1]*=n,t[5]*=i,t[9]*=r,t[2]*=n,t[6]*=i,t[10]*=r,t[3]*=n,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),r=1-n,a=e.x,l=e.y,c=e.z,h=r*a,d=r*l;return this.set(h*a+n,h*l-i*c,h*c+i*l,0,h*l+i*c,d*l+n,d*c-i*a,0,h*c-i*l,d*c+i*a,r*c*c+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,r,a){return this.set(1,n,r,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,r=t._x,a=t._y,l=t._z,c=t._w,h=r+r,d=a+a,p=l+l,f=r*h,m=r*d,y=r*p,b=a*d,T=a*p,_=l*p,F=c*h,U=c*d,k=c*p,X=n.x,K=n.y,ye=n.z;return i[0]=(1-(b+_))*X,i[1]=(m+k)*X,i[2]=(y-U)*X,i[3]=0,i[4]=(m-k)*K,i[5]=(1-(f+_))*K,i[6]=(T+F)*K,i[7]=0,i[8]=(y+U)*ye,i[9]=(T-F)*ye,i[10]=(1-(f+b))*ye,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let r=oi.set(i[0],i[1],i[2]).length();const a=oi.set(i[4],i[5],i[6]).length(),l=oi.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],Xn.copy(this);const c=1/r,h=1/a,d=1/l;return Xn.elements[0]*=c,Xn.elements[1]*=c,Xn.elements[2]*=c,Xn.elements[4]*=h,Xn.elements[5]*=h,Xn.elements[6]*=h,Xn.elements[8]*=d,Xn.elements[9]*=d,Xn.elements[10]*=d,t.setFromRotationMatrix(Xn),n.x=r,n.y=a,n.z=l,this}makePerspective(e,t,n,i,r,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const l=this.elements,c=2*r/(t-e),h=2*r/(n-i),d=(t+e)/(t-e),p=(n+i)/(n-i),f=-(a+r)/(a-r),m=-2*a*r/(a-r);return l[0]=c,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=h,l[9]=p,l[13]=0,l[2]=0,l[6]=0,l[10]=f,l[14]=m,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,n,i,r,a){const l=this.elements,c=1/(t-e),h=1/(n-i),d=1/(a-r),p=(t+e)*c,f=(n+i)*h,m=(a+r)*d;return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-p,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-f,l[2]=0,l[6]=0,l[10]=-2*d,l[14]=-m,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Dt.prototype.isMatrix4=!0;const oi=new H,Xn=new Dt,vi=new H(0,0,0),ks=new H(1,1,1),Ei=new H,Mr=new H,Zn=new H,hs=new Dt,Ur=new In;class Hi{constructor(e=0,t=0,n=0,i=Hi.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,r=i[0],a=i[4],l=i[8],c=i[1],h=i[5],d=i[9],p=i[2],f=i[6],m=i[10];switch(t){case"XYZ":this._y=Math.asin(Bt(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-d,m),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(f,h),this._z=0);break;case"YXZ":this._x=Math.asin(-Bt(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(l,m),this._z=Math.atan2(c,h)):(this._y=Math.atan2(-p,r),this._z=0);break;case"ZXY":this._x=Math.asin(Bt(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-p,m),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(c,r));break;case"ZYX":this._y=Math.asin(-Bt(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(f,m),this._z=Math.atan2(c,r)):(this._x=0,this._z=Math.atan2(-a,h));break;case"YZX":this._z=Math.asin(Bt(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-d,h),this._y=Math.atan2(-p,r)):(this._x=0,this._y=Math.atan2(l,m));break;case"XZY":this._z=Math.asin(-Bt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(f,h),this._y=Math.atan2(l,r)):(this._x=Math.atan2(-d,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return hs.makeRotationFromQuaternion(e),this.setFromRotationMatrix(hs,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Ur.setFromEuler(this),this.setFromQuaternion(Ur,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new H(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Hi.prototype.isEuler=!0,Hi.DefaultOrder="XYZ",Hi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Sr{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}}let Dn=0;const Tr=new H,tr=new In,S=new Dt,M=new H,P=new H,W=new H,Le=new In,ze=new H(1,0,0),_e=new H(0,1,0),qe=new H(0,0,1),w={type:"added"},x={type:"removed"};class E extends Re{constructor(){super(),Object.defineProperty(this,"id",{value:Dn++}),this.uuid=Ut(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=E.DefaultUp.clone();const e=new H,t=new Hi,n=new In,i=new H(1,1,1);t._onChange(function(){n.setFromEuler(t,!1)}),n._onChange(function(){t.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Dt},normalMatrix:{value:new hn}}),this.matrix=new Dt,this.matrixWorld=new Dt,this.matrixAutoUpdate=E.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Sr,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return tr.setFromAxisAngle(e,t),this.quaternion.multiply(tr),this}rotateOnWorldAxis(e,t){return tr.setFromAxisAngle(e,t),this.quaternion.premultiply(tr),this}rotateX(e){return this.rotateOnAxis(ze,e)}rotateY(e){return this.rotateOnAxis(_e,e)}rotateZ(e){return this.rotateOnAxis(qe,e)}translateOnAxis(e,t){return Tr.copy(e).applyQuaternion(this.quaternion),this.position.add(Tr.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(ze,e)}translateY(e){return this.translateOnAxis(_e,e)}translateZ(e){return this.translateOnAxis(qe,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(S.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?M.copy(e):M.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),P.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?S.lookAt(P,M,this.up):S.lookAt(M,P,this.up),this.quaternion.setFromRotationMatrix(S),i&&(S.extractRotation(i.matrixWorld),tr.setFromRotationMatrix(S),this.quaternion.premultiply(tr.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(w)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(x)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(x)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),S.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),S.multiply(e.parent.matrixWorld)),e.applyMatrix4(S),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const r=this.children[n].getObjectByProperty(e,t);if(r!==void 0)return r}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(P,e,W),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(P,Le,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(l,c){return l[c.uuid]===void 0&&(l[c.uuid]=c.toJSON(e)),c.uuid}if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const l=this.geometry.parameters;if(l!==void 0&&l.shapes!==void 0){const c=l.shapes;if(Array.isArray(c))for(let h=0,d=c.length;h<d;h++){const p=c[h];r(e.shapes,p)}else r(e.shapes,c)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const l=[];for(let c=0,h=this.material.length;c<h;c++)l.push(r(e.materials,this.material[c]));i.material=l}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let l=0;l<this.children.length;l++)i.children.push(this.children[l].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let l=0;l<this.animations.length;l++){const c=this.animations[l];i.animations.push(r(e.animations,c))}}if(t){const l=a(e.geometries),c=a(e.materials),h=a(e.textures),d=a(e.images),p=a(e.shapes),f=a(e.skeletons),m=a(e.animations);l.length>0&&(n.geometries=l),c.length>0&&(n.materials=c),h.length>0&&(n.textures=h),d.length>0&&(n.images=d),p.length>0&&(n.shapes=p),f.length>0&&(n.skeletons=f),m.length>0&&(n.animations=m)}return n.object=i,n;function a(l){const c=[];for(const h in l){const d=l[h];delete d.metadata,c.push(d)}return c}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}E.DefaultUp=new H(0,1,0),E.DefaultMatrixAutoUpdate=!0,E.prototype.isObject3D=!0;const O=new H,I=new H,pe=new H,Se=new H,Ve=new H,lt=new H,xt=new H,Ye=new H,ke=new H,Et=new H;class Ke{constructor(e=new H,t=new H,n=new H){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),O.subVectors(e,t),i.cross(O);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,n,i,r){O.subVectors(i,t),I.subVectors(n,t),pe.subVectors(e,t);const a=O.dot(O),l=O.dot(I),c=O.dot(pe),h=I.dot(I),d=I.dot(pe),p=a*h-l*l;if(p===0)return r.set(-2,-1,-1);const f=1/p,m=(h*c-l*d)*f,y=(a*d-l*c)*f;return r.set(1-m-y,y,m)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,Se),Se.x>=0&&Se.y>=0&&Se.x+Se.y<=1}static getUV(e,t,n,i,r,a,l,c){return this.getBarycoord(e,t,n,i,Se),c.set(0,0),c.addScaledVector(r,Se.x),c.addScaledVector(a,Se.y),c.addScaledVector(l,Se.z),c}static isFrontFacing(e,t,n,i){return O.subVectors(n,t),I.subVectors(e,t),O.cross(I).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return O.subVectors(this.c,this.b),I.subVectors(this.a,this.b),.5*O.cross(I).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ke.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ke.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,r){return Ke.getUV(e,this.a,this.b,this.c,t,n,i,r)}containsPoint(e){return Ke.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ke.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,r=this.c;let a,l;Ve.subVectors(i,n),lt.subVectors(r,n),Ye.subVectors(e,n);const c=Ve.dot(Ye),h=lt.dot(Ye);if(c<=0&&h<=0)return t.copy(n);ke.subVectors(e,i);const d=Ve.dot(ke),p=lt.dot(ke);if(d>=0&&p<=d)return t.copy(i);const f=c*p-d*h;if(f<=0&&c>=0&&d<=0)return a=c/(c-d),t.copy(n).addScaledVector(Ve,a);Et.subVectors(e,r);const m=Ve.dot(Et),y=lt.dot(Et);if(y>=0&&m<=y)return t.copy(r);const b=m*h-c*y;if(b<=0&&h>=0&&y<=0)return l=h/(h-y),t.copy(n).addScaledVector(lt,l);const T=d*y-m*p;if(T<=0&&p-d>=0&&m-y>=0)return xt.subVectors(r,i),l=(p-d)/(p-d+(m-y)),t.copy(i).addScaledVector(xt,l);const _=1/(T+b+f);return a=b*_,l=f*_,t.copy(n).addScaledVector(Ve,a).addScaledVector(lt,l)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Tt=0;class We extends Re{constructor(){super(),Object.defineProperty(this,"id",{value:Tt++}),this.uuid=Ut(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.format=1023,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===1;continue}const i=this[t];i!==void 0?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(r){const a=[];for(const l in r){const c=r[l];delete c.metadata,a.push(c)}return a}if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheenTint&&this.sheenTint.isColor&&(n.sheenTint=this.sheenTint.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(n.specularTint=this.specularTint.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(n.specularTintMap=this.specularTintMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationTint!==void 0&&(n.attenuationTint=this.attenuationTint.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(n.blending=this.blending),this.side!==0&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==1023&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t){const r=i(e.textures),a=i(e.images);r.length>0&&(n.textures=r),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.format=e.format,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}We.prototype.isMaterial=!0;const Rt={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},zt={h:0,s:0,l:0},jt={h:0,s:0,l:0};function qt(s,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?s+6*(e-s)*t:t<.5?e:t<2/3?s+6*(e-s)*(2/3-t):s}function un(s){return s<.04045?.0773993808*s:Math.pow(.9478672986*s+.0521327014,2.4)}function rn(s){return s<.0031308?12.92*s:1.055*Math.pow(s,.41666)-.055}class ut{constructor(e,t,n){return t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=At(e,1),t=Bt(t,0,1),n=Bt(n,0,1),t===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+t):n+t-n*t,r=2*n-i;this.r=qt(r,i,e+1/3),this.g=qt(r,i,e),this.b=qt(r,i,e-1/3)}return this}setStyle(e){function t(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let i;const r=n[1],a=n[2];switch(r){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,t(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,t(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const l=parseFloat(i[1])/360,c=parseInt(i[2],10)/100,h=parseInt(i[3],10)/100;return t(i[4]),this.setHSL(l,c,h)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){const i=n[1],r=i.length;if(r===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(r===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Rt[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=un(e.r),this.g=un(e.g),this.b=un(e.b),this}copyLinearToSRGB(e){return this.r=rn(e.r),this.g=rn(e.g),this.b=rn(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){const t=this.r,n=this.g,i=this.b,r=Math.max(t,n,i),a=Math.min(t,n,i);let l,c;const h=(a+r)/2;if(a===r)l=0,c=0;else{const d=r-a;switch(c=h<=.5?d/(r+a):d/(2-r-a),r){case t:l=(n-i)/d+(n<i?6:0);break;case n:l=(i-t)/d+2;break;case i:l=(t-n)/d+4}l/=6}return e.h=l,e.s=c,e.l=h,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,n){return this.getHSL(zt),zt.h+=e,zt.s+=t,zt.l+=n,this.setHSL(zt.h,zt.s,zt.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(zt),e.getHSL(jt);const n=Vt(zt.h,jt.h,t),i=Vt(zt.s,jt.s,t),r=Vt(zt.l,jt.l,t);return this.setHSL(n,i,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}ut.NAMES=Rt,ut.prototype.isColor=!0,ut.prototype.r=1,ut.prototype.g=1,ut.prototype.b=1;class _n extends We{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new ut(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}_n.prototype.isMeshBasicMaterial=!0;const Kt=new H,On=new at;class $t{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),a=new ut),t[n++]=a.r,t[n++]=a.g,t[n++]=a.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),a=new at),t[n++]=a.x,t[n++]=a.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),a=new H),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let a=e[i];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),a=new en),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z,t[n++]=a.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)On.fromBufferAttribute(this,t),On.applyMatrix3(e),this.setXY(t,On.x,On.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)Kt.fromBufferAttribute(this,t),Kt.applyMatrix3(e),this.setXYZ(t,Kt.x,Kt.y,Kt.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Kt.x=this.getX(t),Kt.y=this.getY(t),Kt.z=this.getZ(t),Kt.applyMatrix4(e),this.setXYZ(t,Kt.x,Kt.y,Kt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Kt.x=this.getX(t),Kt.y=this.getY(t),Kt.z=this.getZ(t),Kt.applyNormalMatrix(e),this.setXYZ(t,Kt.x,Kt.y,Kt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Kt.x=this.getX(t),Kt.y=this.getY(t),Kt.z=this.getZ(t),Kt.transformDirection(e),this.setXYZ(t,Kt.x,Kt.y,Kt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==35044&&(e.usage=this.usage),this.updateRange.offset===0&&this.updateRange.count===-1||(e.updateRange=this.updateRange),e}}$t.prototype.isBufferAttribute=!0;class fi extends $t{constructor(e,t,n){super(new Int8Array(e),t,n)}}class Ai extends $t{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class li extends $t{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class Bi extends $t{constructor(e,t,n){super(new Int16Array(e),t,n)}}class mi extends $t{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class ri extends $t{constructor(e,t,n){super(new Int32Array(e),t,n)}}class kn extends $t{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class Hr extends $t{constructor(e,t,n){super(new Uint16Array(e),t,n)}}Hr.prototype.isFloat16BufferAttribute=!0;class Ot extends $t{constructor(e,t,n){super(new Float32Array(e),t,n)}}class dr extends $t{constructor(e,t,n){super(new Float64Array(e),t,n)}}function Us(s){if(s.length===0)return-1/0;let e=s[0];for(let t=1,n=s.length;t<n;++t)s[t]>e&&(e=s[t]);return e}const ma={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function pr(s,e){return new ma[s](e)}let Hs=0;const zi=new Dt,vo=new E,ds=new H,Li=new qn,Gs=new qn,Yn=new H;class Qt extends Re{constructor(){super(),Object.defineProperty(this,"id",{value:Hs++}),this.uuid=Ut(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Us(e)>65535?kn:mi)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new hn().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return zi.makeRotationFromQuaternion(e),this.applyMatrix4(zi),this}rotateX(e){return zi.makeRotationX(e),this.applyMatrix4(zi),this}rotateY(e){return zi.makeRotationY(e),this.applyMatrix4(zi),this}rotateZ(e){return zi.makeRotationZ(e),this.applyMatrix4(zi),this}translate(e,t,n){return zi.makeTranslation(e,t,n),this.applyMatrix4(zi),this}scale(e,t,n){return zi.makeScale(e,t,n),this.applyMatrix4(zi),this}lookAt(e){return vo.lookAt(e),vo.updateMatrix(),this.applyMatrix4(vo.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ds).negate(),this.translate(ds.x,ds.y,ds.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Ot(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new qn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new H(-1/0,-1/0,-1/0),new H(1/0,1/0,1/0));if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const r=t[n];Li.setFromBufferAttribute(r),this.morphTargetsRelative?(Yn.addVectors(this.boundingBox.min,Li.min),this.boundingBox.expandByPoint(Yn),Yn.addVectors(this.boundingBox.max,Li.max),this.boundingBox.expandByPoint(Yn)):(this.boundingBox.expandByPoint(Li.min),this.boundingBox.expandByPoint(Li.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Si);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new H,1/0);if(e){const n=this.boundingSphere.center;if(Li.setFromBufferAttribute(e),t)for(let r=0,a=t.length;r<a;r++){const l=t[r];Gs.setFromBufferAttribute(l),this.morphTargetsRelative?(Yn.addVectors(Li.min,Gs.min),Li.expandByPoint(Yn),Yn.addVectors(Li.max,Gs.max),Li.expandByPoint(Yn)):(Li.expandByPoint(Gs.min),Li.expandByPoint(Gs.max))}Li.getCenter(n);let i=0;for(let r=0,a=e.count;r<a;r++)Yn.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(Yn));if(t)for(let r=0,a=t.length;r<a;r++){const l=t[r],c=this.morphTargetsRelative;for(let h=0,d=l.count;h<d;h++)Yn.fromBufferAttribute(l,h),c&&(ds.fromBufferAttribute(e,h),Yn.add(ds)),i=Math.max(i,n.distanceToSquared(Yn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.array,i=t.position.array,r=t.normal.array,a=t.uv.array,l=i.length/3;t.tangent===void 0&&this.setAttribute("tangent",new $t(new Float32Array(4*l),4));const c=t.tangent.array,h=[],d=[];for(let Te=0;Te<l;Te++)h[Te]=new H,d[Te]=new H;const p=new H,f=new H,m=new H,y=new at,b=new at,T=new at,_=new H,F=new H;function U(Te,Ce,St){p.fromArray(i,3*Te),f.fromArray(i,3*Ce),m.fromArray(i,3*St),y.fromArray(a,2*Te),b.fromArray(a,2*Ce),T.fromArray(a,2*St),f.sub(p),m.sub(p),b.sub(y),T.sub(y);const ht=1/(b.x*T.y-T.x*b.y);isFinite(ht)&&(_.copy(f).multiplyScalar(T.y).addScaledVector(m,-b.y).multiplyScalar(ht),F.copy(m).multiplyScalar(b.x).addScaledVector(f,-T.x).multiplyScalar(ht),h[Te].add(_),h[Ce].add(_),h[St].add(_),d[Te].add(F),d[Ce].add(F),d[St].add(F))}let k=this.groups;k.length===0&&(k=[{start:0,count:n.length}]);for(let Te=0,Ce=k.length;Te<Ce;++Te){const St=k[Te],ht=St.start;for(let je=ht,ft=ht+St.count;je<ft;je+=3)U(n[je+0],n[je+1],n[je+2])}const X=new H,K=new H,ye=new H,we=new H;function Fe(Te){ye.fromArray(r,3*Te),we.copy(ye);const Ce=h[Te];X.copy(Ce),X.sub(ye.multiplyScalar(ye.dot(Ce))).normalize(),K.crossVectors(we,Ce);const St=K.dot(d[Te])<0?-1:1;c[4*Te]=X.x,c[4*Te+1]=X.y,c[4*Te+2]=X.z,c[4*Te+3]=St}for(let Te=0,Ce=k.length;Te<Ce;++Te){const St=k[Te],ht=St.start;for(let je=ht,ft=ht+St.count;je<ft;je+=3)Fe(n[je+0]),Fe(n[je+1]),Fe(n[je+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new $t(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let f=0,m=n.count;f<m;f++)n.setXYZ(f,0,0,0);const i=new H,r=new H,a=new H,l=new H,c=new H,h=new H,d=new H,p=new H;if(e)for(let f=0,m=e.count;f<m;f+=3){const y=e.getX(f+0),b=e.getX(f+1),T=e.getX(f+2);i.fromBufferAttribute(t,y),r.fromBufferAttribute(t,b),a.fromBufferAttribute(t,T),d.subVectors(a,r),p.subVectors(i,r),d.cross(p),l.fromBufferAttribute(n,y),c.fromBufferAttribute(n,b),h.fromBufferAttribute(n,T),l.add(d),c.add(d),h.add(d),n.setXYZ(y,l.x,l.y,l.z),n.setXYZ(b,c.x,c.y,c.z),n.setXYZ(T,h.x,h.y,h.z)}else for(let f=0,m=t.count;f<m;f+=3)i.fromBufferAttribute(t,f+0),r.fromBufferAttribute(t,f+1),a.fromBufferAttribute(t,f+2),d.subVectors(a,r),p.subVectors(i,r),d.cross(p),n.setXYZ(f+0,d.x,d.y,d.z),n.setXYZ(f+1,d.x,d.y,d.z),n.setXYZ(f+2,d.x,d.y,d.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(e.attributes[i]===void 0)continue;const r=n[i].array,a=e.attributes[i],l=a.array,c=a.itemSize*t,h=Math.min(l.length,r.length-c);for(let d=0,p=c;d<h;d++,p++)r[p]=l[d]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Yn.fromBufferAttribute(e,t),Yn.normalize(),e.setXYZ(t,Yn.x,Yn.y,Yn.z)}toNonIndexed(){function e(l,c){const h=l.array,d=l.itemSize,p=l.normalized,f=new h.constructor(c.length*d);let m=0,y=0;for(let b=0,T=c.length;b<T;b++){m=l.isInterleavedBufferAttribute?c[b]*l.data.stride+l.offset:c[b]*d;for(let _=0;_<d;_++)f[y++]=h[m++]}return new $t(f,d,p)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Qt,n=this.index.array,i=this.attributes;for(const l in i){const c=e(i[l],n);t.setAttribute(l,c)}const r=this.morphAttributes;for(const l in r){const c=[],h=r[l];for(let d=0,p=h.length;d<p;d++){const f=e(h[d],n);c.push(f)}t.morphAttributes[l]=c}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let l=0,c=a.length;l<c;l++){const h=a[l];t.addGroup(h.start,h.count,h.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const h in c)c[h]!==void 0&&(e[h]=c[h]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const c in n){const h=n[c];e.data.attributes[c]=h.toJSON(e.data)}const i={};let r=!1;for(const c in this.morphAttributes){const h=this.morphAttributes[c],d=[];for(let p=0,f=h.length;p<f;p++){const m=h[p];d.push(m.toJSON(e.data))}d.length>0&&(i[c]=d,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const l=this.boundingSphere;return l!==null&&(e.data.boundingSphere={center:l.center.toArray(),radius:l.radius}),e}clone(){return new Qt().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const h in i){const d=i[h];this.setAttribute(h,d.clone(t))}const r=e.morphAttributes;for(const h in r){const d=[],p=r[h];for(let f=0,m=p.length;f<m;f++)d.push(p[f].clone(t));this.morphAttributes[h]=d}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let h=0,d=a.length;h<d;h++){const p=a[h];this.addGroup(p.start,p.count,p.materialIndex)}const l=e.boundingBox;l!==null&&(this.boundingBox=l.clone());const c=e.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}Qt.prototype.isBufferGeometry=!0;const Fl=new Dt,ps=new Ti,xo=new Si,Er=new H,Ar=new H,Lr=new H,bo=new H,wo=new H,_o=new H,ga=new H,ya=new H,va=new H,xa=new at,ba=new at,wa=new at,Mo=new H,_a=new H;class Vn extends E{constructor(e=new Qt,t=new _n){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const l=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),xo.copy(n.boundingSphere),xo.applyMatrix4(r),e.ray.intersectsSphere(xo)===!1)||(Fl.copy(r).invert(),ps.copy(e.ray).applyMatrix4(Fl),n.boundingBox!==null&&ps.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){const l=n.index,c=n.attributes.position,h=n.morphAttributes.position,d=n.morphTargetsRelative,p=n.attributes.uv,f=n.attributes.uv2,m=n.groups,y=n.drawRange;if(l!==null)if(Array.isArray(i))for(let b=0,T=m.length;b<T;b++){const _=m[b],F=i[_.materialIndex];for(let U=Math.max(_.start,y.start),k=Math.min(_.start+_.count,y.start+y.count);U<k;U+=3){const X=l.getX(U),K=l.getX(U+1),ye=l.getX(U+2);a=Ma(this,F,e,ps,c,h,d,p,f,X,K,ye),a&&(a.faceIndex=Math.floor(U/3),a.face.materialIndex=_.materialIndex,t.push(a))}}else for(let b=Math.max(0,y.start),T=Math.min(l.count,y.start+y.count);b<T;b+=3){const _=l.getX(b),F=l.getX(b+1),U=l.getX(b+2);a=Ma(this,i,e,ps,c,h,d,p,f,_,F,U),a&&(a.faceIndex=Math.floor(b/3),t.push(a))}else if(c!==void 0)if(Array.isArray(i))for(let b=0,T=m.length;b<T;b++){const _=m[b],F=i[_.materialIndex];for(let U=Math.max(_.start,y.start),k=Math.min(_.start+_.count,y.start+y.count);U<k;U+=3)a=Ma(this,F,e,ps,c,h,d,p,f,U,U+1,U+2),a&&(a.faceIndex=Math.floor(U/3),a.face.materialIndex=_.materialIndex,t.push(a))}else for(let b=Math.max(0,y.start),T=Math.min(c.count,y.start+y.count);b<T;b+=3)a=Ma(this,i,e,ps,c,h,d,p,f,b,b+1,b+2),a&&(a.faceIndex=Math.floor(b/3),t.push(a))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function Ma(s,e,t,n,i,r,a,l,c,h,d,p){Er.fromBufferAttribute(i,h),Ar.fromBufferAttribute(i,d),Lr.fromBufferAttribute(i,p);const f=s.morphTargetInfluences;if(r&&f){ga.set(0,0,0),ya.set(0,0,0),va.set(0,0,0);for(let y=0,b=r.length;y<b;y++){const T=f[y],_=r[y];T!==0&&(bo.fromBufferAttribute(_,h),wo.fromBufferAttribute(_,d),_o.fromBufferAttribute(_,p),a?(ga.addScaledVector(bo,T),ya.addScaledVector(wo,T),va.addScaledVector(_o,T)):(ga.addScaledVector(bo.sub(Er),T),ya.addScaledVector(wo.sub(Ar),T),va.addScaledVector(_o.sub(Lr),T)))}Er.add(ga),Ar.add(ya),Lr.add(va)}s.isSkinnedMesh&&(s.boneTransform(h,Er),s.boneTransform(d,Ar),s.boneTransform(p,Lr));const m=function(y,b,T,_,F,U,k,X){let K;if(K=b.side===1?_.intersectTriangle(k,U,F,!0,X):_.intersectTriangle(F,U,k,b.side!==2,X),K===null)return null;_a.copy(X),_a.applyMatrix4(y.matrixWorld);const ye=T.ray.origin.distanceTo(_a);return ye<T.near||ye>T.far?null:{distance:ye,point:_a.clone(),object:y}}(s,e,t,n,Er,Ar,Lr,Mo);if(m){l&&(xa.fromBufferAttribute(l,h),ba.fromBufferAttribute(l,d),wa.fromBufferAttribute(l,p),m.uv=Ke.getUV(Mo,Er,Ar,Lr,xa,ba,wa,new at)),c&&(xa.fromBufferAttribute(c,h),ba.fromBufferAttribute(c,d),wa.fromBufferAttribute(c,p),m.uv2=Ke.getUV(Mo,Er,Ar,Lr,xa,ba,wa,new at));const y={a:h,b:d,c:p,normal:new H,materialIndex:0};Ke.getNormal(Er,Ar,Lr,y.normal),m.face=y}return m}Vn.prototype.isMesh=!0;class fr extends Qt{constructor(e=1,t=1,n=1,i=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:r,depthSegments:a};const l=this;i=Math.floor(i),r=Math.floor(r),a=Math.floor(a);const c=[],h=[],d=[],p=[];let f=0,m=0;function y(b,T,_,F,U,k,X,K,ye,we,Fe){const Te=k/ye,Ce=X/we,St=k/2,ht=X/2,je=K/2,ft=ye+1,Lt=we+1;let Pt=0,Ht=0;const Xt=new H;for(let Zt=0;Zt<Lt;Zt++){const pt=Zt*Ce-ht;for(let J=0;J<ft;J++){const ce=J*Te-St;Xt[b]=ce*F,Xt[T]=pt*U,Xt[_]=je,h.push(Xt.x,Xt.y,Xt.z),Xt[b]=0,Xt[T]=0,Xt[_]=K>0?1:-1,d.push(Xt.x,Xt.y,Xt.z),p.push(J/ye),p.push(1-Zt/we),Pt+=1}}for(let Zt=0;Zt<we;Zt++)for(let pt=0;pt<ye;pt++){const J=f+pt+ft*Zt,ce=f+pt+ft*(Zt+1),Je=f+(pt+1)+ft*(Zt+1),Ue=f+(pt+1)+ft*Zt;c.push(J,ce,Ue),c.push(ce,Je,Ue),Ht+=6}l.addGroup(m,Ht,Fe),m+=Ht,f+=Pt}y("z","y","x",-1,-1,n,t,e,a,r,0),y("z","y","x",1,-1,n,t,-e,a,r,1),y("x","z","y",1,1,e,n,t,i,a,2),y("x","z","y",1,-1,e,n,-t,i,a,3),y("x","y","z",1,-1,e,t,n,i,r,4),y("x","y","z",-1,-1,e,t,-n,i,r,5),this.setIndex(c),this.setAttribute("position",new Ot(h,3)),this.setAttribute("normal",new Ot(d,3)),this.setAttribute("uv",new Ot(p,2))}static fromJSON(e){return new fr(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function fs(s){const e={};for(const t in s){e[t]={};for(const n in s[t]){const i=s[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function ci(s){const e={};for(let t=0;t<s.length;t++){const n=fs(s[t]);for(const i in n)e[i]=n[i]}return e}const Nl={clone:fs,merge:ci};class mr extends We{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,this.fragmentShader=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=fs(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const r=this.uniforms[i].value;r&&r.isTexture?t.uniforms[i]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[i]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[i]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[i]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[i]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[i]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[i]={type:"m4",value:r.toArray()}:t.uniforms[i]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}mr.prototype.isShaderMaterial=!0;class Vs extends E{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Dt,this.projectionMatrix=new Dt,this.projectionMatrixInverse=new Dt}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Vs.prototype.isCamera=!0;class Jn extends Vs{constructor(e=50,t=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*Nt*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*It*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*Nt*Math.atan(Math.tan(.5*It*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,r,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*It*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const c=a.fullWidth,h=a.fullHeight;r+=a.offsetX*i/c,t-=a.offsetY*n/h,i*=a.width/c,n*=a.height/h}const l=this.filmOffset;l!==0&&(r+=e*l/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}Jn.prototype.isPerspectiveCamera=!0;const ms=90;class Sa extends E{constructor(e,t,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new Jn(ms,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new H(1,0,0)),this.add(i);const r=new Jn(ms,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new H(-1,0,0)),this.add(r);const a=new Jn(ms,1,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new H(0,1,0)),this.add(a);const l=new Jn(ms,1,e,t);l.layers=this.layers,l.up.set(0,0,-1),l.lookAt(new H(0,-1,0)),this.add(l);const c=new Jn(ms,1,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new H(0,0,1)),this.add(c);const h=new Jn(ms,1,e,t);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new H(0,0,-1)),this.add(h)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,a,l,c,h]=this.children,d=e.xr.enabled,p=e.getRenderTarget();e.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,r),e.setRenderTarget(n,2),e.render(t,a),e.setRenderTarget(n,3),e.render(t,l),e.setRenderTarget(n,4),e.render(t,c),n.texture.generateMipmaps=f,e.setRenderTarget(n,5),e.render(t,h),e.setRenderTarget(p),e.xr.enabled=d}}class gs extends wn{constructor(e,t,n,i,r,a,l,c,h,d){super(e=e!==void 0?e:[],t=t!==void 0?t:301,n,i,r,a,l=l!==void 0?l:1022,c,h,d),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}gs.prototype.isCubeTexture=!0;class Ta extends Nn{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),super(e,e,t),t=t||{},this.texture=new gs(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0&&t.generateMipmaps,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:1006,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=1023,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new fr(5,5,5),r=new mr({name:"CubemapFromEquirect",uniforms:fs(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:1,blending:0});r.uniforms.tEquirect.value=t;const a=new Vn(i,r),l=t.minFilter;return t.minFilter===1008&&(t.minFilter=1006),new Sa(1,10,this).update(e,a),t.minFilter=l,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,i){const r=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,i);e.setRenderTarget(r)}}Ta.prototype.isWebGLCubeRenderTarget=!0;const So=new H,Ih=new H,Dh=new hn;class nr{constructor(e=new H(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=So.subVectors(n,t).cross(Ih.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(So),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(n).multiplyScalar(r).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||Dh.getNormalMatrix(e),i=this.coplanarPoint(So).applyMatrix4(e),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}nr.prototype.isPlane=!0;const ys=new Si,Ea=new H;class Ws{constructor(e=new nr,t=new nr,n=new nr,i=new nr,r=new nr,a=new nr){this.planes=[e,t,n,i,r,a]}set(e,t,n,i,r,a){const l=this.planes;return l[0].copy(e),l[1].copy(t),l[2].copy(n),l[3].copy(i),l[4].copy(r),l[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,i=n[0],r=n[1],a=n[2],l=n[3],c=n[4],h=n[5],d=n[6],p=n[7],f=n[8],m=n[9],y=n[10],b=n[11],T=n[12],_=n[13],F=n[14],U=n[15];return t[0].setComponents(l-i,p-c,b-f,U-T).normalize(),t[1].setComponents(l+i,p+c,b+f,U+T).normalize(),t[2].setComponents(l+r,p+h,b+m,U+_).normalize(),t[3].setComponents(l-r,p-h,b-m,U-_).normalize(),t[4].setComponents(l-a,p-d,b-y,U-F).normalize(),t[5].setComponents(l+a,p+d,b+y,U+F).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),ys.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(ys)}intersectsSprite(e){return ys.center.set(0,0,0),ys.radius=.7071067811865476,ys.applyMatrix4(e.matrixWorld),this.intersectsSphere(ys)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(Ea.x=i.normal.x>0?e.max.x:e.min.x,Ea.y=i.normal.y>0?e.max.y:e.min.y,Ea.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Ea)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Bl(){let s=null,e=!1,t=null,n=null;function i(r,a){t(r,a),n=s.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=s.requestAnimationFrame(i),e=!0)},stop:function(){s.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){s=r}}}function Oh(s,e){const t=e.isWebGL2,n=new WeakMap;return{get:function(i){return i.isInterleavedBufferAttribute&&(i=i.data),n.get(i)},remove:function(i){i.isInterleavedBufferAttribute&&(i=i.data);const r=n.get(i);r&&(s.deleteBuffer(r.buffer),n.delete(i))},update:function(i,r){if(i.isGLBufferAttribute){const l=n.get(i);return void((!l||l.version<i.version)&&n.set(i,{buffer:i.buffer,type:i.type,bytesPerElement:i.elementSize,version:i.version}))}i.isInterleavedBufferAttribute&&(i=i.data);const a=n.get(i);a===void 0?n.set(i,function(l,c){const h=l.array,d=l.usage,p=s.createBuffer();s.bindBuffer(c,p),s.bufferData(c,h,d),l.onUploadCallback();let f=5126;return h instanceof Float32Array?f=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?l.isFloat16BufferAttribute?t?f=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):f=5123:h instanceof Int16Array?f=5122:h instanceof Uint32Array?f=5125:h instanceof Int32Array?f=5124:h instanceof Int8Array?f=5120:(h instanceof Uint8Array||h instanceof Uint8ClampedArray)&&(f=5121),{buffer:p,type:f,bytesPerElement:h.BYTES_PER_ELEMENT,version:l.version}}(i,r)):a.version<i.version&&(function(l,c,h){const d=c.array,p=c.updateRange;s.bindBuffer(h,l),p.count===-1?s.bufferSubData(h,0,d):(t?s.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):s.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}(a.buffer,i,r),a.version=i.version)}}}class Gr extends Qt{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const r=e/2,a=t/2,l=Math.floor(n),c=Math.floor(i),h=l+1,d=c+1,p=e/l,f=t/c,m=[],y=[],b=[],T=[];for(let _=0;_<d;_++){const F=_*f-a;for(let U=0;U<h;U++){const k=U*p-r;y.push(k,-F,0),b.push(0,0,1),T.push(U/l),T.push(1-_/c)}}for(let _=0;_<c;_++)for(let F=0;F<l;F++){const U=F+h*_,k=F+h*(_+1),X=F+1+h*(_+1),K=F+1+h*_;m.push(U,k,K),m.push(k,X,K)}this.setIndex(m),this.setAttribute("position",new Ot(y,3)),this.setAttribute("normal",new Ot(b,3)),this.setAttribute("uv",new Ot(T,2))}static fromJSON(e){return new Gr(e.width,e.height,e.widthSegments,e.heightSegments)}}const dn={alphamap_fragment:`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,alphamap_pars_fragment:`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment:`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,alphatest_pars_fragment:`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment:`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment:`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs:`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotVH = saturate( dot( geometry.viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float NoH ) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float NoV, float NoL ) {
	return saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );
}
vec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,bumpmap_pars_fragment:`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment:`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,clipping_planes_pars_fragment:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex:`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment:`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex:`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common:`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,cube_uv_reflection_fragment:`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex:`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex:`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex:`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment:`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment:`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,envmap_fragment:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment:`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment:`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex:`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_physical_pars_fragment:`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in GeometricContext geometry ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,envmap_vertex:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex:`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex:`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment:`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment:`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment:`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,lightmap_fragment:`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,lightmap_pars_fragment:`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_vertex:`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,lights_pars_begin:`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,lights_toon_fragment:`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment:`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,lights_phong_fragment:`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment:`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,lights_physical_fragment:`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularTintFactor = specularTint;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARTINTMAP
			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularTintFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenTint = sheenTint;
#endif`,lights_physical_pars_fragment:`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenTint;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(		0, 1,		0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin:`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps:`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end:`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,logdepthbuf_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment:`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,map_pars_fragment:`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment:`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment:`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphnormal_vertex:`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,morphtarget_pars_vertex:`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,morphtarget_vertex:`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,normal_fragment_begin:`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,normal_fragment_maps:`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment:`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex:`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex:`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment:`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,clearcoat_normal_fragment_begin:`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,clearcoat_normal_fragment_maps:`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,clearcoat_pars_fragment:`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,output_fragment:`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing:`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,premultiplied_alpha_fragment:`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex:`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment:`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment:`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment:`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment:`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
							f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
							f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,shadowmask_pars_fragment:`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex:`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex:`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,skinning_vertex:`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex:`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment:`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment:`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment:`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment:`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,	1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment:`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationTint, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = transmission.a;
#endif`,transmission_pars_fragment:`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationTint;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,uv_pars_fragment:`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,uv_pars_vertex:`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,uv_vertex:`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,uv2_pars_fragment:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,uv2_pars_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,uv2_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,worldpos_vertex:`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,background_frag:`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,cube_frag:`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,depth_vert:`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshbasic_vert:`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularTint;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARTINTMAP
		uniform sampler2D specularTintMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenTint;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,shadow_vert:`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`},Ct={common:{diffuse:{value:new ut(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new hn},uv2Transform:{value:new hn},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new at(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ut(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ut(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new hn}},sprite:{diffuse:{value:new ut(16777215)},opacity:{value:1},center:{value:new at(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new hn}}},Gi={basic:{uniforms:ci([Ct.common,Ct.specularmap,Ct.envmap,Ct.aomap,Ct.lightmap,Ct.fog]),vertexShader:dn.meshbasic_vert,fragmentShader:dn.meshbasic_frag},lambert:{uniforms:ci([Ct.common,Ct.specularmap,Ct.envmap,Ct.aomap,Ct.lightmap,Ct.emissivemap,Ct.fog,Ct.lights,{emissive:{value:new ut(0)}}]),vertexShader:dn.meshlambert_vert,fragmentShader:dn.meshlambert_frag},phong:{uniforms:ci([Ct.common,Ct.specularmap,Ct.envmap,Ct.aomap,Ct.lightmap,Ct.emissivemap,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,Ct.fog,Ct.lights,{emissive:{value:new ut(0)},specular:{value:new ut(1118481)},shininess:{value:30}}]),vertexShader:dn.meshphong_vert,fragmentShader:dn.meshphong_frag},standard:{uniforms:ci([Ct.common,Ct.envmap,Ct.aomap,Ct.lightmap,Ct.emissivemap,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,Ct.roughnessmap,Ct.metalnessmap,Ct.fog,Ct.lights,{emissive:{value:new ut(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:dn.meshphysical_vert,fragmentShader:dn.meshphysical_frag},toon:{uniforms:ci([Ct.common,Ct.aomap,Ct.lightmap,Ct.emissivemap,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,Ct.gradientmap,Ct.fog,Ct.lights,{emissive:{value:new ut(0)}}]),vertexShader:dn.meshtoon_vert,fragmentShader:dn.meshtoon_frag},matcap:{uniforms:ci([Ct.common,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,Ct.fog,{matcap:{value:null}}]),vertexShader:dn.meshmatcap_vert,fragmentShader:dn.meshmatcap_frag},points:{uniforms:ci([Ct.points,Ct.fog]),vertexShader:dn.points_vert,fragmentShader:dn.points_frag},dashed:{uniforms:ci([Ct.common,Ct.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:dn.linedashed_vert,fragmentShader:dn.linedashed_frag},depth:{uniforms:ci([Ct.common,Ct.displacementmap]),vertexShader:dn.depth_vert,fragmentShader:dn.depth_frag},normal:{uniforms:ci([Ct.common,Ct.bumpmap,Ct.normalmap,Ct.displacementmap,{opacity:{value:1}}]),vertexShader:dn.meshnormal_vert,fragmentShader:dn.meshnormal_frag},sprite:{uniforms:ci([Ct.sprite,Ct.fog]),vertexShader:dn.sprite_vert,fragmentShader:dn.sprite_frag},background:{uniforms:{uvTransform:{value:new hn},t2D:{value:null}},vertexShader:dn.background_vert,fragmentShader:dn.background_frag},cube:{uniforms:ci([Ct.envmap,{opacity:{value:1}}]),vertexShader:dn.cube_vert,fragmentShader:dn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:dn.equirect_vert,fragmentShader:dn.equirect_frag},distanceRGBA:{uniforms:ci([Ct.common,Ct.displacementmap,{referencePosition:{value:new H},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:dn.distanceRGBA_vert,fragmentShader:dn.distanceRGBA_frag},shadow:{uniforms:ci([Ct.lights,Ct.fog,{color:{value:new ut(0)},opacity:{value:1}}]),vertexShader:dn.shadow_vert,fragmentShader:dn.shadow_frag}};function Fh(s,e,t,n,i){const r=new ut(0);let a,l,c=0,h=null,d=0,p=null;function f(m,y){t.buffers.color.setClear(m.r,m.g,m.b,y,i)}return{getClearColor:function(){return r},setClearColor:function(m,y=1){r.set(m),c=y,f(r,c)},getClearAlpha:function(){return c},setClearAlpha:function(m){c=m,f(r,c)},render:function(m,y){let b=!1,T=y.isScene===!0?y.background:null;T&&T.isTexture&&(T=e.get(T));const _=s.xr,F=_.getSession&&_.getSession();F&&F.environmentBlendMode==="additive"&&(T=null),T===null?f(r,c):T&&T.isColor&&(f(T,1),b=!0),(s.autoClear||b)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),T&&(T.isCubeTexture||T.mapping===306)?(l===void 0&&(l=new Vn(new fr(1,1,1),new mr({name:"BackgroundCubeMaterial",uniforms:fs(Gi.cube.uniforms),vertexShader:Gi.cube.vertexShader,fragmentShader:Gi.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(U,k,X){this.matrixWorld.copyPosition(X.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(l)),l.material.uniforms.envMap.value=T,l.material.uniforms.flipEnvMap.value=T.isCubeTexture&&T.isRenderTargetTexture===!1?-1:1,h===T&&d===T.version&&p===s.toneMapping||(l.material.needsUpdate=!0,h=T,d=T.version,p=s.toneMapping),m.unshift(l,l.geometry,l.material,0,0,null)):T&&T.isTexture&&(a===void 0&&(a=new Vn(new Gr(2,2),new mr({name:"BackgroundMaterial",uniforms:fs(Gi.background.uniforms),vertexShader:Gi.background.vertexShader,fragmentShader:Gi.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(a)),a.material.uniforms.t2D.value=T,T.matrixAutoUpdate===!0&&T.updateMatrix(),a.material.uniforms.uvTransform.value.copy(T.matrix),h===T&&d===T.version&&p===s.toneMapping||(a.material.needsUpdate=!0,h=T,d=T.version,p=s.toneMapping),m.unshift(a,a.geometry,a.material,0,0,null))}}}function Nh(s,e,t,n){const i=s.getParameter(34921),r=n.isWebGL2?null:e.get("OES_vertex_array_object"),a=n.isWebGL2||r!==null,l={},c=f(null);let h=c;function d(k){return n.isWebGL2?s.bindVertexArray(k):r.bindVertexArrayOES(k)}function p(k){return n.isWebGL2?s.deleteVertexArray(k):r.deleteVertexArrayOES(k)}function f(k){const X=[],K=[],ye=[];for(let we=0;we<i;we++)X[we]=0,K[we]=0,ye[we]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:X,enabledAttributes:K,attributeDivisors:ye,object:k,attributes:{},index:null}}function m(){const k=h.newAttributes;for(let X=0,K=k.length;X<K;X++)k[X]=0}function y(k){b(k,0)}function b(k,X){const K=h.newAttributes,ye=h.enabledAttributes,we=h.attributeDivisors;K[k]=1,ye[k]===0&&(s.enableVertexAttribArray(k),ye[k]=1),we[k]!==X&&((n.isWebGL2?s:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](k,X),we[k]=X)}function T(){const k=h.newAttributes,X=h.enabledAttributes;for(let K=0,ye=X.length;K<ye;K++)X[K]!==k[K]&&(s.disableVertexAttribArray(K),X[K]=0)}function _(k,X,K,ye,we,Fe){n.isWebGL2!==!0||K!==5124&&K!==5125?s.vertexAttribPointer(k,X,K,ye,we,Fe):s.vertexAttribIPointer(k,X,K,we,Fe)}function F(){U(),h!==c&&(h=c,d(h.object))}function U(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function(k,X,K,ye,we){let Fe=!1;if(a){const Te=function(Ce,St,ht){const je=ht.wireframe===!0;let ft=l[Ce.id];ft===void 0&&(ft={},l[Ce.id]=ft);let Lt=ft[St.id];Lt===void 0&&(Lt={},ft[St.id]=Lt);let Pt=Lt[je];return Pt===void 0&&(Pt=f(n.isWebGL2?s.createVertexArray():r.createVertexArrayOES()),Lt[je]=Pt),Pt}(ye,K,X);h!==Te&&(h=Te,d(h.object)),Fe=function(Ce,St){const ht=h.attributes,je=Ce.attributes;let ft=0;for(const Lt in je){const Pt=ht[Lt],Ht=je[Lt];if(Pt===void 0||Pt.attribute!==Ht||Pt.data!==Ht.data)return!0;ft++}return h.attributesNum!==ft||h.index!==St}(ye,we),Fe&&function(Ce,St){const ht={},je=Ce.attributes;let ft=0;for(const Lt in je){const Pt=je[Lt],Ht={};Ht.attribute=Pt,Pt.data&&(Ht.data=Pt.data),ht[Lt]=Ht,ft++}h.attributes=ht,h.attributesNum=ft,h.index=St}(ye,we)}else{const Te=X.wireframe===!0;h.geometry===ye.id&&h.program===K.id&&h.wireframe===Te||(h.geometry=ye.id,h.program=K.id,h.wireframe=Te,Fe=!0)}k.isInstancedMesh===!0&&(Fe=!0),we!==null&&t.update(we,34963),Fe&&(function(Te,Ce,St,ht){if(n.isWebGL2===!1&&(Te.isInstancedMesh||ht.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;m();const je=ht.attributes,ft=St.getAttributes(),Lt=Ce.defaultAttributeValues;for(const Pt in ft){const Ht=ft[Pt];if(Ht.location>=0){let Xt=je[Pt];if(Xt===void 0&&(Pt==="instanceMatrix"&&Te.instanceMatrix&&(Xt=Te.instanceMatrix),Pt==="instanceColor"&&Te.instanceColor&&(Xt=Te.instanceColor)),Xt!==void 0){const Zt=Xt.normalized,pt=Xt.itemSize,J=t.get(Xt);if(J===void 0)continue;const ce=J.buffer,Je=J.type,Ue=J.bytesPerElement;if(Xt.isInterleavedBufferAttribute){const Pe=Xt.data,Mt=Pe.stride,_t=Xt.offset;if(Pe&&Pe.isInstancedInterleavedBuffer){for(let Ne=0;Ne<Ht.locationSize;Ne++)b(Ht.location+Ne,Pe.meshPerAttribute);Te.isInstancedMesh!==!0&&ht._maxInstanceCount===void 0&&(ht._maxInstanceCount=Pe.meshPerAttribute*Pe.count)}else for(let Ne=0;Ne<Ht.locationSize;Ne++)y(Ht.location+Ne);s.bindBuffer(34962,ce);for(let Ne=0;Ne<Ht.locationSize;Ne++)_(Ht.location+Ne,pt/Ht.locationSize,Je,Zt,Mt*Ue,(_t+pt/Ht.locationSize*Ne)*Ue)}else{if(Xt.isInstancedBufferAttribute){for(let Pe=0;Pe<Ht.locationSize;Pe++)b(Ht.location+Pe,Xt.meshPerAttribute);Te.isInstancedMesh!==!0&&ht._maxInstanceCount===void 0&&(ht._maxInstanceCount=Xt.meshPerAttribute*Xt.count)}else for(let Pe=0;Pe<Ht.locationSize;Pe++)y(Ht.location+Pe);s.bindBuffer(34962,ce);for(let Pe=0;Pe<Ht.locationSize;Pe++)_(Ht.location+Pe,pt/Ht.locationSize,Je,Zt,pt*Ue,pt/Ht.locationSize*Pe*Ue)}}else if(Lt!==void 0){const Zt=Lt[Pt];if(Zt!==void 0)switch(Zt.length){case 2:s.vertexAttrib2fv(Ht.location,Zt);break;case 3:s.vertexAttrib3fv(Ht.location,Zt);break;case 4:s.vertexAttrib4fv(Ht.location,Zt);break;default:s.vertexAttrib1fv(Ht.location,Zt)}}}}T()}(k,X,K,ye),we!==null&&s.bindBuffer(34963,t.get(we).buffer))},reset:F,resetDefaultState:U,dispose:function(){F();for(const k in l){const X=l[k];for(const K in X){const ye=X[K];for(const we in ye)p(ye[we].object),delete ye[we];delete X[K]}delete l[k]}},releaseStatesOfGeometry:function(k){if(l[k.id]===void 0)return;const X=l[k.id];for(const K in X){const ye=X[K];for(const we in ye)p(ye[we].object),delete ye[we];delete X[K]}delete l[k.id]},releaseStatesOfProgram:function(k){for(const X in l){const K=l[X];if(K[k.id]===void 0)continue;const ye=K[k.id];for(const we in ye)p(ye[we].object),delete ye[we];delete K[k.id]}},initAttributes:m,enableAttribute:y,disableUnusedAttributes:T}}function Bh(s,e,t,n){const i=n.isWebGL2;let r;this.setMode=function(a){r=a},this.render=function(a,l){s.drawArrays(r,a,l),t.update(l,r,1)},this.renderInstances=function(a,l,c){if(c===0)return;let h,d;if(i)h=s,d="drawArraysInstanced";else if(h=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",h===null)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[d](r,a,l,c),t.update(l,r,c)}}function zh(s,e,t){let n;function i(k){if(k==="highp"){if(s.getShaderPrecisionFormat(35633,36338).precision>0&&s.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";k="mediump"}return k==="mediump"&&s.getShaderPrecisionFormat(35633,36337).precision>0&&s.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const r=typeof WebGL2RenderingContext<"u"&&s instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&s instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=i(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=r||e.has("WEBGL_draw_buffers"),h=t.logarithmicDepthBuffer===!0,d=s.getParameter(34930),p=s.getParameter(35660),f=s.getParameter(3379),m=s.getParameter(34076),y=s.getParameter(34921),b=s.getParameter(36347),T=s.getParameter(36348),_=s.getParameter(36349),F=p>0,U=r||e.has("OES_texture_float");return{isWebGL2:r,drawBuffers:c,getMaxAnisotropy:function(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const k=e.get("EXT_texture_filter_anisotropic");n=s.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n},getMaxPrecision:i,precision:a,logarithmicDepthBuffer:h,maxTextures:d,maxVertexTextures:p,maxTextureSize:f,maxCubemapSize:m,maxAttributes:y,maxVertexUniforms:b,maxVaryings:T,maxFragmentUniforms:_,vertexTextures:F,floatFragmentTextures:U,floatVertexTextures:F&&U,maxSamples:r?s.getParameter(36183):0}}function kh(s){const e=this;let t=null,n=0,i=!1,r=!1;const a=new nr,l=new hn,c={value:null,needsUpdate:!1};function h(){c.value!==t&&(c.value=t,c.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function d(p,f,m,y){const b=p!==null?p.length:0;let T=null;if(b!==0){if(T=c.value,y!==!0||T===null){const _=m+4*b,F=f.matrixWorldInverse;l.getNormalMatrix(F),(T===null||T.length<_)&&(T=new Float32Array(_));for(let U=0,k=m;U!==b;++U,k+=4)a.copy(p[U]).applyMatrix4(F,l),a.normal.toArray(T,k),T[k+3]=a.constant}c.value=T,c.needsUpdate=!0}return e.numPlanes=b,e.numIntersection=0,T}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(p,f,m){const y=p.length!==0||f||n!==0||i;return i=f,t=d(p,m,0),n=p.length,y},this.beginShadows=function(){r=!0,d(null)},this.endShadows=function(){r=!1,h()},this.setState=function(p,f,m){const y=p.clippingPlanes,b=p.clipIntersection,T=p.clipShadows,_=s.get(p);if(!i||y===null||y.length===0||r&&!T)r?d(null):h();else{const F=r?0:n,U=4*F;let k=_.clippingState||null;c.value=k,k=d(y,f,U,m);for(let X=0;X!==U;++X)k[X]=t[X];_.clippingState=k,this.numIntersection=b?this.numPlanes:0,this.numPlanes+=F}}}function Uh(s){let e=new WeakMap;function t(i,r){return r===303?i.mapping=301:r===304&&(i.mapping=302),i}function n(i){const r=i.target;r.removeEventListener("dispose",n);const a=e.get(r);a!==void 0&&(e.delete(r),a.dispose())}return{get:function(i){if(i&&i.isTexture&&i.isRenderTargetTexture===!1){const r=i.mapping;if(r===303||r===304){if(e.has(i))return t(e.get(i).texture,i.mapping);{const a=i.image;if(a&&a.height>0){const l=s.getRenderTarget(),c=new Ta(a.height/2);return c.fromEquirectangularTexture(s,i),e.set(i,c),s.setRenderTarget(l),i.addEventListener("dispose",n),t(c.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}Gi.physical={uniforms:ci([Gi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new at(1,1)},clearcoatNormalMap:{value:null},sheenTint:{value:new ut(0)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new at},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new ut(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new ut(1,1,1)},specularTintMap:{value:null}}]),vertexShader:dn.meshphysical_vert,fragmentShader:dn.meshphysical_frag};class js extends Vs{constructor(e=-1,t=1,n=1,i=-1,r=.1,a=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-e,a=n+e,l=i+t,c=i-t;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,d=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=h*this.view.offsetX,a=r+h*this.view.width,l-=d*this.view.offsetY,c=l-d*this.view.height}this.projectionMatrix.makeOrthographic(r,a,l,c,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}js.prototype.isOrthographicCamera=!0;class vs extends mr{constructor(e){super(e),this.type="RawShaderMaterial"}}vs.prototype.isRawShaderMaterial=!0;const ir=Math.pow(2,8),zl=[.125,.215,.35,.446,.526,.582],kl=5+zl.length,Aa=20,rr={3e3:0,3001:1,3002:2,3004:3,3005:4,3006:5,3007:6},To=new js,{_lodPlanes:qs,_sizeLods:Ul,_sigmas:La}=Gh(),Hl=new ut;let Eo=null;const Vr=(1+Math.sqrt(5))/2,xs=1/Vr,Gl=[new H(1,1,1),new H(-1,1,1),new H(1,1,-1),new H(-1,1,-1),new H(0,Vr,xs),new H(0,Vr,-xs),new H(xs,0,Vr),new H(-xs,0,Vr),new H(Vr,xs,0),new H(-Vr,xs,0)];class Vl{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const n=new Float32Array(t),i=new H(0,1,0);return new vs({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i},inputEncoding:{value:rr[3e3]},outputEncoding:{value:rr[3e3]}},vertexShader:Ao(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Lo()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}(Aa),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){Eo=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(e,n,i,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=ql(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=jl(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<qs.length;e++)qs[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Eo),e.scissorTest=!1,Ra(e,0,0,e.width,e.height)}_fromTexture(e){Eo=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:1003,minFilter:1003,generateMipmaps:!1,type:1009,format:1023,encoding:Hh(e)?e.encoding:3002,depthBuffer:!1},n=Wl(t);return n.depthBuffer=!e,this._pingPongRenderTarget=Wl(t),n}_compileMaterial(e){const t=new Vn(qs[0],e);this._renderer.compile(t,To)}_sceneToCubeUV(e,t,n,i){const r=new Jn(90,1,t,n),a=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],c=this._renderer,h=c.autoClear,d=c.outputEncoding,p=c.toneMapping;c.getClearColor(Hl),c.toneMapping=0,c.outputEncoding=3e3,c.autoClear=!1;const f=new _n({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),m=new Vn(new fr,f);let y=!1;const b=e.background;b?b.isColor&&(f.color.copy(b),e.background=null,y=!0):(f.color.copy(Hl),y=!0);for(let T=0;T<6;T++){const _=T%3;_==0?(r.up.set(0,a[T],0),r.lookAt(l[T],0,0)):_==1?(r.up.set(0,0,a[T]),r.lookAt(0,l[T],0)):(r.up.set(0,a[T],0),r.lookAt(0,0,l[T])),Ra(i,_*ir,T>2?ir:0,ir,ir),c.setRenderTarget(i),y&&c.render(m,r),c.render(e,r)}m.geometry.dispose(),m.material.dispose(),c.toneMapping=p,c.outputEncoding=d,c.autoClear=h,e.background=b}_textureToCubeUV(e,t){const n=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=ql()):this._equirectShader==null&&(this._equirectShader=jl());const i=e.isCubeTexture?this._cubemapShader:this._equirectShader,r=new Vn(qs[0],i),a=i.uniforms;a.envMap.value=e,e.isCubeTexture||a.texelSize.value.set(1/e.image.width,1/e.image.height),a.inputEncoding.value=rr[e.encoding],a.outputEncoding.value=rr[t.texture.encoding],Ra(t,0,0,3*ir,2*ir),n.setRenderTarget(t),n.render(r,To)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<kl;i++){const r=Math.sqrt(La[i]*La[i]-La[i-1]*La[i-1]),a=Gl[(i-1)%Gl.length];this._blur(e,i-1,i,r,a)}t.autoClear=n}_blur(e,t,n,i,r){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,i,"latitudinal",r),this._halfBlur(a,e,n,n,i,"longitudinal",r)}_halfBlur(e,t,n,i,r,a,l){const c=this._renderer,h=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const d=new Vn(qs[i],h),p=h.uniforms,f=Ul[n]-1,m=isFinite(r)?Math.PI/(2*f):2*Math.PI/39,y=r/m,b=isFinite(r)?1+Math.floor(3*y):Aa;b>Aa&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${b} samples when the maximum is set to 20`);const T=[];let _=0;for(let U=0;U<Aa;++U){const k=U/y,X=Math.exp(-k*k/2);T.push(X),U==0?_+=X:U<b&&(_+=2*X)}for(let U=0;U<T.length;U++)T[U]=T[U]/_;p.envMap.value=e.texture,p.samples.value=b,p.weights.value=T,p.latitudinal.value=a==="latitudinal",l&&(p.poleAxis.value=l),p.dTheta.value=m,p.mipInt.value=8-n,p.inputEncoding.value=rr[e.texture.encoding],p.outputEncoding.value=rr[e.texture.encoding];const F=Ul[i];Ra(t,3*Math.max(0,ir-2*F),(i===0?0:2*ir)+2*F*(i>4?i-8+4:0),3*F,2*F),c.setRenderTarget(t),c.render(d,To)}}function Hh(s){return s!==void 0&&s.type===1009&&(s.encoding===3e3||s.encoding===3001||s.encoding===3007)}function Gh(){const s=[],e=[],t=[];let n=8;for(let i=0;i<kl;i++){const r=Math.pow(2,n);e.push(r);let a=1/r;i>4?a=zl[i-8+4-1]:i==0&&(a=0),t.push(a);const l=1/(r-1),c=-l/2,h=1+l/2,d=[c,c,h,c,h,h,c,c,h,h,c,h],p=6,f=6,m=3,y=2,b=1,T=new Float32Array(m*f*p),_=new Float32Array(y*f*p),F=new Float32Array(b*f*p);for(let k=0;k<p;k++){const X=k%3*2/3-1,K=k>2?0:-1,ye=[X,K,0,X+2/3,K,0,X+2/3,K+1,0,X,K,0,X+2/3,K+1,0,X,K+1,0];T.set(ye,m*f*k),_.set(d,y*f*k);const we=[k,k,k,k,k,k];F.set(we,b*f*k)}const U=new Qt;U.setAttribute("position",new $t(T,m)),U.setAttribute("uv",new $t(_,y)),U.setAttribute("faceIndex",new $t(F,b)),s.push(U),n>4&&n--}return{_lodPlanes:s,_sizeLods:e,_sigmas:t}}function Wl(s){const e=new Nn(3*ir,3*ir,s);return e.texture.mapping=306,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function Ra(s,e,t,n,i){s.viewport.set(e,t,n,i),s.scissor.set(e,t,n,i)}function jl(){const s=new at(1,1);return new vs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:s},inputEncoding:{value:rr[3e3]},outputEncoding:{value:rr[3e3]}},vertexShader:Ao(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Lo()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function ql(){return new vs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:rr[3e3]},outputEncoding:{value:rr[3e3]}},vertexShader:Ao(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Lo()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function Ao(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Lo(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function Vh(s){let e=new WeakMap,t=null;function n(i){const r=i.target;r.removeEventListener("dispose",n);const a=e.get(r);a!==void 0&&(e.delete(r),a.dispose())}return{get:function(i){if(i&&i.isTexture&&i.isRenderTargetTexture===!1){const r=i.mapping,a=r===303||r===304,l=r===301||r===302;if(a||l){if(e.has(i))return e.get(i).texture;{const c=i.image;if(a&&c&&c.height>0||l&&c&&function(h){let d=0;const p=6;for(let f=0;f<p;f++)h[f]!==void 0&&d++;return d===p}(c)){const h=s.getRenderTarget();t===null&&(t=new Vl(s));const d=a?t.fromEquirectangular(i):t.fromCubemap(i);return e.set(i,d),s.setRenderTarget(h),i.addEventListener("dispose",n),d.texture}return null}}}return i},dispose:function(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}}}function Wh(s){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=s.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(n){const i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function jh(s,e,t,n){const i={},r=new WeakMap;function a(c){const h=c.target;h.index!==null&&e.remove(h.index);for(const p in h.attributes)e.remove(h.attributes[p]);h.removeEventListener("dispose",a),delete i[h.id];const d=r.get(h);d&&(e.remove(d),r.delete(h)),n.releaseStatesOfGeometry(h),h.isInstancedBufferGeometry===!0&&delete h._maxInstanceCount,t.memory.geometries--}function l(c){const h=[],d=c.index,p=c.attributes.position;let f=0;if(d!==null){const b=d.array;f=d.version;for(let T=0,_=b.length;T<_;T+=3){const F=b[T+0],U=b[T+1],k=b[T+2];h.push(F,U,U,k,k,F)}}else{const b=p.array;f=p.version;for(let T=0,_=b.length/3-1;T<_;T+=3){const F=T+0,U=T+1,k=T+2;h.push(F,U,U,k,k,F)}}const m=new(Us(h)>65535?kn:mi)(h,1);m.version=f;const y=r.get(c);y&&e.remove(y),r.set(c,m)}return{get:function(c,h){return i[h.id]===!0||(h.addEventListener("dispose",a),i[h.id]=!0,t.memory.geometries++),h},update:function(c){const h=c.attributes;for(const p in h)e.update(h[p],34962);const d=c.morphAttributes;for(const p in d){const f=d[p];for(let m=0,y=f.length;m<y;m++)e.update(f[m],34962)}},getWireframeAttribute:function(c){const h=r.get(c);if(h){const d=c.index;d!==null&&h.version<d.version&&l(c)}else l(c);return r.get(c)}}}function qh(s,e,t,n){const i=n.isWebGL2;let r,a,l;this.setMode=function(c){r=c},this.setIndex=function(c){a=c.type,l=c.bytesPerElement},this.render=function(c,h){s.drawElements(r,h,a,c*l),t.update(h,r,1)},this.renderInstances=function(c,h,d){if(d===0)return;let p,f;if(i)p=s,f="drawElementsInstanced";else if(p=e.get("ANGLE_instanced_arrays"),f="drawElementsInstancedANGLE",p===null)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");p[f](r,h,a,c*l,d),t.update(h,r,d)}}function Xh(s){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,i){switch(e.calls++,n){case 4:e.triangles+=i*(t/3);break;case 1:e.lines+=i*(t/2);break;case 3:e.lines+=i*(t-1);break;case 2:e.lines+=i*t;break;case 0:e.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function Zh(s,e){return s[0]-e[0]}function Yh(s,e){return Math.abs(e[1])-Math.abs(s[1])}function Jh(s){const e={},t=new Float32Array(8),n=[];for(let i=0;i<8;i++)n[i]=[i,0];return{update:function(i,r,a,l){const c=i.morphTargetInfluences,h=c===void 0?0:c.length;let d=e[r.id];if(d===void 0||d.length!==h){d=[];for(let b=0;b<h;b++)d[b]=[b,0];e[r.id]=d}for(let b=0;b<h;b++){const T=d[b];T[0]=b,T[1]=c[b]}d.sort(Yh);for(let b=0;b<8;b++)b<h&&d[b][1]?(n[b][0]=d[b][0],n[b][1]=d[b][1]):(n[b][0]=Number.MAX_SAFE_INTEGER,n[b][1]=0);n.sort(Zh);const p=r.morphAttributes.position,f=r.morphAttributes.normal;let m=0;for(let b=0;b<8;b++){const T=n[b],_=T[0],F=T[1];_!==Number.MAX_SAFE_INTEGER&&F?(p&&r.getAttribute("morphTarget"+b)!==p[_]&&r.setAttribute("morphTarget"+b,p[_]),f&&r.getAttribute("morphNormal"+b)!==f[_]&&r.setAttribute("morphNormal"+b,f[_]),t[b]=F,m+=F):(p&&r.hasAttribute("morphTarget"+b)===!0&&r.deleteAttribute("morphTarget"+b),f&&r.hasAttribute("morphNormal"+b)===!0&&r.deleteAttribute("morphNormal"+b),t[b]=0)}const y=r.morphTargetsRelative?1:1-m;l.getUniforms().setValue(s,"morphTargetBaseInfluence",y),l.getUniforms().setValue(s,"morphTargetInfluences",t)}}}function Kh(s,e,t,n){let i=new WeakMap;function r(a){const l=a.target;l.removeEventListener("dispose",r),t.remove(l.instanceMatrix),l.instanceColor!==null&&t.remove(l.instanceColor)}return{update:function(a){const l=n.render.frame,c=a.geometry,h=e.get(a,c);return i.get(h)!==l&&(e.update(h),i.set(h,l)),a.isInstancedMesh&&(a.hasEventListener("dispose",r)===!1&&a.addEventListener("dispose",r),t.update(a.instanceMatrix,34962),a.instanceColor!==null&&t.update(a.instanceColor,34962)),h},dispose:function(){i=new WeakMap}}}class Ro extends wn{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Ro.prototype.isDataTexture2DArray=!0;class Co extends wn{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Co.prototype.isDataTexture3D=!0;const Xl=new wn,Qh=new Ro,$h=new Co,Zl=new gs,Yl=[],Jl=[],Kl=new Float32Array(16),Ql=new Float32Array(9),$l=new Float32Array(4);function bs(s,e,t){const n=s[0];if(n<=0||n>0)return s;const i=e*t;let r=Yl[i];if(r===void 0&&(r=new Float32Array(i),Yl[i]=r),e!==0){n.toArray(r,0);for(let a=1,l=0;a!==e;++a)l+=t,s[a].toArray(r,l)}return r}function gi(s,e){if(s.length!==e.length)return!1;for(let t=0,n=s.length;t<n;t++)if(s[t]!==e[t])return!1;return!0}function ui(s,e){for(let t=0,n=e.length;t<n;t++)s[t]=e[t]}function ec(s,e){let t=Jl[e];t===void 0&&(t=new Int32Array(e),Jl[e]=t);for(let n=0;n!==e;++n)t[n]=s.allocateTextureUnit();return t}function ed(s,e){const t=this.cache;t[0]!==e&&(s.uniform1f(this.addr,e),t[0]=e)}function td(s,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y||(s.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(gi(t,e))return;s.uniform2fv(this.addr,e),ui(t,e)}}function nd(s,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(s.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)t[0]===e.r&&t[1]===e.g&&t[2]===e.b||(s.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(gi(t,e))return;s.uniform3fv(this.addr,e),ui(t,e)}}function id(s,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(s.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(gi(t,e))return;s.uniform4fv(this.addr,e),ui(t,e)}}function rd(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(gi(t,e))return;s.uniformMatrix2fv(this.addr,!1,e),ui(t,e)}else{if(gi(t,n))return;$l.set(n),s.uniformMatrix2fv(this.addr,!1,$l),ui(t,n)}}function sd(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(gi(t,e))return;s.uniformMatrix3fv(this.addr,!1,e),ui(t,e)}else{if(gi(t,n))return;Ql.set(n),s.uniformMatrix3fv(this.addr,!1,Ql),ui(t,n)}}function ad(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(gi(t,e))return;s.uniformMatrix4fv(this.addr,!1,e),ui(t,e)}else{if(gi(t,n))return;Kl.set(n),s.uniformMatrix4fv(this.addr,!1,Kl),ui(t,n)}}function od(s,e){const t=this.cache;t[0]!==e&&(s.uniform1i(this.addr,e),t[0]=e)}function ld(s,e){const t=this.cache;gi(t,e)||(s.uniform2iv(this.addr,e),ui(t,e))}function cd(s,e){const t=this.cache;gi(t,e)||(s.uniform3iv(this.addr,e),ui(t,e))}function ud(s,e){const t=this.cache;gi(t,e)||(s.uniform4iv(this.addr,e),ui(t,e))}function hd(s,e){const t=this.cache;t[0]!==e&&(s.uniform1ui(this.addr,e),t[0]=e)}function dd(s,e){const t=this.cache;gi(t,e)||(s.uniform2uiv(this.addr,e),ui(t,e))}function pd(s,e){const t=this.cache;gi(t,e)||(s.uniform3uiv(this.addr,e),ui(t,e))}function fd(s,e){const t=this.cache;gi(t,e)||(s.uniform4uiv(this.addr,e),ui(t,e))}function md(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.safeSetTexture2D(e||Xl,i)}function gd(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||$h,i)}function yd(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.safeSetTextureCube(e||Zl,i)}function vd(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||Qh,i)}function xd(s,e){s.uniform1fv(this.addr,e)}function bd(s,e){const t=bs(e,this.size,2);s.uniform2fv(this.addr,t)}function wd(s,e){const t=bs(e,this.size,3);s.uniform3fv(this.addr,t)}function _d(s,e){const t=bs(e,this.size,4);s.uniform4fv(this.addr,t)}function Md(s,e){const t=bs(e,this.size,4);s.uniformMatrix2fv(this.addr,!1,t)}function Sd(s,e){const t=bs(e,this.size,9);s.uniformMatrix3fv(this.addr,!1,t)}function Td(s,e){const t=bs(e,this.size,16);s.uniformMatrix4fv(this.addr,!1,t)}function Ed(s,e){s.uniform1iv(this.addr,e)}function Ad(s,e){s.uniform2iv(this.addr,e)}function Ld(s,e){s.uniform3iv(this.addr,e)}function Rd(s,e){s.uniform4iv(this.addr,e)}function Cd(s,e){s.uniform1uiv(this.addr,e)}function Pd(s,e){s.uniform2uiv(this.addr,e)}function Id(s,e){s.uniform3uiv(this.addr,e)}function Dd(s,e){s.uniform4uiv(this.addr,e)}function Od(s,e,t){const n=e.length,i=ec(t,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.safeSetTexture2D(e[r]||Xl,i[r])}function Fd(s,e,t){const n=e.length,i=ec(t,n);s.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.safeSetTextureCube(e[r]||Zl,i[r])}function Nd(s,e,t){this.id=s,this.addr=t,this.cache=[],this.setValue=function(n){switch(n){case 5126:return ed;case 35664:return td;case 35665:return nd;case 35666:return id;case 35674:return rd;case 35675:return sd;case 35676:return ad;case 5124:case 35670:return od;case 35667:case 35671:return ld;case 35668:case 35672:return cd;case 35669:case 35673:return ud;case 5125:return hd;case 36294:return dd;case 36295:return pd;case 36296:return fd;case 35678:case 36198:case 36298:case 36306:case 35682:return md;case 35679:case 36299:case 36307:return gd;case 35680:case 36300:case 36308:case 36293:return yd;case 36289:case 36303:case 36311:case 36292:return vd}}(e.type)}function tc(s,e,t){this.id=s,this.addr=t,this.cache=[],this.size=e.size,this.setValue=function(n){switch(n){case 5126:return xd;case 35664:return bd;case 35665:return wd;case 35666:return _d;case 35674:return Md;case 35675:return Sd;case 35676:return Td;case 5124:case 35670:return Ed;case 35667:case 35671:return Ad;case 35668:case 35672:return Ld;case 35669:case 35673:return Rd;case 5125:return Cd;case 36294:return Pd;case 36295:return Id;case 36296:return Dd;case 35678:case 36198:case 36298:case 36306:case 35682:return Od;case 35680:case 36300:case 36308:case 36293:return Fd}}(e.type)}function nc(s){this.id=s,this.seq=[],this.map={}}tc.prototype.updateCache=function(s){const e=this.cache;s instanceof Float32Array&&e.length!==s.length&&(this.cache=new Float32Array(s.length)),ui(e,s)},nc.prototype.setValue=function(s,e,t){const n=this.seq;for(let i=0,r=n.length;i!==r;++i){const a=n[i];a.setValue(s,e[a.id],t)}};const Po=/(\w+)(\])?(\[|\.)?/g;function ic(s,e){s.seq.push(e),s.map[e.id]=e}function Bd(s,e,t){const n=s.name,i=n.length;for(Po.lastIndex=0;;){const r=Po.exec(n),a=Po.lastIndex;let l=r[1];const c=r[2]==="]",h=r[3];if(c&&(l|=0),h===void 0||h==="["&&a+2===i){ic(t,h===void 0?new Nd(l,s,e):new tc(l,s,e));break}{let d=t.map[l];d===void 0&&(d=new nc(l),ic(t,d)),t=d}}}function Rr(s,e){this.seq=[],this.map={};const t=s.getProgramParameter(e,35718);for(let n=0;n<t;++n){const i=s.getActiveUniform(e,n);Bd(i,s.getUniformLocation(e,i.name),this)}}function rc(s,e,t){const n=s.createShader(e);return s.shaderSource(n,t),s.compileShader(n),n}Rr.prototype.setValue=function(s,e,t,n){const i=this.map[e];i!==void 0&&i.setValue(s,t,n)},Rr.prototype.setOptional=function(s,e,t){const n=e[t];n!==void 0&&this.setValue(s,t,n)},Rr.upload=function(s,e,t,n){for(let i=0,r=e.length;i!==r;++i){const a=e[i],l=t[a.id];l.needsUpdate!==!1&&a.setValue(s,l.value,n)}},Rr.seqWithValue=function(s,e){const t=[];for(let n=0,i=s.length;n!==i;++n){const r=s[n];r.id in e&&t.push(r)}return t};let zd=0;function sc(s){switch(s){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",s),["Linear","( value )"]}}function ac(s,e,t){const n=s.getShaderParameter(e,35713),i=s.getShaderInfoLog(e).trim();return n&&i===""?"":t.toUpperCase()+`

`+i+`

`+function(r){const a=r.split(`
`);for(let l=0;l<a.length;l++)a[l]=l+1+": "+a[l];return a.join(`
`)}(s.getShaderSource(e))}function ws(s,e){const t=sc(e);return"vec4 "+s+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function kd(s,e){const t=sc(e);return"vec4 "+s+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function Ud(s,e){let t;switch(e){case 1:t="Linear";break;case 2:t="Reinhard";break;case 3:t="OptimizedCineon";break;case 4:t="ACESFilmic";break;case 5:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+s+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Xs(s){return s!==""}function oc(s,e){return s.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function lc(s,e){return s.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Hd=/^[ \t]*#include +<([\w\d./]+)>/gm;function Io(s){return s.replace(Hd,Gd)}function Gd(s,e){const t=dn[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Io(t)}const Vd=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Wd=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function cc(s){return s.replace(Wd,uc).replace(Vd,jd)}function jd(s,e,t,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),uc(s,e,t,n)}function uc(s,e,t,n){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function hc(s){let e="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?e+=`
#define HIGH_PRECISION`:s.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function qd(s,e,t,n){const i=s.getContext(),r=t.defines;let a=t.vertexShader,l=t.fragmentShader;const c=function(we){let Fe="SHADOWMAP_TYPE_BASIC";return we.shadowMapType===1?Fe="SHADOWMAP_TYPE_PCF":we.shadowMapType===2?Fe="SHADOWMAP_TYPE_PCF_SOFT":we.shadowMapType===3&&(Fe="SHADOWMAP_TYPE_VSM"),Fe}(t),h=function(we){let Fe="ENVMAP_TYPE_CUBE";if(we.envMap)switch(we.envMapMode){case 301:case 302:Fe="ENVMAP_TYPE_CUBE";break;case 306:case 307:Fe="ENVMAP_TYPE_CUBE_UV"}return Fe}(t),d=function(we){let Fe="ENVMAP_MODE_REFLECTION";if(we.envMap)switch(we.envMapMode){case 302:case 307:Fe="ENVMAP_MODE_REFRACTION"}return Fe}(t),p=function(we){let Fe="ENVMAP_BLENDING_NONE";if(we.envMap)switch(we.combine){case 0:Fe="ENVMAP_BLENDING_MULTIPLY";break;case 1:Fe="ENVMAP_BLENDING_MIX";break;case 2:Fe="ENVMAP_BLENDING_ADD"}return Fe}(t),f=s.gammaFactor>0?s.gammaFactor:1,m=t.isWebGL2?"":function(we){return[we.extensionDerivatives||we.envMapCubeUV||we.bumpMap||we.tangentSpaceNormalMap||we.clearcoatNormalMap||we.flatShading||we.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(we.extensionFragDepth||we.logarithmicDepthBuffer)&&we.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",we.extensionDrawBuffers&&we.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(we.extensionShaderTextureLOD||we.envMap||we.transmission)&&we.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Xs).join(`
`)}(t),y=function(we){const Fe=[];for(const Te in we){const Ce=we[Te];Ce!==!1&&Fe.push("#define "+Te+" "+Ce)}return Fe.join(`
`)}(r),b=i.createProgram();let T,_,F=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(T=[y].filter(Xs).join(`
`),T.length>0&&(T+=`
`),_=[m,y].filter(Xs).join(`
`),_.length>0&&(_+=`
`)):(T=[hc(t),"#define SHADER_NAME "+t.shaderName,y,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+d:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularTintMap?"#define USE_SPECULARTINTMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Xs).join(`
`),_=[m,hc(t),"#define SHADER_NAME "+t.shaderName,y,"#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.envMap?"#define "+d:"",t.envMap?"#define "+p:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularTintMap?"#define USE_SPECULARTINTMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheenTint?"#define USE_SHEEN":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==0?"#define TONE_MAPPING":"",t.toneMapping!==0?dn.tonemapping_pars_fragment:"",t.toneMapping!==0?Ud("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.format===1022?"#define OPAQUE":"",dn.encodings_pars_fragment,t.map?ws("mapTexelToLinear",t.mapEncoding):"",t.matcap?ws("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?ws("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?ws("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.specularTintMap?ws("specularTintMapTexelToLinear",t.specularTintMapEncoding):"",t.lightMap?ws("lightMapTexelToLinear",t.lightMapEncoding):"",kd("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Xs).join(`
`)),a=Io(a),a=oc(a,t),a=lc(a,t),l=Io(l),l=oc(l,t),l=lc(l,t),a=cc(a),l=cc(l),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(F=`#version 300 es
`,T=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+T,_=["#define varying in",t.glslVersion===he?"":"out highp vec4 pc_fragColor;",t.glslVersion===he?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_);const U=F+_+l,k=rc(i,35633,F+T+a),X=rc(i,35632,U);if(i.attachShader(b,k),i.attachShader(b,X),t.index0AttributeName!==void 0?i.bindAttribLocation(b,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(b,0,"position"),i.linkProgram(b),s.debug.checkShaderErrors){const we=i.getProgramInfoLog(b).trim(),Fe=i.getShaderInfoLog(k).trim(),Te=i.getShaderInfoLog(X).trim();let Ce=!0,St=!0;if(i.getProgramParameter(b,35714)===!1){Ce=!1;const ht=ac(i,k,"vertex"),je=ac(i,X,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(b,35715)+`

Program Info Log: `+we+`
`+ht+`
`+je)}else we!==""?console.warn("THREE.WebGLProgram: Program Info Log:",we):Fe!==""&&Te!==""||(St=!1);St&&(this.diagnostics={runnable:Ce,programLog:we,vertexShader:{log:Fe,prefix:T},fragmentShader:{log:Te,prefix:_}})}let K,ye;return i.deleteShader(k),i.deleteShader(X),this.getUniforms=function(){return K===void 0&&(K=new Rr(i,b)),K},this.getAttributes=function(){return ye===void 0&&(ye=function(we,Fe){const Te={},Ce=we.getProgramParameter(Fe,35721);for(let St=0;St<Ce;St++){const ht=we.getActiveAttrib(Fe,St),je=ht.name;let ft=1;ht.type===35674&&(ft=2),ht.type===35675&&(ft=3),ht.type===35676&&(ft=4),Te[je]={type:ht.type,location:we.getAttribLocation(Fe,je),locationSize:ft}}return Te}(i,b)),ye},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(b),this.program=void 0},this.name=t.shaderName,this.id=zd++,this.cacheKey=e,this.usedTimes=1,this.program=b,this.vertexShader=k,this.fragmentShader=X,this}function Xd(s,e,t,n,i,r,a){const l=[],c=i.isWebGL2,h=i.logarithmicDepthBuffer,d=i.floatVertexTextures,p=i.maxVertexUniforms,f=i.vertexTextures;let m=i.precision;const y={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},b=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheenTint","transmission","transmissionMap","thicknessMap"];function T(_){let F;return _&&_.isTexture?F=_.encoding:_&&_.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),F=_.texture.encoding):F=3e3,F}return{getParameters:function(_,F,U,k,X){const K=k.fog,ye=_.isMeshStandardMaterial?k.environment:null,we=(_.isMeshStandardMaterial?t:e).get(_.envMap||ye),Fe=y[_.type],Te=X.isSkinnedMesh?function(Lt){const Pt=Lt.skeleton.bones;if(d)return 1024;{const Ht=p,Xt=Math.floor((Ht-20)/4),Zt=Math.min(Xt,Pt.length);return Zt<Pt.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+Pt.length+" bones. This GPU supports "+Zt+"."),0):Zt}}(X):0;let Ce,St;if(_.precision!==null&&(m=i.getMaxPrecision(_.precision),m!==_.precision&&console.warn("THREE.WebGLProgram.getParameters:",_.precision,"not supported, using",m,"instead.")),Fe){const Lt=Gi[Fe];Ce=Lt.vertexShader,St=Lt.fragmentShader}else Ce=_.vertexShader,St=_.fragmentShader;const ht=s.getRenderTarget(),je=_.alphaTest>0,ft=_.clearcoat>0;return{isWebGL2:c,shaderID:Fe,shaderName:_.type,vertexShader:Ce,fragmentShader:St,defines:_.defines,isRawShaderMaterial:_.isRawShaderMaterial===!0,glslVersion:_.glslVersion,precision:m,instancing:X.isInstancedMesh===!0,instancingColor:X.isInstancedMesh===!0&&X.instanceColor!==null,supportsVertexTextures:f,outputEncoding:ht!==null?T(ht.texture):s.outputEncoding,map:!!_.map,mapEncoding:T(_.map),matcap:!!_.matcap,matcapEncoding:T(_.matcap),envMap:!!we,envMapMode:we&&we.mapping,envMapEncoding:T(we),envMapCubeUV:!!we&&(we.mapping===306||we.mapping===307),lightMap:!!_.lightMap,lightMapEncoding:T(_.lightMap),aoMap:!!_.aoMap,emissiveMap:!!_.emissiveMap,emissiveMapEncoding:T(_.emissiveMap),bumpMap:!!_.bumpMap,normalMap:!!_.normalMap,objectSpaceNormalMap:_.normalMapType===1,tangentSpaceNormalMap:_.normalMapType===0,clearcoat:ft,clearcoatMap:ft&&!!_.clearcoatMap,clearcoatRoughnessMap:ft&&!!_.clearcoatRoughnessMap,clearcoatNormalMap:ft&&!!_.clearcoatNormalMap,displacementMap:!!_.displacementMap,roughnessMap:!!_.roughnessMap,metalnessMap:!!_.metalnessMap,specularMap:!!_.specularMap,specularIntensityMap:!!_.specularIntensityMap,specularTintMap:!!_.specularTintMap,specularTintMapEncoding:T(_.specularTintMap),alphaMap:!!_.alphaMap,alphaTest:je,gradientMap:!!_.gradientMap,sheenTint:!!_.sheenTint&&(_.sheenTint.r>0||_.sheenTint.g>0||_.sheenTint.b>0),transmission:_.transmission>0,transmissionMap:!!_.transmissionMap,thicknessMap:!!_.thicknessMap,combine:_.combine,vertexTangents:!!_.normalMap&&!!X.geometry&&!!X.geometry.attributes.tangent,vertexColors:_.vertexColors,vertexAlphas:_.vertexColors===!0&&!!X.geometry&&!!X.geometry.attributes.color&&X.geometry.attributes.color.itemSize===4,vertexUvs:!!(_.map||_.bumpMap||_.normalMap||_.specularMap||_.alphaMap||_.emissiveMap||_.roughnessMap||_.metalnessMap||_.clearcoatMap||_.clearcoatRoughnessMap||_.clearcoatNormalMap||_.displacementMap||_.transmissionMap||_.thicknessMap||_.specularIntensityMap||_.specularTintMap),uvsVertexOnly:!(_.map||_.bumpMap||_.normalMap||_.specularMap||_.alphaMap||_.emissiveMap||_.roughnessMap||_.metalnessMap||_.clearcoatNormalMap||_.transmission>0||_.transmissionMap||_.thicknessMap||_.specularIntensityMap||_.specularTintMap||!_.displacementMap),fog:!!K,useFog:_.fog,fogExp2:K&&K.isFogExp2,flatShading:!!_.flatShading,sizeAttenuation:_.sizeAttenuation,logarithmicDepthBuffer:h,skinning:X.isSkinnedMesh===!0&&Te>0,maxBones:Te,useVertexTexture:d,morphTargets:!!X.geometry&&!!X.geometry.morphAttributes.position,morphNormals:!!X.geometry&&!!X.geometry.morphAttributes.normal,numDirLights:F.directional.length,numPointLights:F.point.length,numSpotLights:F.spot.length,numRectAreaLights:F.rectArea.length,numHemiLights:F.hemi.length,numDirLightShadows:F.directionalShadowMap.length,numPointLightShadows:F.pointShadowMap.length,numSpotLightShadows:F.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:_.format,dithering:_.dithering,shadowMapEnabled:s.shadowMap.enabled&&U.length>0,shadowMapType:s.shadowMap.type,toneMapping:_.toneMapped?s.toneMapping:0,physicallyCorrectLights:s.physicallyCorrectLights,premultipliedAlpha:_.premultipliedAlpha,doubleSided:_.side===2,flipSided:_.side===1,depthPacking:_.depthPacking!==void 0&&_.depthPacking,index0AttributeName:_.index0AttributeName,extensionDerivatives:_.extensions&&_.extensions.derivatives,extensionFragDepth:_.extensions&&_.extensions.fragDepth,extensionDrawBuffers:_.extensions&&_.extensions.drawBuffers,extensionShaderTextureLOD:_.extensions&&_.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||n.has("EXT_shader_texture_lod"),customProgramCacheKey:_.customProgramCacheKey()}},getProgramCacheKey:function(_){const F=[];if(_.shaderID?F.push(_.shaderID):(F.push(_.fragmentShader),F.push(_.vertexShader)),_.defines!==void 0)for(const U in _.defines)F.push(U),F.push(_.defines[U]);if(_.isRawShaderMaterial===!1){for(let U=0;U<b.length;U++)F.push(_[b[U]]);F.push(s.outputEncoding),F.push(s.gammaFactor)}return F.push(_.customProgramCacheKey),F.join()},getUniforms:function(_){const F=y[_.type];let U;if(F){const k=Gi[F];U=Nl.clone(k.uniforms)}else U=_.uniforms;return U},acquireProgram:function(_,F){let U;for(let k=0,X=l.length;k<X;k++){const K=l[k];if(K.cacheKey===F){U=K,++U.usedTimes;break}}return U===void 0&&(U=new qd(s,F,_,r),l.push(U)),U},releaseProgram:function(_){if(--_.usedTimes==0){const F=l.indexOf(_);l[F]=l[l.length-1],l.pop(),_.destroy()}},programs:l}}function Zd(){let s=new WeakMap;return{get:function(e){let t=s.get(e);return t===void 0&&(t={},s.set(e,t)),t},remove:function(e){s.delete(e)},update:function(e,t,n){s.get(e)[t]=n},dispose:function(){s=new WeakMap}}}function Yd(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.program!==e.program?s.program.id-e.program.id:s.material.id!==e.material.id?s.material.id-e.material.id:s.z!==e.z?s.z-e.z:s.id-e.id}function dc(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.z!==e.z?e.z-s.z:s.id-e.id}function pc(s){const e=[];let t=0;const n=[],i=[],r=[],a={id:-1};function l(c,h,d,p,f,m){let y=e[t];const b=s.get(d);return y===void 0?(y={id:c.id,object:c,geometry:h,material:d,program:b.program||a,groupOrder:p,renderOrder:c.renderOrder,z:f,group:m},e[t]=y):(y.id=c.id,y.object=c,y.geometry=h,y.material=d,y.program=b.program||a,y.groupOrder=p,y.renderOrder=c.renderOrder,y.z=f,y.group=m),t++,y}return{opaque:n,transmissive:i,transparent:r,init:function(){t=0,n.length=0,i.length=0,r.length=0},push:function(c,h,d,p,f,m){const y=l(c,h,d,p,f,m);d.transmission>0?i.push(y):d.transparent===!0?r.push(y):n.push(y)},unshift:function(c,h,d,p,f,m){const y=l(c,h,d,p,f,m);d.transmission>0?i.unshift(y):d.transparent===!0?r.unshift(y):n.unshift(y)},finish:function(){for(let c=t,h=e.length;c<h;c++){const d=e[c];if(d.id===null)break;d.id=null,d.object=null,d.geometry=null,d.material=null,d.program=null,d.group=null}},sort:function(c,h){n.length>1&&n.sort(c||Yd),i.length>1&&i.sort(h||dc),r.length>1&&r.sort(h||dc)}}}function Jd(s){let e=new WeakMap;return{get:function(t,n){let i;return e.has(t)===!1?(i=new pc(s),e.set(t,[i])):n>=e.get(t).length?(i=new pc(s),e.get(t).push(i)):i=e.get(t)[n],i},dispose:function(){e=new WeakMap}}}function Kd(){const s={};return{get:function(e){if(s[e.id]!==void 0)return s[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new H,color:new ut};break;case"SpotLight":t={position:new H,direction:new H,color:new ut,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new H,color:new ut,distance:0,decay:0};break;case"HemisphereLight":t={direction:new H,skyColor:new ut,groundColor:new ut};break;case"RectAreaLight":t={color:new ut,position:new H,halfWidth:new H,halfHeight:new H}}return s[e.id]=t,t}}}let Qd=0;function $d(s,e){return(e.castShadow?1:0)-(s.castShadow?1:0)}function ep(s,e){const t=new Kd,n=function(){const c={};return{get:function(h){if(c[h.id]!==void 0)return c[h.id];let d;switch(h.type){case"DirectionalLight":case"SpotLight":d={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new at};break;case"PointLight":d={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new at,shadowCameraNear:1,shadowCameraFar:1e3}}return c[h.id]=d,d}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let c=0;c<9;c++)i.probe.push(new H);const r=new H,a=new Dt,l=new Dt;return{setup:function(c,h){let d=0,p=0,f=0;for(let ye=0;ye<9;ye++)i.probe[ye].set(0,0,0);let m=0,y=0,b=0,T=0,_=0,F=0,U=0,k=0;c.sort($d);const X=h!==!0?Math.PI:1;for(let ye=0,we=c.length;ye<we;ye++){const Fe=c[ye],Te=Fe.color,Ce=Fe.intensity,St=Fe.distance,ht=Fe.shadow&&Fe.shadow.map?Fe.shadow.map.texture:null;if(Fe.isAmbientLight)d+=Te.r*Ce*X,p+=Te.g*Ce*X,f+=Te.b*Ce*X;else if(Fe.isLightProbe)for(let je=0;je<9;je++)i.probe[je].addScaledVector(Fe.sh.coefficients[je],Ce);else if(Fe.isDirectionalLight){const je=t.get(Fe);if(je.color.copy(Fe.color).multiplyScalar(Fe.intensity*X),Fe.castShadow){const ft=Fe.shadow,Lt=n.get(Fe);Lt.shadowBias=ft.bias,Lt.shadowNormalBias=ft.normalBias,Lt.shadowRadius=ft.radius,Lt.shadowMapSize=ft.mapSize,i.directionalShadow[m]=Lt,i.directionalShadowMap[m]=ht,i.directionalShadowMatrix[m]=Fe.shadow.matrix,F++}i.directional[m]=je,m++}else if(Fe.isSpotLight){const je=t.get(Fe);if(je.position.setFromMatrixPosition(Fe.matrixWorld),je.color.copy(Te).multiplyScalar(Ce*X),je.distance=St,je.coneCos=Math.cos(Fe.angle),je.penumbraCos=Math.cos(Fe.angle*(1-Fe.penumbra)),je.decay=Fe.decay,Fe.castShadow){const ft=Fe.shadow,Lt=n.get(Fe);Lt.shadowBias=ft.bias,Lt.shadowNormalBias=ft.normalBias,Lt.shadowRadius=ft.radius,Lt.shadowMapSize=ft.mapSize,i.spotShadow[b]=Lt,i.spotShadowMap[b]=ht,i.spotShadowMatrix[b]=Fe.shadow.matrix,k++}i.spot[b]=je,b++}else if(Fe.isRectAreaLight){const je=t.get(Fe);je.color.copy(Te).multiplyScalar(Ce),je.halfWidth.set(.5*Fe.width,0,0),je.halfHeight.set(0,.5*Fe.height,0),i.rectArea[T]=je,T++}else if(Fe.isPointLight){const je=t.get(Fe);if(je.color.copy(Fe.color).multiplyScalar(Fe.intensity*X),je.distance=Fe.distance,je.decay=Fe.decay,Fe.castShadow){const ft=Fe.shadow,Lt=n.get(Fe);Lt.shadowBias=ft.bias,Lt.shadowNormalBias=ft.normalBias,Lt.shadowRadius=ft.radius,Lt.shadowMapSize=ft.mapSize,Lt.shadowCameraNear=ft.camera.near,Lt.shadowCameraFar=ft.camera.far,i.pointShadow[y]=Lt,i.pointShadowMap[y]=ht,i.pointShadowMatrix[y]=Fe.shadow.matrix,U++}i.point[y]=je,y++}else if(Fe.isHemisphereLight){const je=t.get(Fe);je.skyColor.copy(Fe.color).multiplyScalar(Ce*X),je.groundColor.copy(Fe.groundColor).multiplyScalar(Ce*X),i.hemi[_]=je,_++}}T>0&&(e.isWebGL2||s.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Ct.LTC_FLOAT_1,i.rectAreaLTC2=Ct.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=Ct.LTC_HALF_1,i.rectAreaLTC2=Ct.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=p,i.ambient[2]=f;const K=i.hash;K.directionalLength===m&&K.pointLength===y&&K.spotLength===b&&K.rectAreaLength===T&&K.hemiLength===_&&K.numDirectionalShadows===F&&K.numPointShadows===U&&K.numSpotShadows===k||(i.directional.length=m,i.spot.length=b,i.rectArea.length=T,i.point.length=y,i.hemi.length=_,i.directionalShadow.length=F,i.directionalShadowMap.length=F,i.pointShadow.length=U,i.pointShadowMap.length=U,i.spotShadow.length=k,i.spotShadowMap.length=k,i.directionalShadowMatrix.length=F,i.pointShadowMatrix.length=U,i.spotShadowMatrix.length=k,K.directionalLength=m,K.pointLength=y,K.spotLength=b,K.rectAreaLength=T,K.hemiLength=_,K.numDirectionalShadows=F,K.numPointShadows=U,K.numSpotShadows=k,i.version=Qd++)},setupView:function(c,h){let d=0,p=0,f=0,m=0,y=0;const b=h.matrixWorldInverse;for(let T=0,_=c.length;T<_;T++){const F=c[T];if(F.isDirectionalLight){const U=i.directional[d];U.direction.setFromMatrixPosition(F.matrixWorld),r.setFromMatrixPosition(F.target.matrixWorld),U.direction.sub(r),U.direction.transformDirection(b),d++}else if(F.isSpotLight){const U=i.spot[f];U.position.setFromMatrixPosition(F.matrixWorld),U.position.applyMatrix4(b),U.direction.setFromMatrixPosition(F.matrixWorld),r.setFromMatrixPosition(F.target.matrixWorld),U.direction.sub(r),U.direction.transformDirection(b),f++}else if(F.isRectAreaLight){const U=i.rectArea[m];U.position.setFromMatrixPosition(F.matrixWorld),U.position.applyMatrix4(b),l.identity(),a.copy(F.matrixWorld),a.premultiply(b),l.extractRotation(a),U.halfWidth.set(.5*F.width,0,0),U.halfHeight.set(0,.5*F.height,0),U.halfWidth.applyMatrix4(l),U.halfHeight.applyMatrix4(l),m++}else if(F.isPointLight){const U=i.point[p];U.position.setFromMatrixPosition(F.matrixWorld),U.position.applyMatrix4(b),p++}else if(F.isHemisphereLight){const U=i.hemi[y];U.direction.setFromMatrixPosition(F.matrixWorld),U.direction.transformDirection(b),U.direction.normalize(),y++}}},state:i}}function fc(s,e){const t=new ep(s,e),n=[],i=[];return{init:function(){n.length=0,i.length=0},state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:function(r){t.setup(n,r)},setupLightsView:function(r){t.setupView(n,r)},pushLight:function(r){n.push(r)},pushShadow:function(r){i.push(r)}}}function tp(s,e){let t=new WeakMap;return{get:function(n,i=0){let r;return t.has(n)===!1?(r=new fc(s,e),t.set(n,[r])):i>=t.get(n).length?(r=new fc(s,e),t.get(n).push(r)):r=t.get(n)[i],r},dispose:function(){t=new WeakMap}}}class Ca extends We{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Ca.prototype.isMeshDepthMaterial=!0;class Pa extends We{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new H,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}Pa.prototype.isMeshDistanceMaterial=!0;function mc(s,e,t){let n=new Ws;const i=new at,r=new at,a=new en,l=new Ca({depthPacking:3201}),c=new Pa,h={},d=t.maxTextureSize,p={0:1,1:0,2:2},f=new mr({uniforms:{shadow_pass:{value:null},resolution:{value:new at},radius:{value:4},samples:{value:8}},vertexShader:`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragmentShader:`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
uniform float samples;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`}),m=f.clone();m.defines.HORIZONTAL_PASS=1;const y=new Qt;y.setAttribute("position",new $t(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const b=new Vn(y,f),T=this;function _(k,X){const K=e.update(b);f.uniforms.shadow_pass.value=k.map.texture,f.uniforms.resolution.value=k.mapSize,f.uniforms.radius.value=k.radius,f.uniforms.samples.value=k.blurSamples,s.setRenderTarget(k.mapPass),s.clear(),s.renderBufferDirect(X,null,K,f,b,null),m.uniforms.shadow_pass.value=k.mapPass.texture,m.uniforms.resolution.value=k.mapSize,m.uniforms.radius.value=k.radius,m.uniforms.samples.value=k.blurSamples,s.setRenderTarget(k.map),s.clear(),s.renderBufferDirect(X,null,K,m,b,null)}function F(k,X,K,ye,we,Fe,Te){let Ce=null;const St=ye.isPointLight===!0?k.customDistanceMaterial:k.customDepthMaterial;if(Ce=St!==void 0?St:ye.isPointLight===!0?c:l,s.localClippingEnabled&&K.clipShadows===!0&&K.clippingPlanes.length!==0||K.displacementMap&&K.displacementScale!==0||K.alphaMap&&K.alphaTest>0){const ht=Ce.uuid,je=K.uuid;let ft=h[ht];ft===void 0&&(ft={},h[ht]=ft);let Lt=ft[je];Lt===void 0&&(Lt=Ce.clone(),ft[je]=Lt),Ce=Lt}return Ce.visible=K.visible,Ce.wireframe=K.wireframe,Ce.side=Te===3?K.shadowSide!==null?K.shadowSide:K.side:K.shadowSide!==null?K.shadowSide:p[K.side],Ce.alphaMap=K.alphaMap,Ce.alphaTest=K.alphaTest,Ce.clipShadows=K.clipShadows,Ce.clippingPlanes=K.clippingPlanes,Ce.clipIntersection=K.clipIntersection,Ce.displacementMap=K.displacementMap,Ce.displacementScale=K.displacementScale,Ce.displacementBias=K.displacementBias,Ce.wireframeLinewidth=K.wireframeLinewidth,Ce.linewidth=K.linewidth,ye.isPointLight===!0&&Ce.isMeshDistanceMaterial===!0&&(Ce.referencePosition.setFromMatrixPosition(ye.matrixWorld),Ce.nearDistance=we,Ce.farDistance=Fe),Ce}function U(k,X,K,ye,we){if(k.visible===!1)return;if(k.layers.test(X.layers)&&(k.isMesh||k.isLine||k.isPoints)&&(k.castShadow||k.receiveShadow&&we===3)&&(!k.frustumCulled||n.intersectsObject(k))){k.modelViewMatrix.multiplyMatrices(K.matrixWorldInverse,k.matrixWorld);const Te=e.update(k),Ce=k.material;if(Array.isArray(Ce)){const St=Te.groups;for(let ht=0,je=St.length;ht<je;ht++){const ft=St[ht],Lt=Ce[ft.materialIndex];if(Lt&&Lt.visible){const Pt=F(k,0,Lt,ye,K.near,K.far,we);s.renderBufferDirect(K,null,Te,Pt,k,ft)}}}else if(Ce.visible){const St=F(k,0,Ce,ye,K.near,K.far,we);s.renderBufferDirect(K,null,Te,St,k,null)}}const Fe=k.children;for(let Te=0,Ce=Fe.length;Te<Ce;Te++)U(Fe[Te],X,K,ye,we)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(k,X,K){if(T.enabled===!1||T.autoUpdate===!1&&T.needsUpdate===!1||k.length===0)return;const ye=s.getRenderTarget(),we=s.getActiveCubeFace(),Fe=s.getActiveMipmapLevel(),Te=s.state;Te.setBlending(0),Te.buffers.color.setClear(1,1,1,1),Te.buffers.depth.setTest(!0),Te.setScissorTest(!1);for(let Ce=0,St=k.length;Ce<St;Ce++){const ht=k[Ce],je=ht.shadow;if(je===void 0){console.warn("THREE.WebGLShadowMap:",ht,"has no shadow.");continue}if(je.autoUpdate===!1&&je.needsUpdate===!1)continue;i.copy(je.mapSize);const ft=je.getFrameExtents();if(i.multiply(ft),r.copy(je.mapSize),(i.x>d||i.y>d)&&(i.x>d&&(r.x=Math.floor(d/ft.x),i.x=r.x*ft.x,je.mapSize.x=r.x),i.y>d&&(r.y=Math.floor(d/ft.y),i.y=r.y*ft.y,je.mapSize.y=r.y)),je.map===null&&!je.isPointLightShadow&&this.type===3){const Pt={minFilter:1006,magFilter:1006,format:1023};je.map=new Nn(i.x,i.y,Pt),je.map.texture.name=ht.name+".shadowMap",je.mapPass=new Nn(i.x,i.y,Pt),je.camera.updateProjectionMatrix()}if(je.map===null){const Pt={minFilter:1003,magFilter:1003,format:1023};je.map=new Nn(i.x,i.y,Pt),je.map.texture.name=ht.name+".shadowMap",je.camera.updateProjectionMatrix()}s.setRenderTarget(je.map),s.clear();const Lt=je.getViewportCount();for(let Pt=0;Pt<Lt;Pt++){const Ht=je.getViewport(Pt);a.set(r.x*Ht.x,r.y*Ht.y,r.x*Ht.z,r.y*Ht.w),Te.viewport(a),je.updateMatrices(ht,Pt),n=je.getFrustum(),U(X,K,je.camera,ht,this.type)}je.isPointLightShadow||this.type!==3||_(je,K),je.needsUpdate=!1}T.needsUpdate=!1,s.setRenderTarget(ye,we,Fe)}}function np(s,e,t){const n=t.isWebGL2,i=new function(){let j=!1;const Ee=new en;let $e=null;const rt=new en(0,0,0,0);return{setMask:function(Qe){$e===Qe||j||(s.colorMask(Qe,Qe,Qe,Qe),$e=Qe)},setLocked:function(Qe){j=Qe},setClear:function(Qe,Ft,Wt,kt,ln){ln===!0&&(Qe*=kt,Ft*=kt,Wt*=kt),Ee.set(Qe,Ft,Wt,kt),rt.equals(Ee)===!1&&(s.clearColor(Qe,Ft,Wt,kt),rt.copy(Ee))},reset:function(){j=!1,$e=null,rt.set(-1,0,0,0)}}},r=new function(){let j=!1,Ee=null,$e=null,rt=null;return{setTest:function(Qe){Qe?pt(2929):J(2929)},setMask:function(Qe){Ee===Qe||j||(s.depthMask(Qe),Ee=Qe)},setFunc:function(Qe){if($e!==Qe){if(Qe)switch(Qe){case 0:s.depthFunc(512);break;case 1:s.depthFunc(519);break;case 2:s.depthFunc(513);break;case 3:s.depthFunc(515);break;case 4:s.depthFunc(514);break;case 5:s.depthFunc(518);break;case 6:s.depthFunc(516);break;case 7:s.depthFunc(517);break;default:s.depthFunc(515)}else s.depthFunc(515);$e=Qe}},setLocked:function(Qe){j=Qe},setClear:function(Qe){rt!==Qe&&(s.clearDepth(Qe),rt=Qe)},reset:function(){j=!1,Ee=null,$e=null,rt=null}}},a=new function(){let j=!1,Ee=null,$e=null,rt=null,Qe=null,Ft=null,Wt=null,kt=null,ln=null;return{setTest:function(nn){j||(nn?pt(2960):J(2960))},setMask:function(nn){Ee===nn||j||(s.stencilMask(nn),Ee=nn)},setFunc:function(nn,Qn,Sn){$e===nn&&rt===Qn&&Qe===Sn||(s.stencilFunc(nn,Qn,Sn),$e=nn,rt=Qn,Qe=Sn)},setOp:function(nn,Qn,Sn){Ft===nn&&Wt===Qn&&kt===Sn||(s.stencilOp(nn,Qn,Sn),Ft=nn,Wt=Qn,kt=Sn)},setLocked:function(nn){j=nn},setClear:function(nn){ln!==nn&&(s.clearStencil(nn),ln=nn)},reset:function(){j=!1,Ee=null,$e=null,rt=null,Qe=null,Ft=null,Wt=null,kt=null,ln=null}}};let l={},c=null,h={},d=null,p=!1,f=null,m=null,y=null,b=null,T=null,_=null,F=null,U=!1,k=null,X=null,K=null,ye=null,we=null;const Fe=s.getParameter(35661);let Te=!1,Ce=0;const St=s.getParameter(7938);St.indexOf("WebGL")!==-1?(Ce=parseFloat(/^WebGL (\d)/.exec(St)[1]),Te=Ce>=1):St.indexOf("OpenGL ES")!==-1&&(Ce=parseFloat(/^OpenGL ES (\d)/.exec(St)[1]),Te=Ce>=2);let ht=null,je={};const ft=s.getParameter(3088),Lt=s.getParameter(2978),Pt=new en().fromArray(ft),Ht=new en().fromArray(Lt);function Xt(j,Ee,$e){const rt=new Uint8Array(4),Qe=s.createTexture();s.bindTexture(j,Qe),s.texParameteri(j,10241,9728),s.texParameteri(j,10240,9728);for(let Ft=0;Ft<$e;Ft++)s.texImage2D(Ee+Ft,0,6408,1,1,0,6408,5121,rt);return Qe}const Zt={};function pt(j){l[j]!==!0&&(s.enable(j),l[j]=!0)}function J(j){l[j]!==!1&&(s.disable(j),l[j]=!1)}Zt[3553]=Xt(3553,3553,1),Zt[34067]=Xt(34067,34069,6),i.setClear(0,0,0,1),r.setClear(1),a.setClear(0),pt(2929),r.setFunc(3),Pe(!1),Mt(1),pt(2884),Ue(0);const ce={100:32774,101:32778,102:32779};if(n)ce[103]=32775,ce[104]=32776;else{const j=e.get("EXT_blend_minmax");j!==null&&(ce[103]=j.MIN_EXT,ce[104]=j.MAX_EXT)}const Je={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function Ue(j,Ee,$e,rt,Qe,Ft,Wt,kt){if(j!==0){if(p===!1&&(pt(3042),p=!0),j===5)Qe=Qe||Ee,Ft=Ft||$e,Wt=Wt||rt,Ee===m&&Qe===T||(s.blendEquationSeparate(ce[Ee],ce[Qe]),m=Ee,T=Qe),$e===y&&rt===b&&Ft===_&&Wt===F||(s.blendFuncSeparate(Je[$e],Je[rt],Je[Ft],Je[Wt]),y=$e,b=rt,_=Ft,F=Wt),f=j,U=null;else if(j!==f||kt!==U){if(m===100&&T===100||(s.blendEquation(32774),m=100,T=100),kt)switch(j){case 1:s.blendFuncSeparate(1,771,1,771);break;case 2:s.blendFunc(1,1);break;case 3:s.blendFuncSeparate(0,0,769,771);break;case 4:s.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",j)}else switch(j){case 1:s.blendFuncSeparate(770,771,1,771);break;case 2:s.blendFunc(770,1);break;case 3:s.blendFunc(0,769);break;case 4:s.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",j)}y=null,b=null,_=null,F=null,f=j,U=kt}}else p===!0&&(J(3042),p=!1)}function Pe(j){k!==j&&(j?s.frontFace(2304):s.frontFace(2305),k=j)}function Mt(j){j!==0?(pt(2884),j!==X&&(j===1?s.cullFace(1029):j===2?s.cullFace(1028):s.cullFace(1032))):J(2884),X=j}function _t(j,Ee,$e){j?(pt(32823),ye===Ee&&we===$e||(s.polygonOffset(Ee,$e),ye=Ee,we=$e)):J(32823)}function Ne(j){j===void 0&&(j=33984+Fe-1),ht!==j&&(s.activeTexture(j),ht=j)}return{buffers:{color:i,depth:r,stencil:a},enable:pt,disable:J,bindFramebuffer:function(j,Ee){return Ee===null&&c!==null&&(Ee=c),h[j]!==Ee&&(s.bindFramebuffer(j,Ee),h[j]=Ee,n&&(j===36009&&(h[36160]=Ee),j===36160&&(h[36009]=Ee)),!0)},bindXRFramebuffer:function(j){j!==c&&(s.bindFramebuffer(36160,j),c=j)},useProgram:function(j){return d!==j&&(s.useProgram(j),d=j,!0)},setBlending:Ue,setMaterial:function(j,Ee){j.side===2?J(2884):pt(2884);let $e=j.side===1;Ee&&($e=!$e),Pe($e),j.blending===1&&j.transparent===!1?Ue(0):Ue(j.blending,j.blendEquation,j.blendSrc,j.blendDst,j.blendEquationAlpha,j.blendSrcAlpha,j.blendDstAlpha,j.premultipliedAlpha),r.setFunc(j.depthFunc),r.setTest(j.depthTest),r.setMask(j.depthWrite),i.setMask(j.colorWrite);const rt=j.stencilWrite;a.setTest(rt),rt&&(a.setMask(j.stencilWriteMask),a.setFunc(j.stencilFunc,j.stencilRef,j.stencilFuncMask),a.setOp(j.stencilFail,j.stencilZFail,j.stencilZPass)),_t(j.polygonOffset,j.polygonOffsetFactor,j.polygonOffsetUnits),j.alphaToCoverage===!0?pt(32926):J(32926)},setFlipSided:Pe,setCullFace:Mt,setLineWidth:function(j){j!==K&&(Te&&s.lineWidth(j),K=j)},setPolygonOffset:_t,setScissorTest:function(j){j?pt(3089):J(3089)},activeTexture:Ne,bindTexture:function(j,Ee){ht===null&&Ne();let $e=je[ht];$e===void 0&&($e={type:void 0,texture:void 0},je[ht]=$e),$e.type===j&&$e.texture===Ee||(s.bindTexture(j,Ee||Zt[j]),$e.type=j,$e.texture=Ee)},unbindTexture:function(){const j=je[ht];j!==void 0&&j.type!==void 0&&(s.bindTexture(j.type,null),j.type=void 0,j.texture=void 0)},compressedTexImage2D:function(){try{s.compressedTexImage2D.apply(s,arguments)}catch(j){console.error("THREE.WebGLState:",j)}},texImage2D:function(){try{s.texImage2D.apply(s,arguments)}catch(j){console.error("THREE.WebGLState:",j)}},texImage3D:function(){try{s.texImage3D.apply(s,arguments)}catch(j){console.error("THREE.WebGLState:",j)}},scissor:function(j){Pt.equals(j)===!1&&(s.scissor(j.x,j.y,j.z,j.w),Pt.copy(j))},viewport:function(j){Ht.equals(j)===!1&&(s.viewport(j.x,j.y,j.z,j.w),Ht.copy(j))},reset:function(){s.disable(3042),s.disable(2884),s.disable(2929),s.disable(32823),s.disable(3089),s.disable(2960),s.disable(32926),s.blendEquation(32774),s.blendFunc(1,0),s.blendFuncSeparate(1,0,1,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(513),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(519,0,4294967295),s.stencilOp(7680,7680,7680),s.clearStencil(0),s.cullFace(1029),s.frontFace(2305),s.polygonOffset(0,0),s.activeTexture(33984),s.bindFramebuffer(36160,null),n===!0&&(s.bindFramebuffer(36009,null),s.bindFramebuffer(36008,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),l={},ht=null,je={},c=null,h={},d=null,p=!1,f=null,m=null,y=null,b=null,T=null,_=null,F=null,U=!1,k=null,X=null,K=null,ye=null,we=null,Pt.set(0,0,s.canvas.width,s.canvas.height),Ht.set(0,0,s.canvas.width,s.canvas.height),i.reset(),r.reset(),a.reset()}}}function ip(s,e,t,n,i,r,a){const l=i.isWebGL2,c=i.maxTextures,h=i.maxCubemapSize,d=i.maxTextureSize,p=i.maxSamples,f=new WeakMap;let m,y=!1;try{y=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function b(J,ce){return y?new OffscreenCanvas(J,ce):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function T(J,ce,Je,Ue){let Pe=1;if((J.width>Ue||J.height>Ue)&&(Pe=Ue/Math.max(J.width,J.height)),Pe<1||ce===!0){if(typeof HTMLImageElement<"u"&&J instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&J instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&J instanceof ImageBitmap){const Mt=ce?ti:Math.floor,_t=Mt(Pe*J.width),Ne=Mt(Pe*J.height);m===void 0&&(m=b(_t,Ne));const j=Je?b(_t,Ne):m;return j.width=_t,j.height=Ne,j.getContext("2d").drawImage(J,0,0,_t,Ne),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+J.width+"x"+J.height+") to ("+_t+"x"+Ne+")."),j}return"data"in J&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+J.width+"x"+J.height+")."),J}return J}function _(J){return Tn(J.width)&&Tn(J.height)}function F(J,ce){return J.generateMipmaps&&ce&&J.minFilter!==1003&&J.minFilter!==1006}function U(J,ce,Je,Ue,Pe=1){s.generateMipmap(J),n.get(ce).__maxMipLevel=Math.log2(Math.max(Je,Ue,Pe))}function k(J,ce,Je){if(l===!1)return ce;if(J!==null){if(s[J]!==void 0)return s[J];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+J+"'")}let Ue=ce;return ce===6403&&(Je===5126&&(Ue=33326),Je===5131&&(Ue=33325),Je===5121&&(Ue=33321)),ce===6407&&(Je===5126&&(Ue=34837),Je===5131&&(Ue=34843),Je===5121&&(Ue=32849)),ce===6408&&(Je===5126&&(Ue=34836),Je===5131&&(Ue=34842),Je===5121&&(Ue=32856)),Ue!==33325&&Ue!==33326&&Ue!==34842&&Ue!==34836||e.get("EXT_color_buffer_float"),Ue}function X(J){return J===1003||J===1004||J===1005?9728:9729}function K(J){const ce=J.target;ce.removeEventListener("dispose",K),function(Je){const Ue=n.get(Je);Ue.__webglInit!==void 0&&(s.deleteTexture(Ue.__webglTexture),n.remove(Je))}(ce),ce.isVideoTexture&&f.delete(ce),a.memory.textures--}function ye(J){const ce=J.target;ce.removeEventListener("dispose",ye),function(Je){const Ue=Je.texture,Pe=n.get(Je),Mt=n.get(Ue);if(Je){if(Mt.__webglTexture!==void 0&&(s.deleteTexture(Mt.__webglTexture),a.memory.textures--),Je.depthTexture&&Je.depthTexture.dispose(),Je.isWebGLCubeRenderTarget)for(let _t=0;_t<6;_t++)s.deleteFramebuffer(Pe.__webglFramebuffer[_t]),Pe.__webglDepthbuffer&&s.deleteRenderbuffer(Pe.__webglDepthbuffer[_t]);else s.deleteFramebuffer(Pe.__webglFramebuffer),Pe.__webglDepthbuffer&&s.deleteRenderbuffer(Pe.__webglDepthbuffer),Pe.__webglMultisampledFramebuffer&&s.deleteFramebuffer(Pe.__webglMultisampledFramebuffer),Pe.__webglColorRenderbuffer&&s.deleteRenderbuffer(Pe.__webglColorRenderbuffer),Pe.__webglDepthRenderbuffer&&s.deleteRenderbuffer(Pe.__webglDepthRenderbuffer);if(Je.isWebGLMultipleRenderTargets)for(let _t=0,Ne=Ue.length;_t<Ne;_t++){const j=n.get(Ue[_t]);j.__webglTexture&&(s.deleteTexture(j.__webglTexture),a.memory.textures--),n.remove(Ue[_t])}n.remove(Ue),n.remove(Je)}}(ce)}let we=0;function Fe(J,ce){const Je=n.get(J);if(J.isVideoTexture&&function(Ue){const Pe=a.render.frame;f.get(Ue)!==Pe&&(f.set(Ue,Pe),Ue.update())}(J),J.version>0&&Je.__version!==J.version){const Ue=J.image;if(Ue===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(Ue.complete!==!1)return void ft(Je,J,ce);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}t.activeTexture(33984+ce),t.bindTexture(3553,Je.__webglTexture)}function Te(J,ce){const Je=n.get(J);J.version>0&&Je.__version!==J.version?function(Ue,Pe,Mt){if(Pe.image.length!==6)return;je(Ue,Pe),t.activeTexture(33984+Mt),t.bindTexture(34067,Ue.__webglTexture),s.pixelStorei(37440,Pe.flipY),s.pixelStorei(37441,Pe.premultiplyAlpha),s.pixelStorei(3317,Pe.unpackAlignment),s.pixelStorei(37443,0);const _t=Pe&&(Pe.isCompressedTexture||Pe.image[0].isCompressedTexture),Ne=Pe.image[0]&&Pe.image[0].isDataTexture,j=[];for(let kt=0;kt<6;kt++)j[kt]=_t||Ne?Ne?Pe.image[kt].image:Pe.image[kt]:T(Pe.image[kt],!1,!0,h);const Ee=j[0],$e=_(Ee)||l,rt=r.convert(Pe.format),Qe=r.convert(Pe.type),Ft=k(Pe.internalFormat,rt,Qe);let Wt;if(ht(34067,Pe,$e),_t){for(let kt=0;kt<6;kt++){Wt=j[kt].mipmaps;for(let ln=0;ln<Wt.length;ln++){const nn=Wt[ln];Pe.format!==1023&&Pe.format!==1022?rt!==null?t.compressedTexImage2D(34069+kt,ln,Ft,nn.width,nn.height,0,nn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+kt,ln,Ft,nn.width,nn.height,0,rt,Qe,nn.data)}}Ue.__maxMipLevel=Wt.length-1}else{Wt=Pe.mipmaps;for(let kt=0;kt<6;kt++)if(Ne){t.texImage2D(34069+kt,0,Ft,j[kt].width,j[kt].height,0,rt,Qe,j[kt].data);for(let ln=0;ln<Wt.length;ln++){const nn=Wt[ln].image[kt].image;t.texImage2D(34069+kt,ln+1,Ft,nn.width,nn.height,0,rt,Qe,nn.data)}}else{t.texImage2D(34069+kt,0,Ft,rt,Qe,j[kt]);for(let ln=0;ln<Wt.length;ln++){const nn=Wt[ln];t.texImage2D(34069+kt,ln+1,Ft,rt,Qe,nn.image[kt])}}Ue.__maxMipLevel=Wt.length}F(Pe,$e)&&U(34067,Pe,Ee.width,Ee.height),Ue.__version=Pe.version,Pe.onUpdate&&Pe.onUpdate(Pe)}(Je,J,ce):(t.activeTexture(33984+ce),t.bindTexture(34067,Je.__webglTexture))}const Ce={1e3:10497,1001:33071,1002:33648},St={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function ht(J,ce,Je){if(Je?(s.texParameteri(J,10242,Ce[ce.wrapS]),s.texParameteri(J,10243,Ce[ce.wrapT]),J!==32879&&J!==35866||s.texParameteri(J,32882,Ce[ce.wrapR]),s.texParameteri(J,10240,St[ce.magFilter]),s.texParameteri(J,10241,St[ce.minFilter])):(s.texParameteri(J,10242,33071),s.texParameteri(J,10243,33071),J!==32879&&J!==35866||s.texParameteri(J,32882,33071),ce.wrapS===1001&&ce.wrapT===1001||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(J,10240,X(ce.magFilter)),s.texParameteri(J,10241,X(ce.minFilter)),ce.minFilter!==1003&&ce.minFilter!==1006&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const Ue=e.get("EXT_texture_filter_anisotropic");if(ce.type===1015&&e.has("OES_texture_float_linear")===!1||l===!1&&ce.type===1016&&e.has("OES_texture_half_float_linear")===!1)return;(ce.anisotropy>1||n.get(ce).__currentAnisotropy)&&(s.texParameterf(J,Ue.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(ce.anisotropy,i.getMaxAnisotropy())),n.get(ce).__currentAnisotropy=ce.anisotropy)}}function je(J,ce){J.__webglInit===void 0&&(J.__webglInit=!0,ce.addEventListener("dispose",K),J.__webglTexture=s.createTexture(),a.memory.textures++)}function ft(J,ce,Je){let Ue=3553;ce.isDataTexture2DArray&&(Ue=35866),ce.isDataTexture3D&&(Ue=32879),je(J,ce),t.activeTexture(33984+Je),t.bindTexture(Ue,J.__webglTexture),s.pixelStorei(37440,ce.flipY),s.pixelStorei(37441,ce.premultiplyAlpha),s.pixelStorei(3317,ce.unpackAlignment),s.pixelStorei(37443,0);const Pe=function(Qe){return!l&&(Qe.wrapS!==1001||Qe.wrapT!==1001||Qe.minFilter!==1003&&Qe.minFilter!==1006)}(ce)&&_(ce.image)===!1,Mt=T(ce.image,Pe,!1,d),_t=_(Mt)||l,Ne=r.convert(ce.format);let j,Ee=r.convert(ce.type),$e=k(ce.internalFormat,Ne,Ee);ht(Ue,ce,_t);const rt=ce.mipmaps;if(ce.isDepthTexture)$e=6402,l?$e=ce.type===1015?36012:ce.type===1014?33190:ce.type===1020?35056:33189:ce.type===1015&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),ce.format===1026&&$e===6402&&ce.type!==1012&&ce.type!==1014&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),ce.type=1012,Ee=r.convert(ce.type)),ce.format===1027&&$e===6402&&($e=34041,ce.type!==1020&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),ce.type=1020,Ee=r.convert(ce.type))),t.texImage2D(3553,0,$e,Mt.width,Mt.height,0,Ne,Ee,null);else if(ce.isDataTexture)if(rt.length>0&&_t){for(let Qe=0,Ft=rt.length;Qe<Ft;Qe++)j=rt[Qe],t.texImage2D(3553,Qe,$e,j.width,j.height,0,Ne,Ee,j.data);ce.generateMipmaps=!1,J.__maxMipLevel=rt.length-1}else t.texImage2D(3553,0,$e,Mt.width,Mt.height,0,Ne,Ee,Mt.data),J.__maxMipLevel=0;else if(ce.isCompressedTexture){for(let Qe=0,Ft=rt.length;Qe<Ft;Qe++)j=rt[Qe],ce.format!==1023&&ce.format!==1022?Ne!==null?t.compressedTexImage2D(3553,Qe,$e,j.width,j.height,0,j.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,Qe,$e,j.width,j.height,0,Ne,Ee,j.data);J.__maxMipLevel=rt.length-1}else if(ce.isDataTexture2DArray)t.texImage3D(35866,0,$e,Mt.width,Mt.height,Mt.depth,0,Ne,Ee,Mt.data),J.__maxMipLevel=0;else if(ce.isDataTexture3D)t.texImage3D(32879,0,$e,Mt.width,Mt.height,Mt.depth,0,Ne,Ee,Mt.data),J.__maxMipLevel=0;else if(rt.length>0&&_t){for(let Qe=0,Ft=rt.length;Qe<Ft;Qe++)j=rt[Qe],t.texImage2D(3553,Qe,$e,Ne,Ee,j);ce.generateMipmaps=!1,J.__maxMipLevel=rt.length-1}else t.texImage2D(3553,0,$e,Ne,Ee,Mt),J.__maxMipLevel=0;F(ce,_t)&&U(Ue,ce,Mt.width,Mt.height),J.__version=ce.version,ce.onUpdate&&ce.onUpdate(ce)}function Lt(J,ce,Je,Ue,Pe){const Mt=r.convert(Je.format),_t=r.convert(Je.type),Ne=k(Je.internalFormat,Mt,_t);Pe===32879||Pe===35866?t.texImage3D(Pe,0,Ne,ce.width,ce.height,ce.depth,0,Mt,_t,null):t.texImage2D(Pe,0,Ne,ce.width,ce.height,0,Mt,_t,null),t.bindFramebuffer(36160,J),s.framebufferTexture2D(36160,Ue,Pe,n.get(Je).__webglTexture,0),t.bindFramebuffer(36160,null)}function Pt(J,ce,Je){if(s.bindRenderbuffer(36161,J),ce.depthBuffer&&!ce.stencilBuffer){let Ue=33189;if(Je){const Pe=ce.depthTexture;Pe&&Pe.isDepthTexture&&(Pe.type===1015?Ue=36012:Pe.type===1014&&(Ue=33190));const Mt=Xt(ce);s.renderbufferStorageMultisample(36161,Mt,Ue,ce.width,ce.height)}else s.renderbufferStorage(36161,Ue,ce.width,ce.height);s.framebufferRenderbuffer(36160,36096,36161,J)}else if(ce.depthBuffer&&ce.stencilBuffer){if(Je){const Ue=Xt(ce);s.renderbufferStorageMultisample(36161,Ue,35056,ce.width,ce.height)}else s.renderbufferStorage(36161,34041,ce.width,ce.height);s.framebufferRenderbuffer(36160,33306,36161,J)}else{const Ue=ce.isWebGLMultipleRenderTargets===!0?ce.texture[0]:ce.texture,Pe=r.convert(Ue.format),Mt=r.convert(Ue.type),_t=k(Ue.internalFormat,Pe,Mt);if(Je){const Ne=Xt(ce);s.renderbufferStorageMultisample(36161,Ne,_t,ce.width,ce.height)}else s.renderbufferStorage(36161,_t,ce.width,ce.height)}s.bindRenderbuffer(36161,null)}function Ht(J){const ce=n.get(J),Je=J.isWebGLCubeRenderTarget===!0;if(J.depthTexture){if(Je)throw new Error("target.depthTexture not supported in Cube render targets");(function(Ue,Pe){if(Pe&&Pe.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,Ue),!Pe.depthTexture||!Pe.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");n.get(Pe.depthTexture).__webglTexture&&Pe.depthTexture.image.width===Pe.width&&Pe.depthTexture.image.height===Pe.height||(Pe.depthTexture.image.width=Pe.width,Pe.depthTexture.image.height=Pe.height,Pe.depthTexture.needsUpdate=!0),Fe(Pe.depthTexture,0);const Mt=n.get(Pe.depthTexture).__webglTexture;if(Pe.depthTexture.format===1026)s.framebufferTexture2D(36160,36096,3553,Mt,0);else{if(Pe.depthTexture.format!==1027)throw new Error("Unknown depthTexture format");s.framebufferTexture2D(36160,33306,3553,Mt,0)}})(ce.__webglFramebuffer,J)}else if(Je){ce.__webglDepthbuffer=[];for(let Ue=0;Ue<6;Ue++)t.bindFramebuffer(36160,ce.__webglFramebuffer[Ue]),ce.__webglDepthbuffer[Ue]=s.createRenderbuffer(),Pt(ce.__webglDepthbuffer[Ue],J,!1)}else t.bindFramebuffer(36160,ce.__webglFramebuffer),ce.__webglDepthbuffer=s.createRenderbuffer(),Pt(ce.__webglDepthbuffer,J,!1);t.bindFramebuffer(36160,null)}function Xt(J){return l&&J.isWebGLMultisampleRenderTarget?Math.min(p,J.samples):0}let Zt=!1,pt=!1;this.allocateTextureUnit=function(){const J=we;return J>=c&&console.warn("THREE.WebGLTextures: Trying to use "+J+" texture units while this GPU supports only "+c),we+=1,J},this.resetTextureUnits=function(){we=0},this.setTexture2D=Fe,this.setTexture2DArray=function(J,ce){const Je=n.get(J);J.version>0&&Je.__version!==J.version?ft(Je,J,ce):(t.activeTexture(33984+ce),t.bindTexture(35866,Je.__webglTexture))},this.setTexture3D=function(J,ce){const Je=n.get(J);J.version>0&&Je.__version!==J.version?ft(Je,J,ce):(t.activeTexture(33984+ce),t.bindTexture(32879,Je.__webglTexture))},this.setTextureCube=Te,this.setupRenderTarget=function(J){const ce=J.texture,Je=n.get(J),Ue=n.get(ce);J.addEventListener("dispose",ye),J.isWebGLMultipleRenderTargets!==!0&&(Ue.__webglTexture=s.createTexture(),Ue.__version=ce.version,a.memory.textures++);const Pe=J.isWebGLCubeRenderTarget===!0,Mt=J.isWebGLMultipleRenderTargets===!0,_t=J.isWebGLMultisampleRenderTarget===!0,Ne=ce.isDataTexture3D||ce.isDataTexture2DArray,j=_(J)||l;if(!l||ce.format!==1022||ce.type!==1015&&ce.type!==1016||(ce.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),Pe){Je.__webglFramebuffer=[];for(let Ee=0;Ee<6;Ee++)Je.__webglFramebuffer[Ee]=s.createFramebuffer()}else if(Je.__webglFramebuffer=s.createFramebuffer(),Mt)if(i.drawBuffers){const Ee=J.texture;for(let $e=0,rt=Ee.length;$e<rt;$e++){const Qe=n.get(Ee[$e]);Qe.__webglTexture===void 0&&(Qe.__webglTexture=s.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(_t)if(l){Je.__webglMultisampledFramebuffer=s.createFramebuffer(),Je.__webglColorRenderbuffer=s.createRenderbuffer(),s.bindRenderbuffer(36161,Je.__webglColorRenderbuffer);const Ee=r.convert(ce.format),$e=r.convert(ce.type),rt=k(ce.internalFormat,Ee,$e),Qe=Xt(J);s.renderbufferStorageMultisample(36161,Qe,rt,J.width,J.height),t.bindFramebuffer(36160,Je.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064,36161,Je.__webglColorRenderbuffer),s.bindRenderbuffer(36161,null),J.depthBuffer&&(Je.__webglDepthRenderbuffer=s.createRenderbuffer(),Pt(Je.__webglDepthRenderbuffer,J,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(Pe){t.bindTexture(34067,Ue.__webglTexture),ht(34067,ce,j);for(let Ee=0;Ee<6;Ee++)Lt(Je.__webglFramebuffer[Ee],J,ce,36064,34069+Ee);F(ce,j)&&U(34067,ce,J.width,J.height),t.unbindTexture()}else if(Mt){const Ee=J.texture;for(let $e=0,rt=Ee.length;$e<rt;$e++){const Qe=Ee[$e],Ft=n.get(Qe);t.bindTexture(3553,Ft.__webglTexture),ht(3553,Qe,j),Lt(Je.__webglFramebuffer,J,Qe,36064+$e,3553),F(Qe,j)&&U(3553,Qe,J.width,J.height)}t.unbindTexture()}else{let Ee=3553;Ne&&(l?Ee=ce.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(Ee,Ue.__webglTexture),ht(Ee,ce,j),Lt(Je.__webglFramebuffer,J,ce,36064,Ee),F(ce,j)&&U(Ee,ce,J.width,J.height,J.depth),t.unbindTexture()}J.depthBuffer&&Ht(J)},this.updateRenderTargetMipmap=function(J){const ce=_(J)||l,Je=J.isWebGLMultipleRenderTargets===!0?J.texture:[J.texture];for(let Ue=0,Pe=Je.length;Ue<Pe;Ue++){const Mt=Je[Ue];if(F(Mt,ce)){const _t=J.isWebGLCubeRenderTarget?34067:3553,Ne=n.get(Mt).__webglTexture;t.bindTexture(_t,Ne),U(_t,Mt,J.width,J.height),t.unbindTexture()}}},this.updateMultisampleRenderTarget=function(J){if(J.isWebGLMultisampleRenderTarget)if(l){const ce=J.width,Je=J.height;let Ue=16384;J.depthBuffer&&(Ue|=256),J.stencilBuffer&&(Ue|=1024);const Pe=n.get(J);t.bindFramebuffer(36008,Pe.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,Pe.__webglFramebuffer),s.blitFramebuffer(0,0,ce,Je,0,0,ce,Je,Ue,9728),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,Pe.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(J,ce){J&&J.isWebGLRenderTarget&&(Zt===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Zt=!0),J=J.texture),Fe(J,ce)},this.safeSetTextureCube=function(J,ce){J&&J.isWebGLCubeRenderTarget&&(pt===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),pt=!0),J=J.texture),Te(J,ce)}}function gc(s,e,t){const n=t.isWebGL2;return{convert:function(i){let r;if(i===1009)return 5121;if(i===1017)return 32819;if(i===1018)return 32820;if(i===1019)return 33635;if(i===1010)return 5120;if(i===1011)return 5122;if(i===1012)return 5123;if(i===1013)return 5124;if(i===1014)return 5125;if(i===1015)return 5126;if(i===1016)return n?5131:(r=e.get("OES_texture_half_float"),r!==null?r.HALF_FLOAT_OES:null);if(i===1021)return 6406;if(i===1022)return 6407;if(i===1023)return 6408;if(i===1024)return 6409;if(i===1025)return 6410;if(i===1026)return 6402;if(i===1027)return 34041;if(i===1028)return 6403;if(i===1029)return 36244;if(i===1030)return 33319;if(i===1031)return 33320;if(i===1032)return 36248;if(i===1033)return 36249;if(i===33776||i===33777||i===33778||i===33779){if(r=e.get("WEBGL_compressed_texture_s3tc"),r===null)return null;if(i===33776)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===33777)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===33778)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===33779)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===35840||i===35841||i===35842||i===35843){if(r=e.get("WEBGL_compressed_texture_pvrtc"),r===null)return null;if(i===35840)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===35841)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===35842)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===35843)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===36196)return r=e.get("WEBGL_compressed_texture_etc1"),r!==null?r.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===37492||i===37496)&&(r=e.get("WEBGL_compressed_texture_etc"),r!==null)){if(i===37492)return r.COMPRESSED_RGB8_ETC2;if(i===37496)return r.COMPRESSED_RGBA8_ETC2_EAC}return i===37808||i===37809||i===37810||i===37811||i===37812||i===37813||i===37814||i===37815||i===37816||i===37817||i===37818||i===37819||i===37820||i===37821||i===37840||i===37841||i===37842||i===37843||i===37844||i===37845||i===37846||i===37847||i===37848||i===37849||i===37850||i===37851||i===37852||i===37853?(r=e.get("WEBGL_compressed_texture_astc"),r!==null?i:null):i===36492?(r=e.get("EXT_texture_compression_bptc"),r!==null?i:null):i===1020?n?34042:(r=e.get("WEBGL_depth_texture"),r!==null?r.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}class Do extends Jn{constructor(e=[]){super(),this.cameras=e}}Do.prototype.isArrayCamera=!0;class Wr extends E{constructor(){super(),this.type="Group"}}Wr.prototype.isGroup=!0;const rp={type:"move"};class Oo{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Wr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Wr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new H,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new H),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Wr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new H,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new H),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,r=null,a=null;const l=this._targetRay,c=this._grip,h=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(l!==null&&(i=t.getPose(e.targetRaySpace,n),i!==null&&(l.matrix.fromArray(i.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),i.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(i.linearVelocity)):l.hasLinearVelocity=!1,i.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(i.angularVelocity)):l.hasAngularVelocity=!1,this.dispatchEvent(rp))),h&&e.hand){a=!0;for(const b of e.hand.values()){const T=t.getJointPose(b,n);if(h.joints[b.jointName]===void 0){const F=new Wr;F.matrixAutoUpdate=!1,F.visible=!1,h.joints[b.jointName]=F,h.add(F)}const _=h.joints[b.jointName];T!==null&&(_.matrix.fromArray(T.transform.matrix),_.matrix.decompose(_.position,_.rotation,_.scale),_.jointRadius=T.radius),_.visible=T!==null}const d=h.joints["index-finger-tip"],p=h.joints["thumb-tip"],f=d.position.distanceTo(p.position),m=.02,y=.005;h.inputState.pinching&&f>m+y?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!h.inputState.pinching&&f<=m-y&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else c!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),r!==null&&(c.matrix.fromArray(r.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),r.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(r.linearVelocity)):c.hasLinearVelocity=!1,r.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(r.angularVelocity)):c.hasAngularVelocity=!1));return l!==null&&(l.visible=i!==null),c!==null&&(c.visible=r!==null),h!==null&&(h.visible=a!==null),this}}class sp extends Re{constructor(e,t){super();const n=this,i=e.state;let r=null,a=1,l=null,c="local-floor",h=null,d=null,p=null,f=null,m=null,y=!1,b=null,T=null,_=null,F=null,U=null,k=null;const X=[],K=new Map,ye=new Jn;ye.layers.enable(1),ye.viewport=new en;const we=new Jn;we.layers.enable(2),we.viewport=new en;const Fe=[ye,we],Te=new Do;Te.layers.enable(1),Te.layers.enable(2);let Ce=null,St=null;function ht(pt){const J=K.get(pt.inputSource);J&&J.dispatchEvent({type:pt.type,data:pt.inputSource})}function je(){K.forEach(function(pt,J){pt.disconnect(J)}),K.clear(),Ce=null,St=null,i.bindXRFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),p&&t.deleteFramebuffer(p),b&&t.deleteFramebuffer(b),T&&t.deleteRenderbuffer(T),_&&t.deleteRenderbuffer(_),p=null,b=null,T=null,_=null,m=null,f=null,d=null,r=null,Zt.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function ft(pt){const J=r.inputSources;for(let ce=0;ce<X.length;ce++)K.set(J[ce],X[ce]);for(let ce=0;ce<pt.removed.length;ce++){const Je=pt.removed[ce],Ue=K.get(Je);Ue&&(Ue.dispatchEvent({type:"disconnected",data:Je}),K.delete(Je))}for(let ce=0;ce<pt.added.length;ce++){const Je=pt.added[ce],Ue=K.get(Je);Ue&&Ue.dispatchEvent({type:"connected",data:Je})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(pt){let J=X[pt];return J===void 0&&(J=new Oo,X[pt]=J),J.getTargetRaySpace()},this.getControllerGrip=function(pt){let J=X[pt];return J===void 0&&(J=new Oo,X[pt]=J),J.getGripSpace()},this.getHand=function(pt){let J=X[pt];return J===void 0&&(J=new Oo,X[pt]=J),J.getHandSpace()},this.setFramebufferScaleFactor=function(pt){a=pt,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(pt){c=pt,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l},this.getBaseLayer=function(){return f!==null?f:m},this.getBinding=function(){return d},this.getFrame=function(){return F},this.getSession=function(){return r},this.setSession=async function(pt){if(r=pt,r!==null){r.addEventListener("select",ht),r.addEventListener("selectstart",ht),r.addEventListener("selectend",ht),r.addEventListener("squeeze",ht),r.addEventListener("squeezestart",ht),r.addEventListener("squeezeend",ht),r.addEventListener("end",je),r.addEventListener("inputsourceschange",ft);const J=t.getContextAttributes();if(J.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0){const ce={antialias:J.antialias,alpha:J.alpha,depth:J.depth,stencil:J.stencil,framebufferScaleFactor:a};m=new XRWebGLLayer(r,t,ce),r.updateRenderState({baseLayer:m})}else if(t instanceof WebGLRenderingContext){const ce={antialias:!0,alpha:J.alpha,depth:J.depth,stencil:J.stencil,framebufferScaleFactor:a};m=new XRWebGLLayer(r,t,ce),r.updateRenderState({layers:[m]})}else{y=J.antialias;let ce=null;J.depth&&(k=256,J.stencil&&(k|=1024),U=J.stencil?33306:36096,ce=J.stencil?35056:33190);const Je={colorFormat:J.alpha?32856:32849,depthFormat:ce,scaleFactor:a};d=new XRWebGLBinding(r,t),f=d.createProjectionLayer(Je),p=t.createFramebuffer(),r.updateRenderState({layers:[f]}),y&&(b=t.createFramebuffer(),T=t.createRenderbuffer(),t.bindRenderbuffer(36161,T),t.renderbufferStorageMultisample(36161,4,32856,f.textureWidth,f.textureHeight),i.bindFramebuffer(36160,b),t.framebufferRenderbuffer(36160,36064,36161,T),t.bindRenderbuffer(36161,null),ce!==null&&(_=t.createRenderbuffer(),t.bindRenderbuffer(36161,_),t.renderbufferStorageMultisample(36161,4,ce,f.textureWidth,f.textureHeight),t.framebufferRenderbuffer(36160,U,36161,_),t.bindRenderbuffer(36161,null)),i.bindFramebuffer(36160,null))}l=await r.requestReferenceSpace(c),Zt.setContext(r),Zt.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const Lt=new H,Pt=new H;function Ht(pt,J){J===null?pt.matrixWorld.copy(pt.matrix):pt.matrixWorld.multiplyMatrices(J.matrixWorld,pt.matrix),pt.matrixWorldInverse.copy(pt.matrixWorld).invert()}this.updateCamera=function(pt){if(r===null)return;Te.near=we.near=ye.near=pt.near,Te.far=we.far=ye.far=pt.far,Ce===Te.near&&St===Te.far||(r.updateRenderState({depthNear:Te.near,depthFar:Te.far}),Ce=Te.near,St=Te.far);const J=pt.parent,ce=Te.cameras;Ht(Te,J);for(let Ue=0;Ue<ce.length;Ue++)Ht(ce[Ue],J);Te.matrixWorld.decompose(Te.position,Te.quaternion,Te.scale),pt.position.copy(Te.position),pt.quaternion.copy(Te.quaternion),pt.scale.copy(Te.scale),pt.matrix.copy(Te.matrix),pt.matrixWorld.copy(Te.matrixWorld);const Je=pt.children;for(let Ue=0,Pe=Je.length;Ue<Pe;Ue++)Je[Ue].updateMatrixWorld(!0);ce.length===2?function(Ue,Pe,Mt){Lt.setFromMatrixPosition(Pe.matrixWorld),Pt.setFromMatrixPosition(Mt.matrixWorld);const _t=Lt.distanceTo(Pt),Ne=Pe.projectionMatrix.elements,j=Mt.projectionMatrix.elements,Ee=Ne[14]/(Ne[10]-1),$e=Ne[14]/(Ne[10]+1),rt=(Ne[9]+1)/Ne[5],Qe=(Ne[9]-1)/Ne[5],Ft=(Ne[8]-1)/Ne[0],Wt=(j[8]+1)/j[0],kt=Ee*Ft,ln=Ee*Wt,nn=_t/(-Ft+Wt),Qn=nn*-Ft;Pe.matrixWorld.decompose(Ue.position,Ue.quaternion,Ue.scale),Ue.translateX(Qn),Ue.translateZ(nn),Ue.matrixWorld.compose(Ue.position,Ue.quaternion,Ue.scale),Ue.matrixWorldInverse.copy(Ue.matrixWorld).invert();const Sn=Ee+nn,$n=$e+nn,Ci=kt-Qn,ss=ln+(_t-Qn),as=rt*$e/$n*Sn,os=Qe*$e/$n*Sn;Ue.projectionMatrix.makePerspective(Ci,ss,as,os,Sn,$n)}(Te,ye,we):Te.projectionMatrix.copy(ye.projectionMatrix)},this.getCamera=function(){return Te},this.getFoveation=function(){return f!==null?f.fixedFoveation:m!==null?m.fixedFoveation:void 0},this.setFoveation=function(pt){f!==null&&(f.fixedFoveation=pt),m!==null&&m.fixedFoveation!==void 0&&(m.fixedFoveation=pt)};let Xt=null;const Zt=new Bl;Zt.setAnimationLoop(function(pt,J){if(h=J.getViewerPose(l),F=J,h!==null){const Je=h.views;m!==null&&i.bindXRFramebuffer(m.framebuffer);let Ue=!1;Je.length!==Te.cameras.length&&(Te.cameras.length=0,Ue=!0);for(let Pe=0;Pe<Je.length;Pe++){const Mt=Je[Pe];let _t=null;if(m!==null)_t=m.getViewport(Mt);else{const j=d.getViewSubImage(f,Mt);i.bindXRFramebuffer(p),j.depthStencilTexture!==void 0&&t.framebufferTexture2D(36160,U,3553,j.depthStencilTexture,0),t.framebufferTexture2D(36160,36064,3553,j.colorTexture,0),_t=j.viewport}const Ne=Fe[Pe];Ne.matrix.fromArray(Mt.transform.matrix),Ne.projectionMatrix.fromArray(Mt.projectionMatrix),Ne.viewport.set(_t.x,_t.y,_t.width,_t.height),Pe===0&&Te.matrix.copy(Ne.matrix),Ue===!0&&Te.cameras.push(Ne)}y&&(i.bindXRFramebuffer(b),k!==null&&t.clear(k))}const ce=r.inputSources;for(let Je=0;Je<X.length;Je++){const Ue=X[Je],Pe=ce[Je];Ue.update(Pe,J,l)}if(Xt&&Xt(pt,J),y){const Je=f.textureWidth,Ue=f.textureHeight;i.bindFramebuffer(36008,b),i.bindFramebuffer(36009,p),t.invalidateFramebuffer(36008,[U]),t.invalidateFramebuffer(36009,[U]),t.blitFramebuffer(0,0,Je,Ue,0,0,Je,Ue,16384,9728),t.invalidateFramebuffer(36008,[36064]),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null),i.bindFramebuffer(36160,b)}F=null}),this.setAnimationLoop=function(pt){Xt=pt},this.dispose=function(){}}}function ap(s){function e(n,i){n.opacity.value=i.opacity,i.color&&n.diffuse.value.copy(i.color),i.emissive&&n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(n.map.value=i.map),i.alphaMap&&(n.alphaMap.value=i.alphaMap),i.specularMap&&(n.specularMap.value=i.specularMap),i.alphaTest>0&&(n.alphaTest.value=i.alphaTest);const r=s.get(i).envMap;if(r){n.envMap.value=r,n.flipEnvMap.value=r.isCubeTexture&&r.isRenderTargetTexture===!1?-1:1,n.reflectivity.value=i.reflectivity,n.ior.value=i.ior,n.refractionRatio.value=i.refractionRatio;const c=s.get(r).__maxMipLevel;c!==void 0&&(n.maxMipLevel.value=c)}let a,l;i.lightMap&&(n.lightMap.value=i.lightMap,n.lightMapIntensity.value=i.lightMapIntensity),i.aoMap&&(n.aoMap.value=i.aoMap,n.aoMapIntensity.value=i.aoMapIntensity),i.map?a=i.map:i.specularMap?a=i.specularMap:i.displacementMap?a=i.displacementMap:i.normalMap?a=i.normalMap:i.bumpMap?a=i.bumpMap:i.roughnessMap?a=i.roughnessMap:i.metalnessMap?a=i.metalnessMap:i.alphaMap?a=i.alphaMap:i.emissiveMap?a=i.emissiveMap:i.clearcoatMap?a=i.clearcoatMap:i.clearcoatNormalMap?a=i.clearcoatNormalMap:i.clearcoatRoughnessMap?a=i.clearcoatRoughnessMap:i.specularIntensityMap?a=i.specularIntensityMap:i.specularTintMap?a=i.specularTintMap:i.transmissionMap?a=i.transmissionMap:i.thicknessMap&&(a=i.thicknessMap),a!==void 0&&(a.isWebGLRenderTarget&&(a=a.texture),a.matrixAutoUpdate===!0&&a.updateMatrix(),n.uvTransform.value.copy(a.matrix)),i.aoMap?l=i.aoMap:i.lightMap&&(l=i.lightMap),l!==void 0&&(l.isWebGLRenderTarget&&(l=l.texture),l.matrixAutoUpdate===!0&&l.updateMatrix(),n.uv2Transform.value.copy(l.matrix))}function t(n,i){n.roughness.value=i.roughness,n.metalness.value=i.metalness,i.roughnessMap&&(n.roughnessMap.value=i.roughnessMap),i.metalnessMap&&(n.metalnessMap.value=i.metalnessMap),i.emissiveMap&&(n.emissiveMap.value=i.emissiveMap),i.bumpMap&&(n.bumpMap.value=i.bumpMap,n.bumpScale.value=i.bumpScale,i.side===1&&(n.bumpScale.value*=-1)),i.normalMap&&(n.normalMap.value=i.normalMap,n.normalScale.value.copy(i.normalScale),i.side===1&&n.normalScale.value.negate()),i.displacementMap&&(n.displacementMap.value=i.displacementMap,n.displacementScale.value=i.displacementScale,n.displacementBias.value=i.displacementBias),s.get(i).envMap&&(n.envMapIntensity.value=i.envMapIntensity)}return{refreshFogUniforms:function(n,i){n.fogColor.value.copy(i.color),i.isFog?(n.fogNear.value=i.near,n.fogFar.value=i.far):i.isFogExp2&&(n.fogDensity.value=i.density)},refreshMaterialUniforms:function(n,i,r,a,l){i.isMeshBasicMaterial?e(n,i):i.isMeshLambertMaterial?(e(n,i),function(c,h){h.emissiveMap&&(c.emissiveMap.value=h.emissiveMap)}(n,i)):i.isMeshToonMaterial?(e(n,i),function(c,h){h.gradientMap&&(c.gradientMap.value=h.gradientMap),h.emissiveMap&&(c.emissiveMap.value=h.emissiveMap),h.bumpMap&&(c.bumpMap.value=h.bumpMap,c.bumpScale.value=h.bumpScale,h.side===1&&(c.bumpScale.value*=-1)),h.normalMap&&(c.normalMap.value=h.normalMap,c.normalScale.value.copy(h.normalScale),h.side===1&&c.normalScale.value.negate()),h.displacementMap&&(c.displacementMap.value=h.displacementMap,c.displacementScale.value=h.displacementScale,c.displacementBias.value=h.displacementBias)}(n,i)):i.isMeshPhongMaterial?(e(n,i),function(c,h){c.specular.value.copy(h.specular),c.shininess.value=Math.max(h.shininess,1e-4),h.emissiveMap&&(c.emissiveMap.value=h.emissiveMap),h.bumpMap&&(c.bumpMap.value=h.bumpMap,c.bumpScale.value=h.bumpScale,h.side===1&&(c.bumpScale.value*=-1)),h.normalMap&&(c.normalMap.value=h.normalMap,c.normalScale.value.copy(h.normalScale),h.side===1&&c.normalScale.value.negate()),h.displacementMap&&(c.displacementMap.value=h.displacementMap,c.displacementScale.value=h.displacementScale,c.displacementBias.value=h.displacementBias)}(n,i)):i.isMeshStandardMaterial?(e(n,i),i.isMeshPhysicalMaterial?function(c,h,d){t(c,h),c.ior.value=h.ior,h.sheenTint&&c.sheenTint.value.copy(h.sheenTint),h.clearcoat>0&&(c.clearcoat.value=h.clearcoat,c.clearcoatRoughness.value=h.clearcoatRoughness,h.clearcoatMap&&(c.clearcoatMap.value=h.clearcoatMap),h.clearcoatRoughnessMap&&(c.clearcoatRoughnessMap.value=h.clearcoatRoughnessMap),h.clearcoatNormalMap&&(c.clearcoatNormalScale.value.copy(h.clearcoatNormalScale),c.clearcoatNormalMap.value=h.clearcoatNormalMap,h.side===1&&c.clearcoatNormalScale.value.negate())),h.transmission>0&&(c.transmission.value=h.transmission,c.transmissionSamplerMap.value=d.texture,c.transmissionSamplerSize.value.set(d.width,d.height),h.transmissionMap&&(c.transmissionMap.value=h.transmissionMap),c.thickness.value=h.thickness,h.thicknessMap&&(c.thicknessMap.value=h.thicknessMap),c.attenuationDistance.value=h.attenuationDistance,c.attenuationTint.value.copy(h.attenuationTint)),c.specularIntensity.value=h.specularIntensity,c.specularTint.value.copy(h.specularTint),h.specularIntensityMap&&(c.specularIntensityMap.value=h.specularIntensityMap),h.specularTintMap&&(c.specularTintMap.value=h.specularTintMap)}(n,i,l):t(n,i)):i.isMeshMatcapMaterial?(e(n,i),function(c,h){h.matcap&&(c.matcap.value=h.matcap),h.bumpMap&&(c.bumpMap.value=h.bumpMap,c.bumpScale.value=h.bumpScale,h.side===1&&(c.bumpScale.value*=-1)),h.normalMap&&(c.normalMap.value=h.normalMap,c.normalScale.value.copy(h.normalScale),h.side===1&&c.normalScale.value.negate()),h.displacementMap&&(c.displacementMap.value=h.displacementMap,c.displacementScale.value=h.displacementScale,c.displacementBias.value=h.displacementBias)}(n,i)):i.isMeshDepthMaterial?(e(n,i),function(c,h){h.displacementMap&&(c.displacementMap.value=h.displacementMap,c.displacementScale.value=h.displacementScale,c.displacementBias.value=h.displacementBias)}(n,i)):i.isMeshDistanceMaterial?(e(n,i),function(c,h){h.displacementMap&&(c.displacementMap.value=h.displacementMap,c.displacementScale.value=h.displacementScale,c.displacementBias.value=h.displacementBias),c.referencePosition.value.copy(h.referencePosition),c.nearDistance.value=h.nearDistance,c.farDistance.value=h.farDistance}(n,i)):i.isMeshNormalMaterial?(e(n,i),function(c,h){h.bumpMap&&(c.bumpMap.value=h.bumpMap,c.bumpScale.value=h.bumpScale,h.side===1&&(c.bumpScale.value*=-1)),h.normalMap&&(c.normalMap.value=h.normalMap,c.normalScale.value.copy(h.normalScale),h.side===1&&c.normalScale.value.negate()),h.displacementMap&&(c.displacementMap.value=h.displacementMap,c.displacementScale.value=h.displacementScale,c.displacementBias.value=h.displacementBias)}(n,i)):i.isLineBasicMaterial?(function(c,h){c.diffuse.value.copy(h.color),c.opacity.value=h.opacity}(n,i),i.isLineDashedMaterial&&function(c,h){c.dashSize.value=h.dashSize,c.totalSize.value=h.dashSize+h.gapSize,c.scale.value=h.scale}(n,i)):i.isPointsMaterial?function(c,h,d,p){c.diffuse.value.copy(h.color),c.opacity.value=h.opacity,c.size.value=h.size*d,c.scale.value=.5*p,h.map&&(c.map.value=h.map),h.alphaMap&&(c.alphaMap.value=h.alphaMap),h.alphaTest>0&&(c.alphaTest.value=h.alphaTest);let f;h.map?f=h.map:h.alphaMap&&(f=h.alphaMap),f!==void 0&&(f.matrixAutoUpdate===!0&&f.updateMatrix(),c.uvTransform.value.copy(f.matrix))}(n,i,r,a):i.isSpriteMaterial?function(c,h){c.diffuse.value.copy(h.color),c.opacity.value=h.opacity,c.rotation.value=h.rotation,h.map&&(c.map.value=h.map),h.alphaMap&&(c.alphaMap.value=h.alphaMap),h.alphaTest>0&&(c.alphaTest.value=h.alphaTest);let d;h.map?d=h.map:h.alphaMap&&(d=h.alphaMap),d!==void 0&&(d.matrixAutoUpdate===!0&&d.updateMatrix(),c.uvTransform.value.copy(d.matrix))}(n,i):i.isShadowMaterial?(n.color.value.copy(i.color),n.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function En(s={}){const e=s.canvas!==void 0?s.canvas:function(){const Z=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return Z.style.display="block",Z}(),t=s.context!==void 0?s.context:null,n=s.alpha!==void 0&&s.alpha,i=s.depth===void 0||s.depth,r=s.stencil===void 0||s.stencil,a=s.antialias!==void 0&&s.antialias,l=s.premultipliedAlpha===void 0||s.premultipliedAlpha,c=s.preserveDrawingBuffer!==void 0&&s.preserveDrawingBuffer,h=s.powerPreference!==void 0?s.powerPreference:"default",d=s.failIfMajorPerformanceCaveat!==void 0&&s.failIfMajorPerformanceCaveat;let p=null,f=null;const m=[],y=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const b=this;let T=!1,_=0,F=0,U=null,k=-1,X=null;const K=new en,ye=new en;let we=null,Fe=e.width,Te=e.height,Ce=1,St=null,ht=null;const je=new en(0,0,Fe,Te),ft=new en(0,0,Fe,Te);let Lt=!1;const Pt=[],Ht=new Ws;let Xt=!1,Zt=!1,pt=null;const J=new Dt,ce=new H,Je={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Ue(){return U===null?Ce:1}let Pe,Mt,_t,Ne,j,Ee,$e,rt,Qe,Ft,Wt,kt,ln,nn,Qn,Sn,$n,Ci,ss,as,os,ki,bi,vt=t;function Yu(Z,Xe){for(let Ae=0;Ae<Z.length;Ae++){const Ze=Z[Ae],mt=e.getContext(Ze,Xe);if(mt!==null)return mt}return null}try{const Z={alpha:n,depth:i,stencil:r,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:d};if(e.addEventListener("webglcontextlost",Ku,!1),e.addEventListener("webglcontextrestored",Qu,!1),vt===null){const Xe=["webgl2","webgl","experimental-webgl"];if(b.isWebGL1Renderer===!0&&Xe.shift(),vt=Yu(Xe,Z),vt===null)throw Yu(Xe)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}vt.getShaderPrecisionFormat===void 0&&(vt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Z){throw console.error("THREE.WebGLRenderer: "+Z.message),Z}function Ju(){Pe=new Wh(vt),Mt=new zh(vt,Pe,s),Pe.init(Mt),ki=new gc(vt,Pe,Mt),_t=new np(vt,Pe,Mt),Pt[0]=1029,Ne=new Xh,j=new Zd,Ee=new ip(vt,Pe,_t,j,Mt,ki,Ne),$e=new Uh(b),rt=new Vh(b),Qe=new Oh(vt,Mt),bi=new Nh(vt,Pe,Qe,Mt),Ft=new jh(vt,Qe,Ne,bi),Wt=new Kh(vt,Ft,Qe,Ne),ss=new Jh(vt),Sn=new kh(j),kt=new Xd(b,$e,rt,Pe,Mt,bi,Sn),ln=new ap(j),nn=new Jd(j),Qn=new tp(Pe,Mt),Ci=new Fh(b,$e,_t,Wt,l),$n=new mc(b,Wt,Mt),as=new Bh(vt,Pe,Ne,Mt),os=new qh(vt,Pe,Ne,Mt),Ne.programs=kt.programs,b.capabilities=Mt,b.extensions=Pe,b.properties=j,b.renderLists=nn,b.shadowMap=$n,b.state=_t,b.info=Ne}Ju();const Pi=new sp(b,vt);function Ku(Z){Z.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),T=!0}function Qu(){console.log("THREE.WebGLRenderer: Context Restored."),T=!1;const Z=Ne.autoReset,Xe=$n.enabled,Ae=$n.autoUpdate,Ze=$n.needsUpdate,mt=$n.type;Ju(),Ne.autoReset=Z,$n.enabled=Xe,$n.autoUpdate=Ae,$n.needsUpdate=Ze,$n.type=mt}function $u(Z){const Xe=Z.target;Xe.removeEventListener("dispose",$u),function(Ae){(function(Ze){const mt=j.get(Ze).programs;mt!==void 0&&mt.forEach(function(tn){kt.releaseProgram(tn)})})(Ae),j.remove(Ae)}(Xe)}this.xr=Pi,this.getContext=function(){return vt},this.getContextAttributes=function(){return vt.getContextAttributes()},this.forceContextLoss=function(){const Z=Pe.get("WEBGL_lose_context");Z&&Z.loseContext()},this.forceContextRestore=function(){const Z=Pe.get("WEBGL_lose_context");Z&&Z.restoreContext()},this.getPixelRatio=function(){return Ce},this.setPixelRatio=function(Z){Z!==void 0&&(Ce=Z,this.setSize(Fe,Te,!1))},this.getSize=function(Z){return Z.set(Fe,Te)},this.setSize=function(Z,Xe,Ae){Pi.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(Fe=Z,Te=Xe,e.width=Math.floor(Z*Ce),e.height=Math.floor(Xe*Ce),Ae!==!1&&(e.style.width=Z+"px",e.style.height=Xe+"px"),this.setViewport(0,0,Z,Xe))},this.getDrawingBufferSize=function(Z){return Z.set(Fe*Ce,Te*Ce).floor()},this.setDrawingBufferSize=function(Z,Xe,Ae){Fe=Z,Te=Xe,Ce=Ae,e.width=Math.floor(Z*Ae),e.height=Math.floor(Xe*Ae),this.setViewport(0,0,Z,Xe)},this.getCurrentViewport=function(Z){return Z.copy(K)},this.getViewport=function(Z){return Z.copy(je)},this.setViewport=function(Z,Xe,Ae,Ze){Z.isVector4?je.set(Z.x,Z.y,Z.z,Z.w):je.set(Z,Xe,Ae,Ze),_t.viewport(K.copy(je).multiplyScalar(Ce).floor())},this.getScissor=function(Z){return Z.copy(ft)},this.setScissor=function(Z,Xe,Ae,Ze){Z.isVector4?ft.set(Z.x,Z.y,Z.z,Z.w):ft.set(Z,Xe,Ae,Ze),_t.scissor(ye.copy(ft).multiplyScalar(Ce).floor())},this.getScissorTest=function(){return Lt},this.setScissorTest=function(Z){_t.setScissorTest(Lt=Z)},this.setOpaqueSort=function(Z){St=Z},this.setTransparentSort=function(Z){ht=Z},this.getClearColor=function(Z){return Z.copy(Ci.getClearColor())},this.setClearColor=function(){Ci.setClearColor.apply(Ci,arguments)},this.getClearAlpha=function(){return Ci.getClearAlpha()},this.setClearAlpha=function(){Ci.setClearAlpha.apply(Ci,arguments)},this.clear=function(Z,Xe,Ae){let Ze=0;(Z===void 0||Z)&&(Ze|=16384),(Xe===void 0||Xe)&&(Ze|=256),(Ae===void 0||Ae)&&(Ze|=1024),vt.clear(Ze)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Ku,!1),e.removeEventListener("webglcontextrestored",Qu,!1),nn.dispose(),Qn.dispose(),j.dispose(),$e.dispose(),rt.dispose(),Wt.dispose(),bi.dispose(),Pi.dispose(),Pi.removeEventListener("sessionstart",eh),Pi.removeEventListener("sessionend",th),pt&&(pt.dispose(),pt=null),ls.stop()},this.renderBufferImmediate=function(Z,Xe){bi.initAttributes();const Ae=j.get(Z);Z.hasPositions&&!Ae.position&&(Ae.position=vt.createBuffer()),Z.hasNormals&&!Ae.normal&&(Ae.normal=vt.createBuffer()),Z.hasUvs&&!Ae.uv&&(Ae.uv=vt.createBuffer()),Z.hasColors&&!Ae.color&&(Ae.color=vt.createBuffer());const Ze=Xe.getAttributes();Z.hasPositions&&(vt.bindBuffer(34962,Ae.position),vt.bufferData(34962,Z.positionArray,35048),bi.enableAttribute(Ze.position.location),vt.vertexAttribPointer(Ze.position.location,3,5126,!1,0,0)),Z.hasNormals&&(vt.bindBuffer(34962,Ae.normal),vt.bufferData(34962,Z.normalArray,35048),bi.enableAttribute(Ze.normal.location),vt.vertexAttribPointer(Ze.normal.location,3,5126,!1,0,0)),Z.hasUvs&&(vt.bindBuffer(34962,Ae.uv),vt.bufferData(34962,Z.uvArray,35048),bi.enableAttribute(Ze.uv.location),vt.vertexAttribPointer(Ze.uv.location,2,5126,!1,0,0)),Z.hasColors&&(vt.bindBuffer(34962,Ae.color),vt.bufferData(34962,Z.colorArray,35048),bi.enableAttribute(Ze.color.location),vt.vertexAttribPointer(Ze.color.location,3,5126,!1,0,0)),bi.disableUnusedAttributes(),vt.drawArrays(4,0,Z.count),Z.count=0},this.renderBufferDirect=function(Z,Xe,Ae,Ze,mt,tn){Xe===null&&(Xe=Je);const Gt=mt.isMesh&&mt.matrixWorld.determinant()<0,sn=sh(Z,Xe,Ze,mt);_t.setMaterial(Ze,Gt);let pn=Ae.index;const An=Ae.attributes.position;if(pn===null){if(An===void 0||An.count===0)return}else if(pn.count===0)return;let xn,fn=1;Ze.wireframe===!0&&(pn=Ft.getWireframeAttribute(Ae),fn=2),Ae.morphAttributes.position===void 0&&Ae.morphAttributes.normal===void 0||ss.update(mt,Ae,Ze,sn),bi.setup(mt,Ze,sn,Ae,pn);let an=as;pn!==null&&(xn=Qe.get(pn),an=os,an.setIndex(xn));const cs=pn!==null?pn.count:An.count,zn=Ae.drawRange.start*fn,Fr=Ae.drawRange.count*fn,Zi=tn!==null?tn.start*fn:0,us=tn!==null?tn.count*fn:1/0,Nr=Math.max(zn,Zi),ei=Math.min(cs,zn+Fr,Zi+us)-1,or=Math.max(0,ei-Nr+1);if(or!==0){if(mt.isMesh)Ze.wireframe===!0?(_t.setLineWidth(Ze.wireframeLinewidth*Ue()),an.setMode(1)):an.setMode(4);else if(mt.isLine){let di=Ze.linewidth;di===void 0&&(di=1),_t.setLineWidth(di*Ue()),mt.isLineSegments?an.setMode(1):mt.isLineLoop?an.setMode(2):an.setMode(3)}else mt.isPoints?an.setMode(0):mt.isSprite&&an.setMode(4);if(mt.isInstancedMesh)an.renderInstances(Nr,or,mt.count);else if(Ae.isInstancedBufferGeometry){const di=Math.min(Ae.instanceCount,Ae._maxInstanceCount);an.renderInstances(Nr,or,di)}else an.render(Nr,or)}},this.compile=function(Z,Xe){f=Qn.get(Z),f.init(),y.push(f),Z.traverseVisible(function(Ae){Ae.isLight&&Ae.layers.test(Xe.layers)&&(f.pushLight(Ae),Ae.castShadow&&f.pushShadow(Ae))}),f.setupLights(b.physicallyCorrectLights),Z.traverse(function(Ae){const Ze=Ae.material;if(Ze)if(Array.isArray(Ze))for(let mt=0;mt<Ze.length;mt++)Cl(Ze[mt],Z,Ae);else Cl(Ze,Z,Ae)}),y.pop(),f=null};let Rl=null;function eh(){ls.stop()}function th(){ls.start()}const ls=new Bl;function nh(Z,Xe,Ae,Ze){if(Z.visible===!1)return;if(Z.layers.test(Xe.layers)){if(Z.isGroup)Ae=Z.renderOrder;else if(Z.isLOD)Z.autoUpdate===!0&&Z.update(Xe);else if(Z.isLight)f.pushLight(Z),Z.castShadow&&f.pushShadow(Z);else if(Z.isSprite){if(!Z.frustumCulled||Ht.intersectsSprite(Z)){Ze&&ce.setFromMatrixPosition(Z.matrixWorld).applyMatrix4(J);const tn=Wt.update(Z),Gt=Z.material;Gt.visible&&p.push(Z,tn,Gt,Ae,ce.z,null)}}else if(Z.isImmediateRenderObject)Ze&&ce.setFromMatrixPosition(Z.matrixWorld).applyMatrix4(J),p.push(Z,null,Z.material,Ae,ce.z,null);else if((Z.isMesh||Z.isLine||Z.isPoints)&&(Z.isSkinnedMesh&&Z.skeleton.frame!==Ne.render.frame&&(Z.skeleton.update(),Z.skeleton.frame=Ne.render.frame),!Z.frustumCulled||Ht.intersectsObject(Z))){Ze&&ce.setFromMatrixPosition(Z.matrixWorld).applyMatrix4(J);const tn=Wt.update(Z),Gt=Z.material;if(Array.isArray(Gt)){const sn=tn.groups;for(let pn=0,An=sn.length;pn<An;pn++){const xn=sn[pn],fn=Gt[xn.materialIndex];fn&&fn.visible&&p.push(Z,tn,fn,Ae,ce.z,xn)}}else Gt.visible&&p.push(Z,tn,Gt,Ae,ce.z,null)}}const mt=Z.children;for(let tn=0,Gt=mt.length;tn<Gt;tn++)nh(mt[tn],Xe,Ae,Ze)}function ih(Z,Xe,Ae,Ze){const mt=Z.opaque,tn=Z.transmissive,Gt=Z.transparent;f.setupLightsView(Ae),tn.length>0&&function(sn,pn,An){if(pt===null){const an=a===!0&&Mt.isWebGL2===!0;pt=new(an?wi:Nn)(1024,1024,{generateMipmaps:!0,type:ki.convert(1016)!==null?1016:1009,minFilter:1008,magFilter:1003,wrapS:1001,wrapT:1001})}const xn=b.getRenderTarget();b.setRenderTarget(pt),b.clear();const fn=b.toneMapping;b.toneMapping=0,mo(sn,pn,An),b.toneMapping=fn,Ee.updateMultisampleRenderTarget(pt),Ee.updateRenderTargetMipmap(pt),b.setRenderTarget(xn)}(mt,Xe,Ae),Ze&&_t.viewport(K.copy(Ze)),mt.length>0&&mo(mt,Xe,Ae),tn.length>0&&mo(tn,Xe,Ae),Gt.length>0&&mo(Gt,Xe,Ae)}function mo(Z,Xe,Ae){const Ze=Xe.isScene===!0?Xe.overrideMaterial:null;for(let mt=0,tn=Z.length;mt<tn;mt++){const Gt=Z[mt],sn=Gt.object,pn=Gt.geometry,An=Ze===null?Gt.material:Ze,xn=Gt.group;sn.layers.test(Ae.layers)&&kp(sn,Xe,Ae,pn,An,xn)}}function kp(Z,Xe,Ae,Ze,mt,tn){if(Z.onBeforeRender(b,Xe,Ae,Ze,mt,tn),Z.modelViewMatrix.multiplyMatrices(Ae.matrixWorldInverse,Z.matrixWorld),Z.normalMatrix.getNormalMatrix(Z.modelViewMatrix),Z.isImmediateRenderObject){const Gt=sh(Ae,Xe,mt,Z);_t.setMaterial(mt),bi.reset(),function(sn,pn){sn.render(function(An){b.renderBufferImmediate(An,pn)})}(Z,Gt)}else mt.transparent===!0&&mt.side===2?(mt.side=1,mt.needsUpdate=!0,b.renderBufferDirect(Ae,Xe,Ze,mt,Z,tn),mt.side=0,mt.needsUpdate=!0,b.renderBufferDirect(Ae,Xe,Ze,mt,Z,tn),mt.side=2):b.renderBufferDirect(Ae,Xe,Ze,mt,Z,tn);Z.onAfterRender(b,Xe,Ae,Ze,mt,tn)}function Cl(Z,Xe,Ae){Xe.isScene!==!0&&(Xe=Je);const Ze=j.get(Z),mt=f.state.lights,tn=f.state.shadowsArray,Gt=mt.state.version,sn=kt.getParameters(Z,mt.state,tn,Xe,Ae),pn=kt.getProgramCacheKey(sn);let An=Ze.programs;Ze.environment=Z.isMeshStandardMaterial?Xe.environment:null,Ze.fog=Xe.fog,Ze.envMap=(Z.isMeshStandardMaterial?rt:$e).get(Z.envMap||Ze.environment),An===void 0&&(Z.addEventListener("dispose",$u),An=new Map,Ze.programs=An);let xn=An.get(pn);if(xn!==void 0){if(Ze.currentProgram===xn&&Ze.lightsStateVersion===Gt)return rh(Z,sn),xn}else sn.uniforms=kt.getUniforms(Z),Z.onBuild(sn,b),Z.onBeforeCompile(sn,b),xn=kt.acquireProgram(sn,pn),An.set(pn,xn),Ze.uniforms=sn.uniforms;const fn=Ze.uniforms;(Z.isShaderMaterial||Z.isRawShaderMaterial)&&Z.clipping!==!0||(fn.clippingPlanes=Sn.uniform),rh(Z,sn),Ze.needsLights=function(zn){return zn.isMeshLambertMaterial||zn.isMeshToonMaterial||zn.isMeshPhongMaterial||zn.isMeshStandardMaterial||zn.isShadowMaterial||zn.isShaderMaterial&&zn.lights===!0}(Z),Ze.lightsStateVersion=Gt,Ze.needsLights&&(fn.ambientLightColor.value=mt.state.ambient,fn.lightProbe.value=mt.state.probe,fn.directionalLights.value=mt.state.directional,fn.directionalLightShadows.value=mt.state.directionalShadow,fn.spotLights.value=mt.state.spot,fn.spotLightShadows.value=mt.state.spotShadow,fn.rectAreaLights.value=mt.state.rectArea,fn.ltc_1.value=mt.state.rectAreaLTC1,fn.ltc_2.value=mt.state.rectAreaLTC2,fn.pointLights.value=mt.state.point,fn.pointLightShadows.value=mt.state.pointShadow,fn.hemisphereLights.value=mt.state.hemi,fn.directionalShadowMap.value=mt.state.directionalShadowMap,fn.directionalShadowMatrix.value=mt.state.directionalShadowMatrix,fn.spotShadowMap.value=mt.state.spotShadowMap,fn.spotShadowMatrix.value=mt.state.spotShadowMatrix,fn.pointShadowMap.value=mt.state.pointShadowMap,fn.pointShadowMatrix.value=mt.state.pointShadowMatrix);const an=xn.getUniforms(),cs=Rr.seqWithValue(an.seq,fn);return Ze.currentProgram=xn,Ze.uniformsList=cs,xn}function rh(Z,Xe){const Ae=j.get(Z);Ae.outputEncoding=Xe.outputEncoding,Ae.instancing=Xe.instancing,Ae.skinning=Xe.skinning,Ae.morphTargets=Xe.morphTargets,Ae.morphNormals=Xe.morphNormals,Ae.numClippingPlanes=Xe.numClippingPlanes,Ae.numIntersection=Xe.numClipIntersection,Ae.vertexAlphas=Xe.vertexAlphas,Ae.vertexTangents=Xe.vertexTangents}function sh(Z,Xe,Ae,Ze){Xe.isScene!==!0&&(Xe=Je),Ee.resetTextureUnits();const mt=Xe.fog,tn=Ae.isMeshStandardMaterial?Xe.environment:null,Gt=U===null?b.outputEncoding:U.texture.encoding,sn=(Ae.isMeshStandardMaterial?rt:$e).get(Ae.envMap||tn),pn=Ae.vertexColors===!0&&!!Ze.geometry&&!!Ze.geometry.attributes.color&&Ze.geometry.attributes.color.itemSize===4,An=!!Ze.geometry&&!!Ze.geometry.attributes.tangent,xn=!!Ze.geometry&&!!Ze.geometry.morphAttributes.position,fn=!!Ze.geometry&&!!Ze.geometry.morphAttributes.normal,an=j.get(Ae),cs=f.state.lights;if(Xt===!0&&(Zt===!0||Z!==X)){const Ji=Z===X&&Ae.id===k;Sn.setState(Ae,Z,Ji)}let zn=!1;Ae.version===an.__version?an.needsLights&&an.lightsStateVersion!==cs.state.version||an.outputEncoding!==Gt||Ze.isInstancedMesh&&an.instancing===!1?zn=!0:Ze.isInstancedMesh||an.instancing!==!0?Ze.isSkinnedMesh&&an.skinning===!1?zn=!0:Ze.isSkinnedMesh||an.skinning!==!0?an.envMap!==sn||Ae.fog&&an.fog!==mt?zn=!0:an.numClippingPlanes===void 0||an.numClippingPlanes===Sn.numPlanes&&an.numIntersection===Sn.numIntersection?(an.vertexAlphas!==pn||an.vertexTangents!==An||an.morphTargets!==xn||an.morphNormals!==fn)&&(zn=!0):zn=!0:zn=!0:zn=!0:(zn=!0,an.__version=Ae.version);let Fr=an.currentProgram;zn===!0&&(Fr=Cl(Ae,Xe,Ze));let Zi=!1,us=!1,Nr=!1;const ei=Fr.getUniforms(),or=an.uniforms;if(_t.useProgram(Fr.program)&&(Zi=!0,us=!0,Nr=!0),Ae.id!==k&&(k=Ae.id,us=!0),Zi||X!==Z){if(ei.setValue(vt,"projectionMatrix",Z.projectionMatrix),Mt.logarithmicDepthBuffer&&ei.setValue(vt,"logDepthBufFC",2/(Math.log(Z.far+1)/Math.LN2)),X!==Z&&(X=Z,us=!0,Nr=!0),Ae.isShaderMaterial||Ae.isMeshPhongMaterial||Ae.isMeshToonMaterial||Ae.isMeshStandardMaterial||Ae.envMap){const Ji=ei.map.cameraPosition;Ji!==void 0&&Ji.setValue(vt,ce.setFromMatrixPosition(Z.matrixWorld))}(Ae.isMeshPhongMaterial||Ae.isMeshToonMaterial||Ae.isMeshLambertMaterial||Ae.isMeshBasicMaterial||Ae.isMeshStandardMaterial||Ae.isShaderMaterial)&&ei.setValue(vt,"isOrthographic",Z.isOrthographicCamera===!0),(Ae.isMeshPhongMaterial||Ae.isMeshToonMaterial||Ae.isMeshLambertMaterial||Ae.isMeshBasicMaterial||Ae.isMeshStandardMaterial||Ae.isShaderMaterial||Ae.isShadowMaterial||Ze.isSkinnedMesh)&&ei.setValue(vt,"viewMatrix",Z.matrixWorldInverse)}if(Ze.isSkinnedMesh){ei.setOptional(vt,Ze,"bindMatrix"),ei.setOptional(vt,Ze,"bindMatrixInverse");const Ji=Ze.skeleton;Ji&&(Mt.floatVertexTextures?(Ji.boneTexture===null&&Ji.computeBoneTexture(),ei.setValue(vt,"boneTexture",Ji.boneTexture,Ee),ei.setValue(vt,"boneTextureSize",Ji.boneTextureSize)):ei.setOptional(vt,Ji,"boneMatrices"))}var di,Yi;return(us||an.receiveShadow!==Ze.receiveShadow)&&(an.receiveShadow=Ze.receiveShadow,ei.setValue(vt,"receiveShadow",Ze.receiveShadow)),us&&(ei.setValue(vt,"toneMappingExposure",b.toneMappingExposure),an.needsLights&&(Yi=Nr,(di=or).ambientLightColor.needsUpdate=Yi,di.lightProbe.needsUpdate=Yi,di.directionalLights.needsUpdate=Yi,di.directionalLightShadows.needsUpdate=Yi,di.pointLights.needsUpdate=Yi,di.pointLightShadows.needsUpdate=Yi,di.spotLights.needsUpdate=Yi,di.spotLightShadows.needsUpdate=Yi,di.rectAreaLights.needsUpdate=Yi,di.hemisphereLights.needsUpdate=Yi),mt&&Ae.fog&&ln.refreshFogUniforms(or,mt),ln.refreshMaterialUniforms(or,Ae,Ce,Te,pt),Rr.upload(vt,an.uniformsList,or,Ee)),Ae.isShaderMaterial&&Ae.uniformsNeedUpdate===!0&&(Rr.upload(vt,an.uniformsList,or,Ee),Ae.uniformsNeedUpdate=!1),Ae.isSpriteMaterial&&ei.setValue(vt,"center",Ze.center),ei.setValue(vt,"modelViewMatrix",Ze.modelViewMatrix),ei.setValue(vt,"normalMatrix",Ze.normalMatrix),ei.setValue(vt,"modelMatrix",Ze.matrixWorld),Fr}ls.setAnimationLoop(function(Z){Rl&&Rl(Z)}),typeof window<"u"&&ls.setContext(window),this.setAnimationLoop=function(Z){Rl=Z,Pi.setAnimationLoop(Z),Z===null?ls.stop():ls.start()},Pi.addEventListener("sessionstart",eh),Pi.addEventListener("sessionend",th),this.render=function(Z,Xe){if(Xe!==void 0&&Xe.isCamera!==!0)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(T===!0)return;Z.autoUpdate===!0&&Z.updateMatrixWorld(),Xe.parent===null&&Xe.updateMatrixWorld(),Pi.enabled===!0&&Pi.isPresenting===!0&&(Pi.cameraAutoUpdate===!0&&Pi.updateCamera(Xe),Xe=Pi.getCamera()),Z.isScene===!0&&Z.onBeforeRender(b,Z,Xe,U),f=Qn.get(Z,y.length),f.init(),y.push(f),J.multiplyMatrices(Xe.projectionMatrix,Xe.matrixWorldInverse),Ht.setFromProjectionMatrix(J),Zt=this.localClippingEnabled,Xt=Sn.init(this.clippingPlanes,Zt,Xe),p=nn.get(Z,m.length),p.init(),m.push(p),nh(Z,Xe,0,b.sortObjects),p.finish(),b.sortObjects===!0&&p.sort(St,ht),Xt===!0&&Sn.beginShadows();const Ae=f.state.shadowsArray;if($n.render(Ae,Z,Xe),Xt===!0&&Sn.endShadows(),this.info.autoReset===!0&&this.info.reset(),Ci.render(p,Z),f.setupLights(b.physicallyCorrectLights),Xe.isArrayCamera){const Ze=Xe.cameras;for(let mt=0,tn=Ze.length;mt<tn;mt++){const Gt=Ze[mt];ih(p,Z,Gt,Gt.viewport)}}else ih(p,Z,Xe);U!==null&&(Ee.updateMultisampleRenderTarget(U),Ee.updateRenderTargetMipmap(U)),Z.isScene===!0&&Z.onAfterRender(b,Z,Xe),_t.buffers.depth.setTest(!0),_t.buffers.depth.setMask(!0),_t.buffers.color.setMask(!0),_t.setPolygonOffset(!1),bi.resetDefaultState(),k=-1,X=null,y.pop(),f=y.length>0?y[y.length-1]:null,m.pop(),p=m.length>0?m[m.length-1]:null},this.getActiveCubeFace=function(){return _},this.getActiveMipmapLevel=function(){return F},this.getRenderTarget=function(){return U},this.setRenderTarget=function(Z,Xe=0,Ae=0){U=Z,_=Xe,F=Ae,Z&&j.get(Z).__webglFramebuffer===void 0&&Ee.setupRenderTarget(Z);let Ze=null,mt=!1,tn=!1;if(Z){const Gt=Z.texture;(Gt.isDataTexture3D||Gt.isDataTexture2DArray)&&(tn=!0);const sn=j.get(Z).__webglFramebuffer;Z.isWebGLCubeRenderTarget?(Ze=sn[Xe],mt=!0):Ze=Z.isWebGLMultisampleRenderTarget?j.get(Z).__webglMultisampledFramebuffer:sn,K.copy(Z.viewport),ye.copy(Z.scissor),we=Z.scissorTest}else K.copy(je).multiplyScalar(Ce).floor(),ye.copy(ft).multiplyScalar(Ce).floor(),we=Lt;if(_t.bindFramebuffer(36160,Ze)&&Mt.drawBuffers){let Gt=!1;if(Z)if(Z.isWebGLMultipleRenderTargets){const sn=Z.texture;if(Pt.length!==sn.length||Pt[0]!==36064){for(let pn=0,An=sn.length;pn<An;pn++)Pt[pn]=36064+pn;Pt.length=sn.length,Gt=!0}}else Pt.length===1&&Pt[0]===36064||(Pt[0]=36064,Pt.length=1,Gt=!0);else Pt.length===1&&Pt[0]===1029||(Pt[0]=1029,Pt.length=1,Gt=!0);Gt&&(Mt.isWebGL2?vt.drawBuffers(Pt):Pe.get("WEBGL_draw_buffers").drawBuffersWEBGL(Pt))}if(_t.viewport(K),_t.scissor(ye),_t.setScissorTest(we),mt){const Gt=j.get(Z.texture);vt.framebufferTexture2D(36160,36064,34069+Xe,Gt.__webglTexture,Ae)}else if(tn){const Gt=j.get(Z.texture),sn=Xe||0;vt.framebufferTextureLayer(36160,36064,Gt.__webglTexture,Ae||0,sn)}k=-1},this.readRenderTargetPixels=function(Z,Xe,Ae,Ze,mt,tn,Gt){if(!Z||!Z.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let sn=j.get(Z).__webglFramebuffer;if(Z.isWebGLCubeRenderTarget&&Gt!==void 0&&(sn=sn[Gt]),sn){_t.bindFramebuffer(36160,sn);try{const pn=Z.texture,An=pn.format,xn=pn.type;if(An!==1023&&ki.convert(An)!==vt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const fn=xn===1016&&(Pe.has("EXT_color_buffer_half_float")||Mt.isWebGL2&&Pe.has("EXT_color_buffer_float"));if(!(xn===1009||ki.convert(xn)===vt.getParameter(35738)||xn===1015&&(Mt.isWebGL2||Pe.has("OES_texture_float")||Pe.has("WEBGL_color_buffer_float"))||fn))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");vt.checkFramebufferStatus(36160)===36053?Xe>=0&&Xe<=Z.width-Ze&&Ae>=0&&Ae<=Z.height-mt&&vt.readPixels(Xe,Ae,Ze,mt,ki.convert(An),ki.convert(xn),tn):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const pn=U!==null?j.get(U).__webglFramebuffer:null;_t.bindFramebuffer(36160,pn)}}},this.copyFramebufferToTexture=function(Z,Xe,Ae=0){const Ze=Math.pow(2,-Ae),mt=Math.floor(Xe.image.width*Ze),tn=Math.floor(Xe.image.height*Ze);let Gt=ki.convert(Xe.format);Mt.isWebGL2&&(Gt===6407&&(Gt=32849),Gt===6408&&(Gt=32856)),Ee.setTexture2D(Xe,0),vt.copyTexImage2D(3553,Ae,Gt,Z.x,Z.y,mt,tn,0),_t.unbindTexture()},this.copyTextureToTexture=function(Z,Xe,Ae,Ze=0){const mt=Xe.image.width,tn=Xe.image.height,Gt=ki.convert(Ae.format),sn=ki.convert(Ae.type);Ee.setTexture2D(Ae,0),vt.pixelStorei(37440,Ae.flipY),vt.pixelStorei(37441,Ae.premultiplyAlpha),vt.pixelStorei(3317,Ae.unpackAlignment),Xe.isDataTexture?vt.texSubImage2D(3553,Ze,Z.x,Z.y,mt,tn,Gt,sn,Xe.image.data):Xe.isCompressedTexture?vt.compressedTexSubImage2D(3553,Ze,Z.x,Z.y,Xe.mipmaps[0].width,Xe.mipmaps[0].height,Gt,Xe.mipmaps[0].data):vt.texSubImage2D(3553,Ze,Z.x,Z.y,Gt,sn,Xe.image),Ze===0&&Ae.generateMipmaps&&vt.generateMipmap(3553),_t.unbindTexture()},this.copyTextureToTexture3D=function(Z,Xe,Ae,Ze,mt=0){if(b.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const tn=Z.max.x-Z.min.x+1,Gt=Z.max.y-Z.min.y+1,sn=Z.max.z-Z.min.z+1,pn=ki.convert(Ze.format),An=ki.convert(Ze.type);let xn;if(Ze.isDataTexture3D)Ee.setTexture3D(Ze,0),xn=32879;else{if(!Ze.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");Ee.setTexture2DArray(Ze,0),xn=35866}vt.pixelStorei(37440,Ze.flipY),vt.pixelStorei(37441,Ze.premultiplyAlpha),vt.pixelStorei(3317,Ze.unpackAlignment);const fn=vt.getParameter(3314),an=vt.getParameter(32878),cs=vt.getParameter(3316),zn=vt.getParameter(3315),Fr=vt.getParameter(32877),Zi=Ae.isCompressedTexture?Ae.mipmaps[0]:Ae.image;vt.pixelStorei(3314,Zi.width),vt.pixelStorei(32878,Zi.height),vt.pixelStorei(3316,Z.min.x),vt.pixelStorei(3315,Z.min.y),vt.pixelStorei(32877,Z.min.z),Ae.isDataTexture||Ae.isDataTexture3D?vt.texSubImage3D(xn,mt,Xe.x,Xe.y,Xe.z,tn,Gt,sn,pn,An,Zi.data):Ae.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),vt.compressedTexSubImage3D(xn,mt,Xe.x,Xe.y,Xe.z,tn,Gt,sn,pn,Zi.data)):vt.texSubImage3D(xn,mt,Xe.x,Xe.y,Xe.z,tn,Gt,sn,pn,An,Zi),vt.pixelStorei(3314,fn),vt.pixelStorei(32878,an),vt.pixelStorei(3316,cs),vt.pixelStorei(3315,zn),vt.pixelStorei(32877,Fr),mt===0&&Ze.generateMipmaps&&vt.generateMipmap(xn),_t.unbindTexture()},this.initTexture=function(Z){Ee.setTexture2D(Z,0),_t.unbindTexture()},this.resetState=function(){_=0,F=0,U=null,_t.reset(),bi.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class yc extends En{}yc.prototype.isWebGL1Renderer=!0;class Zs{constructor(e,t=25e-5){this.name="",this.color=new ut(e),this.density=t}clone(){return new Zs(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}Zs.prototype.isFogExp2=!0;class Ys{constructor(e,t=1,n=1e3){this.name="",this.color=new ut(e),this.near=t,this.far=n}clone(){return new Ys(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}Ys.prototype.isFog=!0;class Ia extends E{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}Ia.prototype.isScene=!0;class jr{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ut()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ut()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ut()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}jr.prototype.isInterleavedBuffer=!0;const Un=new H;class Cr{constructor(e,t,n,i=!1){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Un.x=this.getX(t),Un.y=this.getY(t),Un.z=this.getZ(t),Un.applyMatrix4(e),this.setXYZ(t,Un.x,Un.y,Un.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Un.x=this.getX(t),Un.y=this.getY(t),Un.z=this.getZ(t),Un.applyNormalMatrix(e),this.setXYZ(t,Un.x,Un.y,Un.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Un.x=this.getX(t),Un.y=this.getY(t),Un.z=this.getZ(t),Un.transformDirection(e),this.setXYZ(t,Un.x,Un.y,Un.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new $t(new this.array.constructor(t),this.itemSize,this.normalized)}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Cr(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Cr.prototype.isInterleavedBufferAttribute=!0;class Da extends We{constructor(e){super(),this.type="SpriteMaterial",this.color=new ut(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}let _s;Da.prototype.isSpriteMaterial=!0;const Js=new H,Ms=new H,Ss=new H,Ts=new at,Ks=new at,vc=new Dt,Oa=new H,Qs=new H,Fa=new H,xc=new at,Fo=new at,bc=new at;class Na extends E{constructor(e){if(super(),this.type="Sprite",_s===void 0){_s=new Qt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new jr(t,5);_s.setIndex([0,1,2,0,2,3]),_s.setAttribute("position",new Cr(n,3,0,!1)),_s.setAttribute("uv",new Cr(n,2,3,!1))}this.geometry=_s,this.material=e!==void 0?e:new Da,this.center=new at(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ms.setFromMatrixScale(this.matrixWorld),vc.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ss.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Ms.multiplyScalar(-Ss.z);const n=this.material.rotation;let i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));const a=this.center;Ba(Oa.set(-.5,-.5,0),Ss,a,Ms,i,r),Ba(Qs.set(.5,-.5,0),Ss,a,Ms,i,r),Ba(Fa.set(.5,.5,0),Ss,a,Ms,i,r),xc.set(0,0),Fo.set(1,0),bc.set(1,1);let l=e.ray.intersectTriangle(Oa,Qs,Fa,!1,Js);if(l===null&&(Ba(Qs.set(-.5,.5,0),Ss,a,Ms,i,r),Fo.set(0,1),l=e.ray.intersectTriangle(Oa,Fa,Qs,!1,Js),l===null))return;const c=e.ray.origin.distanceTo(Js);c<e.near||c>e.far||t.push({distance:c,point:Js.clone(),uv:Ke.getUV(Js,Oa,Qs,Fa,xc,Fo,bc,new at),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function Ba(s,e,t,n,i,r){Ts.subVectors(s,t).addScalar(.5).multiply(n),i!==void 0?(Ks.x=r*Ts.x-i*Ts.y,Ks.y=i*Ts.x+r*Ts.y):Ks.copy(Ts),s.copy(e),s.x+=Ks.x,s.y+=Ks.y,s.applyMatrix4(vc)}Na.prototype.isSprite=!0;const za=new H,wc=new H;class _c extends E{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const r=t[n];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0){t=Math.abs(t);const n=this.levels;let i;for(i=0;i<n.length&&!(t<n[i].distance);i++);return n.splice(i,0,{distance:t,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i&&!(e<t[n].distance);n++);return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){za.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(za);this.getObjectForDistance(n).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){za.setFromMatrixPosition(e.matrixWorld),wc.setFromMatrixPosition(this.matrixWorld);const n=za.distanceTo(wc)/e.zoom;let i,r;for(t[0].object.visible=!0,i=1,r=t.length;i<r&&n>=t[i].distance;i++)t[i-1].object.visible=!1,t[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,r=n.length;i<r;i++){const a=n[i];t.object.levels.push({object:a.object.uuid,distance:a.distance})}return t}}const Mc=new H,Sc=new en,Tc=new en,op=new H,Ec=new Dt;class ka extends Vn{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Dt,this.bindMatrixInverse=new Dt}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new en,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,i=this.geometry;Sc.fromBufferAttribute(i.attributes.skinIndex,e),Tc.fromBufferAttribute(i.attributes.skinWeight,e),Mc.fromBufferAttribute(i.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const a=Tc.getComponent(r);if(a!==0){const l=Sc.getComponent(r);Ec.multiplyMatrices(n.bones[l].matrixWorld,n.boneInverses[l]),t.addScaledVector(op.copy(Mc).applyMatrix4(Ec),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}ka.prototype.isSkinnedMesh=!0;class Ua extends E{constructor(){super(),this.type="Bone"}}Ua.prototype.isBone=!0;class qr extends wn{constructor(e=null,t=1,n=1,i,r,a,l,c,h=1003,d=1003,p,f){super(null,a,l,c,h,d,i,r,p,f),this.image={data:e,width:t,height:n},this.magFilter=h,this.minFilter=d,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}qr.prototype.isDataTexture=!0;const Ac=new Dt,lp=new Dt;class Ha{constructor(e=[],t=[]){this.uuid=Ut(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Dt)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Dt;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,a=e.length;r<a;r++){const l=e[r]?e[r].matrixWorld:lp;Ac.multiplyMatrices(l,t[r]),Ac.toArray(n,16*r)}i!==null&&(i.needsUpdate=!0)}clone(){return new Ha(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=bn(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new qr(t,e,e,1023,1015);return this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const r=e.bones[n];let a=t[r];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new Ua),this.bones.push(a),this.boneInverses.push(new Dt().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const a=t[i];e.bones.push(a.uuid);const l=n[i];e.boneInverses.push(l.toArray())}return e}}class Xr extends $t{constructor(e,t,n,i=1){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,n),this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}Xr.prototype.isInstancedBufferAttribute=!0;const Lc=new Dt,Rc=new Dt,Ga=[],$s=new Vn;class No extends Vn{constructor(e,t,n){super(e,t),this.instanceMatrix=new Xr(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}raycast(e,t){const n=this.matrixWorld,i=this.count;if($s.geometry=this.geometry,$s.material=this.material,$s.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,Lc),Rc.multiplyMatrices(n,Lc),$s.matrixWorld=Rc,$s.raycast(e,Ga);for(let a=0,l=Ga.length;a<l;a++){const c=Ga[a];c.instanceId=r,c.object=this,t.push(c)}Ga.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Xr(new Float32Array(3*this.instanceMatrix.count),3)),t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}No.prototype.isInstancedMesh=!0;class Kn extends We{constructor(e){super(),this.type="LineBasicMaterial",this.color=new ut(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this}}Kn.prototype.isLineBasicMaterial=!0;const Cc=new H,Pc=new H,Ic=new Dt,Bo=new Ti,Va=new Si;class gr extends E{constructor(e=new Qt,t=new Kn){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,r=t.count;i<r;i++)Cc.fromBufferAttribute(t,i-1),Pc.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=Cc.distanceTo(Pc);e.setAttribute("lineDistance",new Ot(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Va.copy(n.boundingSphere),Va.applyMatrix4(i),Va.radius+=r,e.ray.intersectsSphere(Va)===!1)return;Ic.copy(i).invert(),Bo.copy(e.ray).applyMatrix4(Ic);const l=r/((this.scale.x+this.scale.y+this.scale.z)/3),c=l*l,h=new H,d=new H,p=new H,f=new H,m=this.isLineSegments?2:1;if(n.isBufferGeometry){const y=n.index,b=n.attributes.position;if(y!==null)for(let T=Math.max(0,a.start),_=Math.min(y.count,a.start+a.count)-1;T<_;T+=m){const F=y.getX(T),U=y.getX(T+1);if(h.fromBufferAttribute(b,F),d.fromBufferAttribute(b,U),Bo.distanceSqToSegment(h,d,f,p)>c)continue;f.applyMatrix4(this.matrixWorld);const k=e.ray.origin.distanceTo(f);k<e.near||k>e.far||t.push({distance:k,point:p.clone().applyMatrix4(this.matrixWorld),index:T,face:null,faceIndex:null,object:this})}else for(let T=Math.max(0,a.start),_=Math.min(b.count,a.start+a.count)-1;T<_;T+=m){if(h.fromBufferAttribute(b,T),d.fromBufferAttribute(b,T+1),Bo.distanceSqToSegment(h,d,f,p)>c)continue;f.applyMatrix4(this.matrixWorld);const F=e.ray.origin.distanceTo(f);F<e.near||F>e.far||t.push({distance:F,point:p.clone().applyMatrix4(this.matrixWorld),index:T,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const l=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}gr.prototype.isLine=!0;const Dc=new H,Oc=new H;class xi extends gr{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,r=t.count;i<r;i+=2)Dc.fromBufferAttribute(t,i),Oc.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+Dc.distanceTo(Oc);e.setAttribute("lineDistance",new Ot(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}xi.prototype.isLineSegments=!0;class zo extends gr{constructor(e,t){super(e,t),this.type="LineLoop"}}zo.prototype.isLineLoop=!0;class Zr extends We{constructor(e){super(),this.type="PointsMaterial",this.color=new ut(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this}}Zr.prototype.isPointsMaterial=!0;const Fc=new Dt,ko=new Ti,Wa=new Si,ja=new H;class ea extends E{constructor(e=new Qt,t=new Zr){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Wa.copy(n.boundingSphere),Wa.applyMatrix4(i),Wa.radius+=r,e.ray.intersectsSphere(Wa)===!1)return;Fc.copy(i).invert(),ko.copy(e.ray).applyMatrix4(Fc);const l=r/((this.scale.x+this.scale.y+this.scale.z)/3),c=l*l;if(n.isBufferGeometry){const h=n.index,d=n.attributes.position;if(h!==null)for(let p=Math.max(0,a.start),f=Math.min(h.count,a.start+a.count);p<f;p++){const m=h.getX(p);ja.fromBufferAttribute(d,m),Nc(ja,m,c,i,e,t,this)}else for(let p=Math.max(0,a.start),f=Math.min(d.count,a.start+a.count);p<f;p++)ja.fromBufferAttribute(d,p),Nc(ja,p,c,i,e,t,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const l=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function Nc(s,e,t,n,i,r,a){const l=ko.distanceSqToPoint(s);if(l<t){const c=new H;ko.closestPointToPoint(s,c),c.applyMatrix4(n);const h=i.ray.origin.distanceTo(c);if(h<i.near||h>i.far)return;r.push({distance:h,distanceToRay:Math.sqrt(l),point:c,index:e,face:null,object:a})}}ea.prototype.isPoints=!0;class Bc extends wn{constructor(e,t,n,i,r,a,l,c,h){super(e,t,n,i,r,a,l,c,h),this.format=l!==void 0?l:1022,this.minFilter=a!==void 0?a:1006,this.magFilter=r!==void 0?r:1006,this.generateMipmaps=!1;const d=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(function p(){d.needsUpdate=!0,e.requestVideoFrameCallback(p)})}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;!("requestVideoFrameCallback"in e)&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Bc.prototype.isVideoTexture=!0;class Uo extends wn{constructor(e,t,n,i,r,a,l,c,h,d,p,f){super(null,a,l,c,h,d,i,r,p,f),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}Uo.prototype.isCompressedTexture=!0;class zc extends wn{constructor(e,t,n,i,r,a,l,c,h){super(e,t,n,i,r,a,l,c,h),this.needsUpdate=!0}}zc.prototype.isCanvasTexture=!0;class kc extends wn{constructor(e,t,n,i,r,a,l,c,h,d){if((d=d!==void 0?d:1026)!==1026&&d!==1027)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&d===1026&&(n=1012),n===void 0&&d===1027&&(n=1020),super(null,i,r,a,l,c,d,n,h),this.image={width:e,height:t},this.magFilter=l!==void 0?l:1003,this.minFilter=c!==void 0?c:1003,this.flipY=!1,this.generateMipmaps=!1}}kc.prototype.isDepthTexture=!0;class Es extends Qt{constructor(e=1,t=8,n=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);const r=[],a=[],l=[],c=[],h=new H,d=new at;a.push(0,0,0),l.push(0,0,1),c.push(.5,.5);for(let p=0,f=3;p<=t;p++,f+=3){const m=n+p/t*i;h.x=e*Math.cos(m),h.y=e*Math.sin(m),a.push(h.x,h.y,h.z),l.push(0,0,1),d.x=(a[f]/e+1)/2,d.y=(a[f+1]/e+1)/2,c.push(d.x,d.y)}for(let p=1;p<=t;p++)r.push(p,p+1,0);this.setIndex(r),this.setAttribute("position",new Ot(a,3)),this.setAttribute("normal",new Ot(l,3)),this.setAttribute("uv",new Ot(c,2))}static fromJSON(e){return new Es(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Pr extends Qt{constructor(e=1,t=1,n=1,i=8,r=1,a=!1,l=0,c=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:r,openEnded:a,thetaStart:l,thetaLength:c};const h=this;i=Math.floor(i),r=Math.floor(r);const d=[],p=[],f=[],m=[];let y=0;const b=[],T=n/2;let _=0;function F(U){const k=y,X=new at,K=new H;let ye=0;const we=U===!0?e:t,Fe=U===!0?1:-1;for(let Ce=1;Ce<=i;Ce++)p.push(0,T*Fe,0),f.push(0,Fe,0),m.push(.5,.5),y++;const Te=y;for(let Ce=0;Ce<=i;Ce++){const St=Ce/i*c+l,ht=Math.cos(St),je=Math.sin(St);K.x=we*je,K.y=T*Fe,K.z=we*ht,p.push(K.x,K.y,K.z),f.push(0,Fe,0),X.x=.5*ht+.5,X.y=.5*je*Fe+.5,m.push(X.x,X.y),y++}for(let Ce=0;Ce<i;Ce++){const St=k+Ce,ht=Te+Ce;U===!0?d.push(ht,ht+1,St):d.push(ht+1,ht,St),ye+=3}h.addGroup(_,ye,U===!0?1:2),_+=ye}(function(){const U=new H,k=new H;let X=0;const K=(t-e)/n;for(let ye=0;ye<=r;ye++){const we=[],Fe=ye/r,Te=Fe*(t-e)+e;for(let Ce=0;Ce<=i;Ce++){const St=Ce/i,ht=St*c+l,je=Math.sin(ht),ft=Math.cos(ht);k.x=Te*je,k.y=-Fe*n+T,k.z=Te*ft,p.push(k.x,k.y,k.z),U.set(je,K,ft).normalize(),f.push(U.x,U.y,U.z),m.push(St,1-Fe),we.push(y++)}b.push(we)}for(let ye=0;ye<i;ye++)for(let we=0;we<r;we++){const Fe=b[we][ye],Te=b[we+1][ye],Ce=b[we+1][ye+1],St=b[we][ye+1];d.push(Fe,Te,St),d.push(Te,Ce,St),X+=6}h.addGroup(_,X,0),_+=X})(),a===!1&&(e>0&&F(!0),t>0&&F(!1)),this.setIndex(d),this.setAttribute("position",new Ot(p,3)),this.setAttribute("normal",new Ot(f,3)),this.setAttribute("uv",new Ot(m,2))}static fromJSON(e){return new Pr(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class As extends Pr{constructor(e=1,t=1,n=8,i=1,r=!1,a=0,l=2*Math.PI){super(0,e,t,n,i,r,a,l),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:a,thetaLength:l}}static fromJSON(e){return new As(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class sr extends Qt{constructor(e,t,n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:i};const r=[],a=[];function l(f,m,y,b){const T=b+1,_=[];for(let F=0;F<=T;F++){_[F]=[];const U=f.clone().lerp(y,F/T),k=m.clone().lerp(y,F/T),X=T-F;for(let K=0;K<=X;K++)_[F][K]=K===0&&F===T?U:U.clone().lerp(k,K/X)}for(let F=0;F<T;F++)for(let U=0;U<2*(T-F)-1;U++){const k=Math.floor(U/2);U%2==0?(c(_[F][k+1]),c(_[F+1][k]),c(_[F][k])):(c(_[F][k+1]),c(_[F+1][k+1]),c(_[F+1][k]))}}function c(f){r.push(f.x,f.y,f.z)}function h(f,m){const y=3*f;m.x=e[y+0],m.y=e[y+1],m.z=e[y+2]}function d(f,m,y,b){b<0&&f.x===1&&(a[m]=f.x-1),y.x===0&&y.z===0&&(a[m]=b/2/Math.PI+.5)}function p(f){return Math.atan2(f.z,-f.x)}(function(f){const m=new H,y=new H,b=new H;for(let T=0;T<t.length;T+=3)h(t[T+0],m),h(t[T+1],y),h(t[T+2],b),l(m,y,b,f)})(i),function(f){const m=new H;for(let y=0;y<r.length;y+=3)m.x=r[y+0],m.y=r[y+1],m.z=r[y+2],m.normalize().multiplyScalar(f),r[y+0]=m.x,r[y+1]=m.y,r[y+2]=m.z}(n),function(){const f=new H;for(let y=0;y<r.length;y+=3){f.x=r[y+0],f.y=r[y+1],f.z=r[y+2];const b=p(f)/2/Math.PI+.5,T=(m=f,Math.atan2(-m.y,Math.sqrt(m.x*m.x+m.z*m.z))/Math.PI+.5);a.push(b,1-T)}var m;(function(){const y=new H,b=new H,T=new H,_=new H,F=new at,U=new at,k=new at;for(let X=0,K=0;X<r.length;X+=9,K+=6){y.set(r[X+0],r[X+1],r[X+2]),b.set(r[X+3],r[X+4],r[X+5]),T.set(r[X+6],r[X+7],r[X+8]),F.set(a[K+0],a[K+1]),U.set(a[K+2],a[K+3]),k.set(a[K+4],a[K+5]),_.copy(y).add(b).add(T).divideScalar(3);const ye=p(_);d(F,K+0,y,ye),d(U,K+2,b,ye),d(k,K+4,T,ye)}})(),function(){for(let y=0;y<a.length;y+=6){const b=a[y+0],T=a[y+2],_=a[y+4],F=Math.max(b,T,_),U=Math.min(b,T,_);F>.9&&U<.1&&(b<.2&&(a[y+0]+=1),T<.2&&(a[y+2]+=1),_<.2&&(a[y+4]+=1))}}()}(),this.setAttribute("position",new Ot(r,3)),this.setAttribute("normal",new Ot(r.slice(),3)),this.setAttribute("uv",new Ot(a,2)),i===0?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(e){return new sr(e.vertices,e.indices,e.radius,e.details)}}class Ls extends sr{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Ls(e.radius,e.detail)}}const qa=new H,Xa=new H,Ho=new H,Za=new Ke;class Go extends Qt{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry===!0)return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const n=Math.pow(10,4),i=Math.cos(It*t),r=e.getIndex(),a=e.getAttribute("position"),l=r?r.count:a.count,c=[0,0,0],h=["a","b","c"],d=new Array(3),p={},f=[];for(let m=0;m<l;m+=3){r?(c[0]=r.getX(m),c[1]=r.getX(m+1),c[2]=r.getX(m+2)):(c[0]=m,c[1]=m+1,c[2]=m+2);const{a:y,b,c:T}=Za;if(y.fromBufferAttribute(a,c[0]),b.fromBufferAttribute(a,c[1]),T.fromBufferAttribute(a,c[2]),Za.getNormal(Ho),d[0]=`${Math.round(y.x*n)},${Math.round(y.y*n)},${Math.round(y.z*n)}`,d[1]=`${Math.round(b.x*n)},${Math.round(b.y*n)},${Math.round(b.z*n)}`,d[2]=`${Math.round(T.x*n)},${Math.round(T.y*n)},${Math.round(T.z*n)}`,d[0]!==d[1]&&d[1]!==d[2]&&d[2]!==d[0])for(let _=0;_<3;_++){const F=(_+1)%3,U=d[_],k=d[F],X=Za[h[_]],K=Za[h[F]],ye=`${U}_${k}`,we=`${k}_${U}`;we in p&&p[we]?(Ho.dot(p[we].normal)<=i&&(f.push(X.x,X.y,X.z),f.push(K.x,K.y,K.z)),p[we]=null):ye in p||(p[ye]={index0:c[_],index1:c[F],normal:Ho.clone()})}}for(const m in p)if(p[m]){const{index0:y,index1:b}=p[m];qa.fromBufferAttribute(a,y),Xa.fromBufferAttribute(a,b),f.push(qa.x,qa.y,qa.z),f.push(Xa.x,Xa.y,Xa.z)}this.setAttribute("position",new Ot(f,3))}}class Ri{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),r=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),r+=n.distanceTo(i),t.push(r),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const r=n.length;let a;a=t||e*n[r-1];let l,c=0,h=r-1;for(;c<=h;)if(i=Math.floor(c+(h-c)/2),l=n[i]-a,l<0)c=i+1;else{if(!(l>0)){h=i;break}h=i-1}if(i=h,n[i]===a)return i/(r-1);const d=n[i];return(i+(a-d)/(n[i+1]-d))/(r-1)}getTangent(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const a=this.getPoint(i),l=this.getPoint(r),c=t||(a.isVector2?new at:new H);return c.copy(l).sub(a).normalize(),c}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new H,i=[],r=[],a=[],l=new H,c=new Dt;for(let m=0;m<=e;m++){const y=m/e;i[m]=this.getTangentAt(y,new H),i[m].normalize()}r[0]=new H,a[0]=new H;let h=Number.MAX_VALUE;const d=Math.abs(i[0].x),p=Math.abs(i[0].y),f=Math.abs(i[0].z);d<=h&&(h=d,n.set(1,0,0)),p<=h&&(h=p,n.set(0,1,0)),f<=h&&n.set(0,0,1),l.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],l),a[0].crossVectors(i[0],r[0]);for(let m=1;m<=e;m++){if(r[m]=r[m-1].clone(),a[m]=a[m-1].clone(),l.crossVectors(i[m-1],i[m]),l.length()>Number.EPSILON){l.normalize();const y=Math.acos(Bt(i[m-1].dot(i[m]),-1,1));r[m].applyMatrix4(c.makeRotationAxis(l,y))}a[m].crossVectors(i[m],r[m])}if(t===!0){let m=Math.acos(Bt(r[0].dot(r[e]),-1,1));m/=e,i[0].dot(l.crossVectors(r[0],r[e]))>0&&(m=-m);for(let y=1;y<=e;y++)r[y].applyMatrix4(c.makeRotationAxis(i[y],m*y)),a[y].crossVectors(i[y],r[y])}return{tangents:i,normals:r,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class ta extends Ri{constructor(e=0,t=0,n=1,i=1,r=0,a=2*Math.PI,l=!1,c=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=a,this.aClockwise=l,this.aRotation=c}getPoint(e,t){const n=t||new at,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=a?0:i),this.aClockwise!==!0||a||(r===i?r=-i:r-=i);const l=this.aStartAngle+e*r;let c=this.aX+this.xRadius*Math.cos(l),h=this.aY+this.yRadius*Math.sin(l);if(this.aRotation!==0){const d=Math.cos(this.aRotation),p=Math.sin(this.aRotation),f=c-this.aX,m=h-this.aY;c=f*d-m*p+this.aX,h=f*p+m*d+this.aY}return n.set(c,h)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}ta.prototype.isEllipseCurve=!0;class Vo extends ta{constructor(e,t,n,i,r,a){super(e,t,n,n,i,r,a),this.type="ArcCurve"}}function Wo(){let s=0,e=0,t=0,n=0;function i(r,a,l,c){s=r,e=l,t=-3*r+3*a-2*l-c,n=2*r-2*a+l+c}return{initCatmullRom:function(r,a,l,c,h){i(a,l,h*(l-r),h*(c-a))},initNonuniformCatmullRom:function(r,a,l,c,h,d,p){let f=(a-r)/h-(l-r)/(h+d)+(l-a)/d,m=(l-a)/d-(c-a)/(d+p)+(c-l)/p;f*=d,m*=d,i(a,l,f,m)},calc:function(r){const a=r*r;return s+e*r+t*a+n*(a*r)}}}Vo.prototype.isArcCurve=!0;const Ya=new H,jo=new Wo,qo=new Wo,Xo=new Wo;class Zo extends Ri{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new H){const n=t,i=this.points,r=i.length,a=(r-(this.closed?0:1))*e;let l,c,h=Math.floor(a),d=a-h;this.closed?h+=h>0?0:(Math.floor(Math.abs(h)/r)+1)*r:d===0&&h===r-1&&(h=r-2,d=1),this.closed||h>0?l=i[(h-1)%r]:(Ya.subVectors(i[0],i[1]).add(i[0]),l=Ya);const p=i[h%r],f=i[(h+1)%r];if(this.closed||h+2<r?c=i[(h+2)%r]:(Ya.subVectors(i[r-1],i[r-2]).add(i[r-1]),c=Ya),this.curveType==="centripetal"||this.curveType==="chordal"){const m=this.curveType==="chordal"?.5:.25;let y=Math.pow(l.distanceToSquared(p),m),b=Math.pow(p.distanceToSquared(f),m),T=Math.pow(f.distanceToSquared(c),m);b<1e-4&&(b=1),y<1e-4&&(y=b),T<1e-4&&(T=b),jo.initNonuniformCatmullRom(l.x,p.x,f.x,c.x,y,b,T),qo.initNonuniformCatmullRom(l.y,p.y,f.y,c.y,y,b,T),Xo.initNonuniformCatmullRom(l.z,p.z,f.z,c.z,y,b,T)}else this.curveType==="catmullrom"&&(jo.initCatmullRom(l.x,p.x,f.x,c.x,this.tension),qo.initCatmullRom(l.y,p.y,f.y,c.y,this.tension),Xo.initCatmullRom(l.z,p.z,f.z,c.z,this.tension));return n.set(jo.calc(d),qo.calc(d),Xo.calc(d)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new H().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function Uc(s,e,t,n,i){const r=.5*(n-e),a=.5*(i-t),l=s*s;return(2*t-2*n+r+a)*(s*l)+(-3*t+3*n-2*r-a)*l+r*s+t}function na(s,e,t,n){return function(i,r){const a=1-i;return a*a*r}(s,e)+function(i,r){return 2*(1-i)*i*r}(s,t)+function(i,r){return i*i*r}(s,n)}function ia(s,e,t,n,i){return function(r,a){const l=1-r;return l*l*l*a}(s,e)+function(r,a){const l=1-r;return 3*l*l*r*a}(s,t)+function(r,a){return 3*(1-r)*r*r*a}(s,n)+function(r,a){return r*r*r*a}(s,i)}Zo.prototype.isCatmullRomCurve3=!0;class Ja extends Ri{constructor(e=new at,t=new at,n=new at,i=new at){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new at){const n=t,i=this.v0,r=this.v1,a=this.v2,l=this.v3;return n.set(ia(e,i.x,r.x,a.x,l.x),ia(e,i.y,r.y,a.y,l.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Ja.prototype.isCubicBezierCurve=!0;class Yo extends Ri{constructor(e=new H,t=new H,n=new H,i=new H){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new H){const n=t,i=this.v0,r=this.v1,a=this.v2,l=this.v3;return n.set(ia(e,i.x,r.x,a.x,l.x),ia(e,i.y,r.y,a.y,l.y),ia(e,i.z,r.z,a.z,l.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Yo.prototype.isCubicBezierCurve3=!0;class ra extends Ri{constructor(e=new at,t=new at){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new at){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new at;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}ra.prototype.isLineCurve=!0;class Hc extends Ri{constructor(e=new H,t=new H){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new H){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Ka extends Ri{constructor(e=new at,t=new at,n=new at){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new at){const n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(na(e,i.x,r.x,a.x),na(e,i.y,r.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Ka.prototype.isQuadraticBezierCurve=!0;class Jo extends Ri{constructor(e=new H,t=new H,n=new H){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new H){const n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(na(e,i.x,r.x,a.x),na(e,i.y,r.y,a.y),na(e,i.z,r.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Jo.prototype.isQuadraticBezierCurve3=!0;class Qa extends Ri{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new at){const n=t,i=this.points,r=(i.length-1)*e,a=Math.floor(r),l=r-a,c=i[a===0?a:a-1],h=i[a],d=i[a>i.length-2?i.length-1:a+1],p=i[a>i.length-3?i.length-1:a+2];return n.set(Uc(l,c.x,h.x,d.x,p.x),Uc(l,c.y,h.y,d.y,p.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new at().fromArray(i))}return this}}Qa.prototype.isSplineCurve=!0;var Ko=Object.freeze({__proto__:null,ArcCurve:Vo,CatmullRomCurve3:Zo,CubicBezierCurve:Ja,CubicBezierCurve3:Yo,EllipseCurve:ta,LineCurve:ra,LineCurve3:Hc,QuadraticBezierCurve:Ka,QuadraticBezierCurve3:Jo,SplineCurve:Qa});const cp=function(s,e,t=2){const n=e&&e.length,i=n?e[0]*t:s.length;let r=Gc(s,0,i,t,!0);const a=[];if(!r||r.next===r.prev)return a;let l,c,h,d,p,f,m;if(n&&(r=function(y,b,T,_){const F=[];let U,k,X,K,ye;for(U=0,k=b.length;U<k;U++)X=b[U]*_,K=U<k-1?b[U+1]*_:y.length,ye=Gc(y,X,K,_,!1),ye===ye.next&&(ye.steiner=!0),F.push(yp(ye));for(F.sort(fp),U=0;U<F.length;U++)mp(F[U],T),T=Ir(T,T.next);return T}(s,e,r,t)),s.length>80*t){l=h=s[0],c=d=s[1];for(let y=t;y<i;y+=t)p=s[y],f=s[y+1],p<l&&(l=p),f<c&&(c=f),p>h&&(h=p),f>d&&(d=f);m=Math.max(h-l,d-c),m=m!==0?1/m:0}return sa(r,a,t,l,c,m),a};function Gc(s,e,t,n,i){let r,a;if(i===function(l,c,h,d){let p=0;for(let f=c,m=h-d;f<h;f+=d)p+=(l[m]-l[f])*(l[f+1]+l[m+1]),m=f;return p}(s,e,t,n)>0)for(r=e;r<t;r+=n)a=jc(r,s[r],s[r+1],a);else for(r=t-n;r>=e;r-=n)a=jc(r,s[r],s[r+1],a);return a&&$a(a,a.next)&&(oa(a),a=a.next),a}function Ir(s,e){if(!s)return s;e||(e=s);let t,n=s;do if(t=!1,n.steiner||!$a(n,n.next)&&Fn(n.prev,n,n.next)!==0)n=n.next;else{if(oa(n),n=e=n.prev,n===n.next)break;t=!0}while(t||n!==e);return e}function sa(s,e,t,n,i,r,a){if(!s)return;!a&&r&&function(d,p,f,m){let y=d;do y.z===null&&(y.z=Qo(y.x,y.y,p,f,m)),y.prevZ=y.prev,y.nextZ=y.next,y=y.next;while(y!==d);y.prevZ.nextZ=null,y.prevZ=null,function(b){let T,_,F,U,k,X,K,ye,we=1;do{for(_=b,b=null,k=null,X=0;_;){for(X++,F=_,K=0,T=0;T<we&&(K++,F=F.nextZ,F);T++);for(ye=we;K>0||ye>0&&F;)K!==0&&(ye===0||!F||_.z<=F.z)?(U=_,_=_.nextZ,K--):(U=F,F=F.nextZ,ye--),k?k.nextZ=U:b=U,U.prevZ=k,k=U;_=F}k.nextZ=null,we*=2}while(X>1)}(y)}(s,n,i,r);let l,c,h=s;for(;s.prev!==s.next;)if(l=s.prev,c=s.next,r?hp(s,n,i,r):up(s))e.push(l.i/t),e.push(s.i/t),e.push(c.i/t),oa(s),s=c.next,h=c.next;else if((s=c)===h){a?a===1?sa(s=dp(Ir(s),e,t),e,t,n,i,r,2):a===2&&pp(s,e,t,n,i,r):sa(Ir(s),e,t,n,i,r,1);break}}function up(s){const e=s.prev,t=s,n=s.next;if(Fn(e,t,n)>=0)return!1;let i=s.next.next;for(;i!==s.prev;){if(Rs(e.x,e.y,t.x,t.y,n.x,n.y,i.x,i.y)&&Fn(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function hp(s,e,t,n){const i=s.prev,r=s,a=s.next;if(Fn(i,r,a)>=0)return!1;const l=i.x<r.x?i.x<a.x?i.x:a.x:r.x<a.x?r.x:a.x,c=i.y<r.y?i.y<a.y?i.y:a.y:r.y<a.y?r.y:a.y,h=i.x>r.x?i.x>a.x?i.x:a.x:r.x>a.x?r.x:a.x,d=i.y>r.y?i.y>a.y?i.y:a.y:r.y>a.y?r.y:a.y,p=Qo(l,c,e,t,n),f=Qo(h,d,e,t,n);let m=s.prevZ,y=s.nextZ;for(;m&&m.z>=p&&y&&y.z<=f;){if(m!==s.prev&&m!==s.next&&Rs(i.x,i.y,r.x,r.y,a.x,a.y,m.x,m.y)&&Fn(m.prev,m,m.next)>=0||(m=m.prevZ,y!==s.prev&&y!==s.next&&Rs(i.x,i.y,r.x,r.y,a.x,a.y,y.x,y.y)&&Fn(y.prev,y,y.next)>=0))return!1;y=y.nextZ}for(;m&&m.z>=p;){if(m!==s.prev&&m!==s.next&&Rs(i.x,i.y,r.x,r.y,a.x,a.y,m.x,m.y)&&Fn(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;y&&y.z<=f;){if(y!==s.prev&&y!==s.next&&Rs(i.x,i.y,r.x,r.y,a.x,a.y,y.x,y.y)&&Fn(y.prev,y,y.next)>=0)return!1;y=y.nextZ}return!0}function dp(s,e,t){let n=s;do{const i=n.prev,r=n.next.next;!$a(i,r)&&Vc(i,n,n.next,r)&&aa(i,r)&&aa(r,i)&&(e.push(i.i/t),e.push(n.i/t),e.push(r.i/t),oa(n),oa(n.next),n=s=r),n=n.next}while(n!==s);return Ir(n)}function pp(s,e,t,n,i,r){let a=s;do{let l=a.next.next;for(;l!==a.prev;){if(a.i!==l.i&&vp(a,l)){let c=Wc(a,l);return a=Ir(a,a.next),c=Ir(c,c.next),sa(a,e,t,n,i,r),void sa(c,e,t,n,i,r)}l=l.next}a=a.next}while(a!==s)}function fp(s,e){return s.x-e.x}function mp(s,e){if(e=function(t,n){let i=n;const r=t.x,a=t.y;let l,c=-1/0;do{if(a<=i.y&&a>=i.next.y&&i.next.y!==i.y){const y=i.x+(a-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(y<=r&&y>c){if(c=y,y===r){if(a===i.y)return i;if(a===i.next.y)return i.next}l=i.x<i.next.x?i:i.next}}i=i.next}while(i!==n);if(!l)return null;if(r===c)return l;const h=l,d=l.x,p=l.y;let f,m=1/0;i=l;do r>=i.x&&i.x>=d&&r!==i.x&&Rs(a<p?r:c,a,d,p,a<p?c:r,a,i.x,i.y)&&(f=Math.abs(a-i.y)/(r-i.x),aa(i,t)&&(f<m||f===m&&(i.x>l.x||i.x===l.x&&gp(l,i)))&&(l=i,m=f)),i=i.next;while(i!==h);return l}(s,e)){const t=Wc(e,s);Ir(e,e.next),Ir(t,t.next)}}function gp(s,e){return Fn(s.prev,s,e.prev)<0&&Fn(e.next,s,s.next)<0}function Qo(s,e,t,n,i){return(s=1431655765&((s=858993459&((s=252645135&((s=16711935&((s=32767*(s-t)*i)|s<<8))|s<<4))|s<<2))|s<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function yp(s){let e=s,t=s;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==s);return t}function Rs(s,e,t,n,i,r,a,l){return(i-a)*(e-l)-(s-a)*(r-l)>=0&&(s-a)*(n-l)-(t-a)*(e-l)>=0&&(t-a)*(r-l)-(i-a)*(n-l)>=0}function vp(s,e){return s.next.i!==e.i&&s.prev.i!==e.i&&!function(t,n){let i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==n.i&&i.next.i!==n.i&&Vc(i,i.next,t,n))return!0;i=i.next}while(i!==t);return!1}(s,e)&&(aa(s,e)&&aa(e,s)&&function(t,n){let i=t,r=!1;const a=(t.x+n.x)/2,l=(t.y+n.y)/2;do i.y>l!=i.next.y>l&&i.next.y!==i.y&&a<(i.next.x-i.x)*(l-i.y)/(i.next.y-i.y)+i.x&&(r=!r),i=i.next;while(i!==t);return r}(s,e)&&(Fn(s.prev,s,e.prev)||Fn(s,e.prev,e))||$a(s,e)&&Fn(s.prev,s,s.next)>0&&Fn(e.prev,e,e.next)>0)}function Fn(s,e,t){return(e.y-s.y)*(t.x-e.x)-(e.x-s.x)*(t.y-e.y)}function $a(s,e){return s.x===e.x&&s.y===e.y}function Vc(s,e,t,n){const i=to(Fn(s,e,t)),r=to(Fn(s,e,n)),a=to(Fn(t,n,s)),l=to(Fn(t,n,e));return i!==r&&a!==l||!(i!==0||!eo(s,t,e))||!(r!==0||!eo(s,n,e))||!(a!==0||!eo(t,s,n))||!(l!==0||!eo(t,e,n))}function eo(s,e,t){return e.x<=Math.max(s.x,t.x)&&e.x>=Math.min(s.x,t.x)&&e.y<=Math.max(s.y,t.y)&&e.y>=Math.min(s.y,t.y)}function to(s){return s>0?1:s<0?-1:0}function aa(s,e){return Fn(s.prev,s,s.next)<0?Fn(s,e,s.next)>=0&&Fn(s,s.prev,e)>=0:Fn(s,e,s.prev)<0||Fn(s,s.next,e)<0}function Wc(s,e){const t=new $o(s.i,s.x,s.y),n=new $o(e.i,e.x,e.y),i=s.next,r=e.prev;return s.next=e,e.prev=s,t.next=i,i.prev=t,n.next=t,t.prev=n,r.next=n,n.prev=r,n}function jc(s,e,t,n){const i=new $o(s,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function oa(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function $o(s,e,t){this.i=s,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class ar{static area(e){const t=e.length;let n=0;for(let i=t-1,r=0;r<t;i=r++)n+=e[i].x*e[r].y-e[r].x*e[i].y;return .5*n}static isClockWise(e){return ar.area(e)<0}static triangulateShape(e,t){const n=[],i=[],r=[];qc(e),Xc(n,e);let a=e.length;t.forEach(qc);for(let c=0;c<t.length;c++)i.push(a),a+=t[c].length,Xc(n,t[c]);const l=cp(n,i);for(let c=0;c<l.length;c+=3)r.push(l.slice(c,c+3));return r}}function qc(s){const e=s.length;e>2&&s[e-1].equals(s[0])&&s.pop()}function Xc(s,e){for(let t=0;t<e.length;t++)s.push(e[t].x),s.push(e[t].y)}class Vi extends Qt{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],r=[];for(let l=0,c=e.length;l<c;l++)a(e[l]);function a(l){const c=[],h=t.curveSegments!==void 0?t.curveSegments:12,d=t.steps!==void 0?t.steps:1;let p=t.depth!==void 0?t.depth:100,f=t.bevelEnabled===void 0||t.bevelEnabled,m=t.bevelThickness!==void 0?t.bevelThickness:6,y=t.bevelSize!==void 0?t.bevelSize:m-2,b=t.bevelOffset!==void 0?t.bevelOffset:0,T=t.bevelSegments!==void 0?t.bevelSegments:3;const _=t.extrudePath,F=t.UVGenerator!==void 0?t.UVGenerator:xp;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),p=t.amount);let U,k,X,K,ye,we=!1;_&&(U=_.getSpacedPoints(d),we=!0,f=!1,k=_.computeFrenetFrames(d,!1),X=new H,K=new H,ye=new H),f||(T=0,m=0,y=0,b=0);const Fe=l.extractPoints(h);let Te=Fe.shape;const Ce=Fe.holes;if(!ar.isClockWise(Te)){Te=Te.reverse();for(let Ne=0,j=Ce.length;Ne<j;Ne++){const Ee=Ce[Ne];ar.isClockWise(Ee)&&(Ce[Ne]=Ee.reverse())}}const St=ar.triangulateShape(Te,Ce),ht=Te;for(let Ne=0,j=Ce.length;Ne<j;Ne++){const Ee=Ce[Ne];Te=Te.concat(Ee)}function je(Ne,j,Ee){return j||console.error("THREE.ExtrudeGeometry: vec does not exist"),j.clone().multiplyScalar(Ee).add(Ne)}const ft=Te.length,Lt=St.length;function Pt(Ne,j,Ee){let $e,rt,Qe;const Ft=Ne.x-j.x,Wt=Ne.y-j.y,kt=Ee.x-Ne.x,ln=Ee.y-Ne.y,nn=Ft*Ft+Wt*Wt,Qn=Ft*ln-Wt*kt;if(Math.abs(Qn)>Number.EPSILON){const Sn=Math.sqrt(nn),$n=Math.sqrt(kt*kt+ln*ln),Ci=j.x-Wt/Sn,ss=j.y+Ft/Sn,as=((Ee.x-ln/$n-Ci)*ln-(Ee.y+kt/$n-ss)*kt)/(Ft*ln-Wt*kt);$e=Ci+Ft*as-Ne.x,rt=ss+Wt*as-Ne.y;const os=$e*$e+rt*rt;if(os<=2)return new at($e,rt);Qe=Math.sqrt(os/2)}else{let Sn=!1;Ft>Number.EPSILON?kt>Number.EPSILON&&(Sn=!0):Ft<-Number.EPSILON?kt<-Number.EPSILON&&(Sn=!0):Math.sign(Wt)===Math.sign(ln)&&(Sn=!0),Sn?($e=-Wt,rt=Ft,Qe=Math.sqrt(nn)):($e=Ft,rt=Wt,Qe=Math.sqrt(nn/2))}return new at($e/Qe,rt/Qe)}const Ht=[];for(let Ne=0,j=ht.length,Ee=j-1,$e=Ne+1;Ne<j;Ne++,Ee++,$e++)Ee===j&&(Ee=0),$e===j&&($e=0),Ht[Ne]=Pt(ht[Ne],ht[Ee],ht[$e]);const Xt=[];let Zt,pt=Ht.concat();for(let Ne=0,j=Ce.length;Ne<j;Ne++){const Ee=Ce[Ne];Zt=[];for(let $e=0,rt=Ee.length,Qe=rt-1,Ft=$e+1;$e<rt;$e++,Qe++,Ft++)Qe===rt&&(Qe=0),Ft===rt&&(Ft=0),Zt[$e]=Pt(Ee[$e],Ee[Qe],Ee[Ft]);Xt.push(Zt),pt=pt.concat(Zt)}for(let Ne=0;Ne<T;Ne++){const j=Ne/T,Ee=m*Math.cos(j*Math.PI/2),$e=y*Math.sin(j*Math.PI/2)+b;for(let rt=0,Qe=ht.length;rt<Qe;rt++){const Ft=je(ht[rt],Ht[rt],$e);Je(Ft.x,Ft.y,-Ee)}for(let rt=0,Qe=Ce.length;rt<Qe;rt++){const Ft=Ce[rt];Zt=Xt[rt];for(let Wt=0,kt=Ft.length;Wt<kt;Wt++){const ln=je(Ft[Wt],Zt[Wt],$e);Je(ln.x,ln.y,-Ee)}}}const J=y+b;for(let Ne=0;Ne<ft;Ne++){const j=f?je(Te[Ne],pt[Ne],J):Te[Ne];we?(K.copy(k.normals[0]).multiplyScalar(j.x),X.copy(k.binormals[0]).multiplyScalar(j.y),ye.copy(U[0]).add(K).add(X),Je(ye.x,ye.y,ye.z)):Je(j.x,j.y,0)}for(let Ne=1;Ne<=d;Ne++)for(let j=0;j<ft;j++){const Ee=f?je(Te[j],pt[j],J):Te[j];we?(K.copy(k.normals[Ne]).multiplyScalar(Ee.x),X.copy(k.binormals[Ne]).multiplyScalar(Ee.y),ye.copy(U[Ne]).add(K).add(X),Je(ye.x,ye.y,ye.z)):Je(Ee.x,Ee.y,p/d*Ne)}for(let Ne=T-1;Ne>=0;Ne--){const j=Ne/T,Ee=m*Math.cos(j*Math.PI/2),$e=y*Math.sin(j*Math.PI/2)+b;for(let rt=0,Qe=ht.length;rt<Qe;rt++){const Ft=je(ht[rt],Ht[rt],$e);Je(Ft.x,Ft.y,p+Ee)}for(let rt=0,Qe=Ce.length;rt<Qe;rt++){const Ft=Ce[rt];Zt=Xt[rt];for(let Wt=0,kt=Ft.length;Wt<kt;Wt++){const ln=je(Ft[Wt],Zt[Wt],$e);we?Je(ln.x,ln.y+U[d-1].y,U[d-1].x+Ee):Je(ln.x,ln.y,p+Ee)}}}function ce(Ne,j){let Ee=Ne.length;for(;--Ee>=0;){const $e=Ee;let rt=Ee-1;rt<0&&(rt=Ne.length-1);for(let Qe=0,Ft=d+2*T;Qe<Ft;Qe++){const Wt=ft*Qe,kt=ft*(Qe+1);Pe(j+$e+Wt,j+rt+Wt,j+rt+kt,j+$e+kt)}}}function Je(Ne,j,Ee){c.push(Ne),c.push(j),c.push(Ee)}function Ue(Ne,j,Ee){Mt(Ne),Mt(j),Mt(Ee);const $e=i.length/3,rt=F.generateTopUV(n,i,$e-3,$e-2,$e-1);_t(rt[0]),_t(rt[1]),_t(rt[2])}function Pe(Ne,j,Ee,$e){Mt(Ne),Mt(j),Mt($e),Mt(j),Mt(Ee),Mt($e);const rt=i.length/3,Qe=F.generateSideWallUV(n,i,rt-6,rt-3,rt-2,rt-1);_t(Qe[0]),_t(Qe[1]),_t(Qe[3]),_t(Qe[1]),_t(Qe[2]),_t(Qe[3])}function Mt(Ne){i.push(c[3*Ne+0]),i.push(c[3*Ne+1]),i.push(c[3*Ne+2])}function _t(Ne){r.push(Ne.x),r.push(Ne.y)}(function(){const Ne=i.length/3;if(f){let j=0,Ee=ft*j;for(let $e=0;$e<Lt;$e++){const rt=St[$e];Ue(rt[2]+Ee,rt[1]+Ee,rt[0]+Ee)}j=d+2*T,Ee=ft*j;for(let $e=0;$e<Lt;$e++){const rt=St[$e];Ue(rt[0]+Ee,rt[1]+Ee,rt[2]+Ee)}}else{for(let j=0;j<Lt;j++){const Ee=St[j];Ue(Ee[2],Ee[1],Ee[0])}for(let j=0;j<Lt;j++){const Ee=St[j];Ue(Ee[0]+ft*d,Ee[1]+ft*d,Ee[2]+ft*d)}}n.addGroup(Ne,i.length/3-Ne,0)})(),function(){const Ne=i.length/3;let j=0;ce(ht,j),j+=ht.length;for(let Ee=0,$e=Ce.length;Ee<$e;Ee++){const rt=Ce[Ee];ce(rt,j),j+=rt.length}n.addGroup(Ne,i.length/3-Ne,1)}()}this.setAttribute("position",new Ot(i,3)),this.setAttribute("uv",new Ot(r,2)),this.computeVertexNormals()}toJSON(){const e=super.toJSON();return function(t,n,i){if(i.shapes=[],Array.isArray(t))for(let r=0,a=t.length;r<a;r++){const l=t[r];i.shapes.push(l.uuid)}else i.shapes.push(t.uuid);return n.extrudePath!==void 0&&(i.options.extrudePath=n.extrudePath.toJSON()),i}(this.parameters.shapes,this.parameters.options,e)}static fromJSON(e,t){const n=[];for(let r=0,a=e.shapes.length;r<a;r++){const l=t[e.shapes[r]];n.push(l)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new Ko[i.type]().fromJSON(i)),new Vi(n,e.options)}}const xp={generateTopUV:function(s,e,t,n,i){const r=e[3*t],a=e[3*t+1],l=e[3*n],c=e[3*n+1],h=e[3*i],d=e[3*i+1];return[new at(r,a),new at(l,c),new at(h,d)]},generateSideWallUV:function(s,e,t,n,i,r){const a=e[3*t],l=e[3*t+1],c=e[3*t+2],h=e[3*n],d=e[3*n+1],p=e[3*n+2],f=e[3*i],m=e[3*i+1],y=e[3*i+2],b=e[3*r],T=e[3*r+1],_=e[3*r+2];return Math.abs(l-d)<Math.abs(a-h)?[new at(a,1-c),new at(h,1-p),new at(f,1-y),new at(b,1-_)]:[new at(l,1-c),new at(d,1-p),new at(m,1-y),new at(T,1-_)]}};class Cs extends sr{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Cs(e.radius,e.detail)}}class Ps extends Qt{constructor(e,t=12,n=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:i},t=Math.floor(t),i=Bt(i,0,2*Math.PI);const r=[],a=[],l=[],c=1/t,h=new H,d=new at;for(let p=0;p<=t;p++){const f=n+p*c*i,m=Math.sin(f),y=Math.cos(f);for(let b=0;b<=e.length-1;b++)h.x=e[b].x*m,h.y=e[b].y,h.z=e[b].x*y,a.push(h.x,h.y,h.z),d.x=p/t,d.y=b/(e.length-1),l.push(d.x,d.y)}for(let p=0;p<t;p++)for(let f=0;f<e.length-1;f++){const m=f+p*e.length,y=m,b=m+e.length,T=m+e.length+1,_=m+1;r.push(y,b,_),r.push(b,T,_)}if(this.setIndex(r),this.setAttribute("position",new Ot(a,3)),this.setAttribute("uv",new Ot(l,2)),this.computeVertexNormals(),i===2*Math.PI){const p=this.attributes.normal.array,f=new H,m=new H,y=new H,b=t*e.length*3;for(let T=0,_=0;T<e.length;T++,_+=3)f.x=p[_+0],f.y=p[_+1],f.z=p[_+2],m.x=p[b+_+0],m.y=p[b+_+1],m.z=p[b+_+2],y.addVectors(f,m).normalize(),p[_+0]=p[b+_+0]=y.x,p[_+1]=p[b+_+1]=y.y,p[_+2]=p[b+_+2]=y.z}}static fromJSON(e){return new Ps(e.points,e.segments,e.phiStart,e.phiLength)}}class Yr extends sr{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Yr(e.radius,e.detail)}}class no extends Qt{constructor(e,t,n){super(),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n};const i=[],r=[],a=[],l=[],c=1e-5,h=new H,d=new H,p=new H,f=new H,m=new H;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const y=t+1;for(let b=0;b<=n;b++){const T=b/n;for(let _=0;_<=t;_++){const F=_/t;e(F,T,d),r.push(d.x,d.y,d.z),F-c>=0?(e(F-c,T,p),f.subVectors(d,p)):(e(F+c,T,p),f.subVectors(p,d)),T-c>=0?(e(F,T-c,p),m.subVectors(d,p)):(e(F,T+c,p),m.subVectors(p,d)),h.crossVectors(f,m).normalize(),a.push(h.x,h.y,h.z),l.push(F,T)}}for(let b=0;b<n;b++)for(let T=0;T<t;T++){const _=b*y+T,F=b*y+T+1,U=(b+1)*y+T+1,k=(b+1)*y+T;i.push(_,F,k),i.push(F,U,k)}this.setIndex(i),this.setAttribute("position",new Ot(r,3)),this.setAttribute("normal",new Ot(a,3)),this.setAttribute("uv",new Ot(l,2))}}class Is extends Qt{constructor(e=.5,t=1,n=8,i=1,r=0,a=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:a},n=Math.max(3,n);const l=[],c=[],h=[],d=[];let p=e;const f=(t-e)/(i=Math.max(1,i)),m=new H,y=new at;for(let b=0;b<=i;b++){for(let T=0;T<=n;T++){const _=r+T/n*a;m.x=p*Math.cos(_),m.y=p*Math.sin(_),c.push(m.x,m.y,m.z),h.push(0,0,1),y.x=(m.x/t+1)/2,y.y=(m.y/t+1)/2,d.push(y.x,y.y)}p+=f}for(let b=0;b<i;b++){const T=b*(n+1);for(let _=0;_<n;_++){const F=_+T,U=F,k=F+n+1,X=F+n+2,K=F+1;l.push(U,k,K),l.push(k,X,K)}}this.setIndex(l),this.setAttribute("position",new Ot(c,3)),this.setAttribute("normal",new Ot(h,3)),this.setAttribute("uv",new Ot(d,2))}static fromJSON(e){return new Is(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class Jr extends Qt{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],r=[],a=[];let l=0,c=0;if(Array.isArray(e)===!1)h(e);else for(let d=0;d<e.length;d++)h(e[d]),this.addGroup(l,c,d),l+=c,c=0;function h(d){const p=i.length/3,f=d.extractPoints(t);let m=f.shape;const y=f.holes;ar.isClockWise(m)===!1&&(m=m.reverse());for(let T=0,_=y.length;T<_;T++){const F=y[T];ar.isClockWise(F)===!0&&(y[T]=F.reverse())}const b=ar.triangulateShape(m,y);for(let T=0,_=y.length;T<_;T++){const F=y[T];m=m.concat(F)}for(let T=0,_=m.length;T<_;T++){const F=m[T];i.push(F.x,F.y,0),r.push(0,0,1),a.push(F.x,F.y)}for(let T=0,_=b.length;T<_;T++){const F=b[T],U=F[0]+p,k=F[1]+p,X=F[2]+p;n.push(U,k,X),c+=3}}this.setIndex(n),this.setAttribute("position",new Ot(i,3)),this.setAttribute("normal",new Ot(r,3)),this.setAttribute("uv",new Ot(a,2))}toJSON(){const e=super.toJSON();return function(t,n){if(n.shapes=[],Array.isArray(t))for(let i=0,r=t.length;i<r;i++){const a=t[i];n.shapes.push(a.uuid)}else n.shapes.push(t.uuid);return n}(this.parameters.shapes,e)}static fromJSON(e,t){const n=[];for(let i=0,r=e.shapes.length;i<r;i++){const a=t[e.shapes[i]];n.push(a)}return new Jr(n,e.curveSegments)}}class Kr extends Qt{constructor(e=1,t=32,n=16,i=0,r=2*Math.PI,a=0,l=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:r,thetaStart:a,thetaLength:l},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const c=Math.min(a+l,Math.PI);let h=0;const d=[],p=new H,f=new H,m=[],y=[],b=[],T=[];for(let _=0;_<=n;_++){const F=[],U=_/n;let k=0;_==0&&a==0?k=.5/t:_==n&&c==Math.PI&&(k=-.5/t);for(let X=0;X<=t;X++){const K=X/t;p.x=-e*Math.cos(i+K*r)*Math.sin(a+U*l),p.y=e*Math.cos(a+U*l),p.z=e*Math.sin(i+K*r)*Math.sin(a+U*l),y.push(p.x,p.y,p.z),f.copy(p).normalize(),b.push(f.x,f.y,f.z),T.push(K+k,1-U),F.push(h++)}d.push(F)}for(let _=0;_<n;_++)for(let F=0;F<t;F++){const U=d[_][F+1],k=d[_][F],X=d[_+1][F],K=d[_+1][F+1];(_!==0||a>0)&&m.push(U,k,K),(_!==n-1||c<Math.PI)&&m.push(k,X,K)}this.setIndex(m),this.setAttribute("position",new Ot(y,3)),this.setAttribute("normal",new Ot(b,3)),this.setAttribute("uv",new Ot(T,2))}static fromJSON(e){return new Kr(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class Ds extends sr{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Ds(e.radius,e.detail)}}class io extends Vi{constructor(e,t={}){const n=t.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Qt;const i=n.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(i,t),this.type="TextGeometry"}}class Os extends Qt{constructor(e=1,t=.4,n=8,i=6,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const a=[],l=[],c=[],h=[],d=new H,p=new H,f=new H;for(let m=0;m<=n;m++)for(let y=0;y<=i;y++){const b=y/i*r,T=m/n*Math.PI*2;p.x=(e+t*Math.cos(T))*Math.cos(b),p.y=(e+t*Math.cos(T))*Math.sin(b),p.z=t*Math.sin(T),l.push(p.x,p.y,p.z),d.x=e*Math.cos(b),d.y=e*Math.sin(b),f.subVectors(p,d).normalize(),c.push(f.x,f.y,f.z),h.push(y/i),h.push(m/n)}for(let m=1;m<=n;m++)for(let y=1;y<=i;y++){const b=(i+1)*m+y-1,T=(i+1)*(m-1)+y-1,_=(i+1)*(m-1)+y,F=(i+1)*m+y;a.push(b,T,F),a.push(T,_,F)}this.setIndex(a),this.setAttribute("position",new Ot(l,3)),this.setAttribute("normal",new Ot(c,3)),this.setAttribute("uv",new Ot(h,2))}static fromJSON(e){return new Os(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class Fs extends Qt{constructor(e=1,t=.4,n=64,i=8,r=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:i,p:r,q:a},n=Math.floor(n),i=Math.floor(i);const l=[],c=[],h=[],d=[],p=new H,f=new H,m=new H,y=new H,b=new H,T=new H,_=new H;for(let U=0;U<=n;++U){const k=U/n*r*Math.PI*2;F(k,r,a,e,m),F(k+.01,r,a,e,y),T.subVectors(y,m),_.addVectors(y,m),b.crossVectors(T,_),_.crossVectors(b,T),b.normalize(),_.normalize();for(let X=0;X<=i;++X){const K=X/i*Math.PI*2,ye=-t*Math.cos(K),we=t*Math.sin(K);p.x=m.x+(ye*_.x+we*b.x),p.y=m.y+(ye*_.y+we*b.y),p.z=m.z+(ye*_.z+we*b.z),c.push(p.x,p.y,p.z),f.subVectors(p,m).normalize(),h.push(f.x,f.y,f.z),d.push(U/n),d.push(X/i)}}for(let U=1;U<=n;U++)for(let k=1;k<=i;k++){const X=(i+1)*(U-1)+(k-1),K=(i+1)*U+(k-1),ye=(i+1)*U+k,we=(i+1)*(U-1)+k;l.push(X,K,we),l.push(K,ye,we)}function F(U,k,X,K,ye){const we=Math.cos(U),Fe=Math.sin(U),Te=X/k*U,Ce=Math.cos(Te);ye.x=K*(2+Ce)*.5*we,ye.y=K*(2+Ce)*Fe*.5,ye.z=K*Math.sin(Te)*.5}this.setIndex(l),this.setAttribute("position",new Ot(c,3)),this.setAttribute("normal",new Ot(h,3)),this.setAttribute("uv",new Ot(d,2))}static fromJSON(e){return new Fs(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class Ns extends Qt{constructor(e,t=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:i,closed:r};const a=e.computeFrenetFrames(t,r);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const l=new H,c=new H,h=new at;let d=new H;const p=[],f=[],m=[],y=[];function b(T){d=e.getPointAt(T/t,d);const _=a.normals[T],F=a.binormals[T];for(let U=0;U<=i;U++){const k=U/i*Math.PI*2,X=Math.sin(k),K=-Math.cos(k);c.x=K*_.x+X*F.x,c.y=K*_.y+X*F.y,c.z=K*_.z+X*F.z,c.normalize(),f.push(c.x,c.y,c.z),l.x=d.x+n*c.x,l.y=d.y+n*c.y,l.z=d.z+n*c.z,p.push(l.x,l.y,l.z)}}(function(){for(let T=0;T<t;T++)b(T);b(r===!1?t:0),function(){for(let T=0;T<=t;T++)for(let _=0;_<=i;_++)h.x=T/t,h.y=_/i,m.push(h.x,h.y)}(),function(){for(let T=1;T<=t;T++)for(let _=1;_<=i;_++){const F=(i+1)*(T-1)+(_-1),U=(i+1)*T+(_-1),k=(i+1)*T+_,X=(i+1)*(T-1)+_;y.push(F,U,X),y.push(U,k,X)}}()})(),this.setIndex(y),this.setAttribute("position",new Ot(p,3)),this.setAttribute("normal",new Ot(f,3)),this.setAttribute("uv",new Ot(m,2))}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new Ns(new Ko[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class el extends Qt{constructor(e){if(super(),this.type="WireframeGeometry",e.isGeometry===!0)return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const t=[],n=new Set,i=new H,r=new H;if(e.index!==null){const a=e.attributes.position,l=e.index;let c=e.groups;c.length===0&&(c=[{start:0,count:l.count,materialIndex:0}]);for(let h=0,d=c.length;h<d;++h){const p=c[h],f=p.start;for(let m=f,y=f+p.count;m<y;m+=3)for(let b=0;b<3;b++){const T=l.getX(m+b),_=l.getX(m+(b+1)%3);i.fromBufferAttribute(a,T),r.fromBufferAttribute(a,_),Zc(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}}else{const a=e.attributes.position;for(let l=0,c=a.count/3;l<c;l++)for(let h=0;h<3;h++){const d=3*l+h,p=3*l+(h+1)%3;i.fromBufferAttribute(a,d),r.fromBufferAttribute(a,p),Zc(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}this.setAttribute("position",new Ot(t,3))}}function Zc(s,e,t){const n=`${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;return t.has(n)!==!0&&t.has(i)!==!0&&(t.add(n,i),!0)}var Yc=Object.freeze({__proto__:null,BoxGeometry:fr,BoxBufferGeometry:fr,CircleGeometry:Es,CircleBufferGeometry:Es,ConeGeometry:As,ConeBufferGeometry:As,CylinderGeometry:Pr,CylinderBufferGeometry:Pr,DodecahedronGeometry:Ls,DodecahedronBufferGeometry:Ls,EdgesGeometry:Go,ExtrudeGeometry:Vi,ExtrudeBufferGeometry:Vi,IcosahedronGeometry:Cs,IcosahedronBufferGeometry:Cs,LatheGeometry:Ps,LatheBufferGeometry:Ps,OctahedronGeometry:Yr,OctahedronBufferGeometry:Yr,ParametricGeometry:no,ParametricBufferGeometry:no,PlaneGeometry:Gr,PlaneBufferGeometry:Gr,PolyhedronGeometry:sr,PolyhedronBufferGeometry:sr,RingGeometry:Is,RingBufferGeometry:Is,ShapeGeometry:Jr,ShapeBufferGeometry:Jr,SphereGeometry:Kr,SphereBufferGeometry:Kr,TetrahedronGeometry:Ds,TetrahedronBufferGeometry:Ds,TextGeometry:io,TextBufferGeometry:io,TorusGeometry:Os,TorusBufferGeometry:Os,TorusKnotGeometry:Fs,TorusKnotBufferGeometry:Fs,TubeGeometry:Ns,TubeBufferGeometry:Ns,WireframeGeometry:el});class tl extends We{constructor(e){super(),this.type="ShadowMaterial",this.color=new ut(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}tl.prototype.isShadowMaterial=!0;class ro extends We{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ut(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ut(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new at(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}ro.prototype.isMeshStandardMaterial=!0;class nl extends ro{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new at(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Bt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenTint=new ut(0),this.transmission=0,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationTint=new ut(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularTint=new ut(1,1,1),this.specularTintMap=null,this._clearcoat=0,this._transmission=0,this.setValues(e)}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheenTint.copy(e.sheenTint),this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationTint.copy(e.attenuationTint),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularTint.copy(e.specularTint),this.specularTintMap=e.specularTintMap,this}}nl.prototype.isMeshPhysicalMaterial=!0;class il extends We{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new ut(16777215),this.specular=new ut(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ut(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new at(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}il.prototype.isMeshPhongMaterial=!0;class rl extends We{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ut(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ut(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new at(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}rl.prototype.isMeshToonMaterial=!0;class sl extends We{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new at(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}sl.prototype.isMeshNormalMaterial=!0;class al extends We{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new ut(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ut(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}al.prototype.isMeshLambertMaterial=!0;class ol extends We{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ut(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new at(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this}}ol.prototype.isMeshMatcapMaterial=!0;class ll extends Kn{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}ll.prototype.isLineDashedMaterial=!0;var bp=Object.freeze({__proto__:null,ShadowMaterial:tl,SpriteMaterial:Da,RawShaderMaterial:vs,ShaderMaterial:mr,PointsMaterial:Zr,MeshPhysicalMaterial:nl,MeshStandardMaterial:ro,MeshPhongMaterial:il,MeshToonMaterial:rl,MeshNormalMaterial:sl,MeshLambertMaterial:al,MeshDepthMaterial:Ca,MeshDistanceMaterial:Pa,MeshBasicMaterial:_n,MeshMatcapMaterial:ol,LineDashedMaterial:ll,LineBasicMaterial:Kn,Material:We});const Pn={arraySlice:function(s,e,t){return Pn.isTypedArray(s)?new s.constructor(s.subarray(e,t!==void 0?t:s.length)):s.slice(e,t)},convertArray:function(s,e,t){return!s||!t&&s.constructor===e?s:typeof e.BYTES_PER_ELEMENT=="number"?new e(s):Array.prototype.slice.call(s)},isTypedArray:function(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)},getKeyframeOrder:function(s){const e=s.length,t=new Array(e);for(let n=0;n!==e;++n)t[n]=n;return t.sort(function(n,i){return s[n]-s[i]}),t},sortedArray:function(s,e,t){const n=s.length,i=new s.constructor(n);for(let r=0,a=0;a!==n;++r){const l=t[r]*e;for(let c=0;c!==e;++c)i[a++]=s[l+c]}return i},flattenJSON:function(s,e,t,n){let i=1,r=s[0];for(;r!==void 0&&r[n]===void 0;)r=s[i++];if(r===void 0)return;let a=r[n];if(a!==void 0)if(Array.isArray(a))do a=r[n],a!==void 0&&(e.push(r.time),t.push.apply(t,a)),r=s[i++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[n],a!==void 0&&(e.push(r.time),a.toArray(t,t.length)),r=s[i++];while(r!==void 0);else do a=r[n],a!==void 0&&(e.push(r.time),t.push(a)),r=s[i++];while(r!==void 0)},subclip:function(s,e,t,n,i=30){const r=s.clone();r.name=e;const a=[];for(let c=0;c<r.tracks.length;++c){const h=r.tracks[c],d=h.getValueSize(),p=[],f=[];for(let m=0;m<h.times.length;++m){const y=h.times[m]*i;if(!(y<t||y>=n)){p.push(h.times[m]);for(let b=0;b<d;++b)f.push(h.values[m*d+b])}}p.length!==0&&(h.times=Pn.convertArray(p,h.times.constructor),h.values=Pn.convertArray(f,h.values.constructor),a.push(h))}r.tracks=a;let l=1/0;for(let c=0;c<r.tracks.length;++c)l>r.tracks[c].times[0]&&(l=r.tracks[c].times[0]);for(let c=0;c<r.tracks.length;++c)r.tracks[c].shift(-1*l);return r.resetDuration(),r},makeClipAdditive:function(s,e=0,t=s,n=30){n<=0&&(n=30);const i=t.tracks.length,r=e/n;for(let a=0;a<i;++a){const l=t.tracks[a],c=l.ValueTypeName;if(c==="bool"||c==="string")continue;const h=s.tracks.find(function(_){return _.name===l.name&&_.ValueTypeName===c});if(h===void 0)continue;let d=0;const p=l.getValueSize();l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);let f=0;const m=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=m/3);const y=l.times.length-1;let b;if(r<=l.times[0]){const _=d,F=p-d;b=Pn.arraySlice(l.values,_,F)}else if(r>=l.times[y]){const _=y*p+d,F=_+p-d;b=Pn.arraySlice(l.values,_,F)}else{const _=l.createInterpolant(),F=d,U=p-d;_.evaluate(r),b=Pn.arraySlice(_.resultBuffer,F,U)}c==="quaternion"&&new In().fromArray(b).normalize().conjugate().toArray(b);const T=h.times.length;for(let _=0;_<T;++_){const F=_*m+f;if(c==="quaternion")In.multiplyQuaternionsFlat(h.values,F,b,0,h.values,F);else{const U=m-2*f;for(let k=0;k<U;++k)h.values[F+k]-=b[k]}}}return s.blendMode=2501,s}};class yr{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],r=t[n-1];e:{t:{let a;n:{i:if(!(e<i)){for(let l=n+2;;){if(i===void 0){if(e<r)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,r)}if(n===l)break;if(r=i,i=t[++n],e<i)break t}a=t.length;break n}if(e>=r)break e;{const l=t[1];e<l&&(n=2,r=l);for(let c=n-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(n===c)break;if(i=r,r=t[--n-1],e>=r)break t}a=n,n=0}}for(;n<a;){const l=n+a>>>1;e<t[l]?a=l:n=l+1}if(i=t[n],r=t[n-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(i===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,r,e)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i;for(let a=0;a!==i;++a)t[a]=n[r+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}yr.prototype.beforeStart_=yr.prototype.copySampleValue_,yr.prototype.afterEnd_=yr.prototype.copySampleValue_;class Jc extends yr{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(e,t,n){const i=this.parameterPositions;let r=e-2,a=e+1,l=i[r],c=i[a];if(l===void 0)switch(this.getSettings_().endingStart){case 2401:r=e,l=2*t-n;break;case 2402:r=i.length-2,l=t+i[r]-i[r+1];break;default:r=e,l=n}if(c===void 0)switch(this.getSettings_().endingEnd){case 2401:a=e,c=2*n-t;break;case 2402:a=1,c=n+i[1]-i[0];break;default:a=e-1,c=t}const h=.5*(n-t),d=this.valueSize;this._weightPrev=h/(t-l),this._weightNext=h/(c-n),this._offsetPrev=r*d,this._offsetNext=a*d}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,l=this.valueSize,c=e*l,h=c-l,d=this._offsetPrev,p=this._offsetNext,f=this._weightPrev,m=this._weightNext,y=(n-t)/(i-t),b=y*y,T=b*y,_=-f*T+2*f*b-f*y,F=(1+f)*T+(-1.5-2*f)*b+(-.5+f)*y+1,U=(-1-m)*T+(1.5+m)*b+.5*y,k=m*T-m*b;for(let X=0;X!==l;++X)r[X]=_*a[d+X]+F*a[h+X]+U*a[c+X]+k*a[p+X];return r}}class cl extends yr{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,l=this.valueSize,c=e*l,h=c-l,d=(n-t)/(i-t),p=1-d;for(let f=0;f!==l;++f)r[f]=a[h+f]*p+a[c+f]*d;return r}}class Kc extends yr{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class Wi{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Pn.convertArray(t,this.TimeBufferType),this.values=Pn.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Pn.convertArray(e.times,Array),values:Pn.convertArray(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new Kc(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new cl(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new Jc(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case 2300:t=this.InterpolantFactoryMethodDiscrete;break;case 2301:t=this.InterpolantFactoryMethodLinear;break;case 2302:t=this.InterpolantFactoryMethodSmooth}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0){if(e===this.DefaultInterpolation)throw new Error(n);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let r=0,a=i-1;for(;r!==i&&n[r]<e;)++r;for(;a!==-1&&n[a]>t;)--a;if(++a,r!==0||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);const l=this.getValueSize();this.times=Pn.arraySlice(n,r,a),this.values=Pn.arraySlice(this.values,r*l,a*l)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let l=0;l!==r;l++){const c=n[l];if(typeof c=="number"&&isNaN(c)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,l,c),e=!1;break}if(a!==null&&a>c){console.error("THREE.KeyframeTrack: Out of order keys.",this,l,c,a),e=!1;break}a=c}if(i!==void 0&&Pn.isTypedArray(i))for(let l=0,c=i.length;l!==c;++l){const h=i[l];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,l,h),e=!1;break}}return e}optimize(){const e=Pn.arraySlice(this.times),t=Pn.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===2302,r=e.length-1;let a=1;for(let l=1;l<r;++l){let c=!1;const h=e[l];if(h!==e[l+1]&&(l!==1||h!==e[0]))if(i)c=!0;else{const d=l*n,p=d-n,f=d+n;for(let m=0;m!==n;++m){const y=t[d+m];if(y!==t[p+m]||y!==t[f+m]){c=!0;break}}}if(c){if(l!==a){e[a]=e[l];const d=l*n,p=a*n;for(let f=0;f!==n;++f)t[p+f]=t[d+f]}++a}}if(r>0){e[a]=e[r];for(let l=r*n,c=a*n,h=0;h!==n;++h)t[c+h]=t[l+h];++a}return a!==e.length?(this.times=Pn.arraySlice(e,0,a),this.values=Pn.arraySlice(t,0,a*n)):(this.times=e,this.values=t),this}clone(){const e=Pn.arraySlice(this.times,0),t=Pn.arraySlice(this.values,0),n=new this.constructor(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}Wi.prototype.TimeBufferType=Float32Array,Wi.prototype.ValueBufferType=Float32Array,Wi.prototype.DefaultInterpolation=2301;class Qr extends Wi{}Qr.prototype.ValueTypeName="bool",Qr.prototype.ValueBufferType=Array,Qr.prototype.DefaultInterpolation=2300,Qr.prototype.InterpolantFactoryMethodLinear=void 0,Qr.prototype.InterpolantFactoryMethodSmooth=void 0;class ul extends Wi{}ul.prototype.ValueTypeName="color";class la extends Wi{}la.prototype.ValueTypeName="number";class Qc extends yr{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,l=this.valueSize,c=(n-t)/(i-t);let h=e*l;for(let d=h+l;h!==d;h+=4)In.slerpFlat(r,0,a,h-l,a,h,c);return r}}class Bs extends Wi{InterpolantFactoryMethodLinear(e){return new Qc(this.times,this.values,this.getValueSize(),e)}}Bs.prototype.ValueTypeName="quaternion",Bs.prototype.DefaultInterpolation=2301,Bs.prototype.InterpolantFactoryMethodSmooth=void 0;class $r extends Wi{}$r.prototype.ValueTypeName="string",$r.prototype.ValueBufferType=Array,$r.prototype.DefaultInterpolation=2300,$r.prototype.InterpolantFactoryMethodLinear=void 0,$r.prototype.InterpolantFactoryMethodSmooth=void 0;class ca extends Wi{}ca.prototype.ValueTypeName="vector";class ua{constructor(e,t=-1,n,i=2500){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=Ut(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let a=0,l=n.length;a!==l;++a)t.push(wp(n[a]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,a=n.length;r!==a;++r)t.push(Wi.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const r=t.length,a=[];for(let l=0;l<r;l++){let c=[],h=[];c.push((l+r-1)%r,l,(l+1)%r),h.push(0,1,0);const d=Pn.getKeyframeOrder(c);c=Pn.sortedArray(c,1,d),h=Pn.sortedArray(h,1,d),i||c[0]!==0||(c.push(r),h.push(h[0])),a.push(new la(".morphTargetInfluences["+t[l].name+"]",c,h).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let l=0,c=e.length;l<c;l++){const h=e[l],d=h.name.match(r);if(d&&d.length>1){const p=d[1];let f=i[p];f||(i[p]=f=[]),f.push(h)}}const a=[];for(const l in i)a.push(this.CreateFromMorphTargetSequence(l,i[l],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(d,p,f,m,y){if(f.length!==0){const b=[],T=[];Pn.flattenJSON(f,b,T,m),b.length!==0&&y.push(new d(p,b,T))}},i=[],r=e.name||"default",a=e.fps||30,l=e.blendMode;let c=e.length||-1;const h=e.hierarchy||[];for(let d=0;d<h.length;d++){const p=h[d].keys;if(p&&p.length!==0)if(p[0].morphTargets){const f={};let m;for(m=0;m<p.length;m++)if(p[m].morphTargets)for(let y=0;y<p[m].morphTargets.length;y++)f[p[m].morphTargets[y]]=-1;for(const y in f){const b=[],T=[];for(let _=0;_!==p[m].morphTargets.length;++_){const F=p[m];b.push(F.time),T.push(F.morphTarget===y?1:0)}i.push(new la(".morphTargetInfluence["+y+"]",b,T))}c=f.length*(a||1)}else{const f=".bones["+t[d].name+"]";n(ca,f+".position",p,"pos",i),n(Bs,f+".quaternion",p,"rot",i),n(ca,f+".scale",p,"scl",i)}}return i.length===0?null:new this(r,c,i,l)}resetDuration(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){const i=this.tracks[t];e=Math.max(e,i.times[i.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function wp(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return la;case"vector":case"vector2":case"vector3":case"vector4":return ca;case"color":return ul;case"quaternion":return Bs;case"bool":case"boolean":return Qr;case"string":return $r}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(s.type);if(s.times===void 0){const t=[],n=[];Pn.flattenJSON(s.keys,t,n,"value"),s.times=t,s.values=n}return e.parse!==void 0?e.parse(s):new e(s.name,s.times,s.values,s.interpolation)}const es={enabled:!1,files:{},add:function(s,e){this.enabled!==!1&&(this.files[s]=e)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class hl{constructor(e,t,n){const i=this;let r,a=!1,l=0,c=0;const h=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(d){c++,a===!1&&i.onStart!==void 0&&i.onStart(d,l,c),a=!0},this.itemEnd=function(d){l++,i.onProgress!==void 0&&i.onProgress(d,l,c),l===c&&(a=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(d){i.onError!==void 0&&i.onError(d)},this.resolveURL=function(d){return r?r(d):d},this.setURLModifier=function(d){return r=d,this},this.addHandler=function(d,p){return h.push(d,p),this},this.removeHandler=function(d){const p=h.indexOf(d);return p!==-1&&h.splice(p,2),this},this.getHandler=function(d){for(let p=0,f=h.length;p<f;p+=2){const m=h[p],y=h[p+1];if(m.global&&(m.lastIndex=0),m.test(d))return y}return null}}}const $c=new hl;class hi{constructor(e){this.manager=e!==void 0?e:$c,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,r){n.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const ji={};class qi extends hi{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=es.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;if(ji[e]!==void 0)return void ji[e].push({onLoad:t,onProgress:n,onError:i});const l=e.match(/^data:(.*?)(;base64)?,(.*)$/);let c;if(l){const h=l[1],d=!!l[2];let p=l[3];p=decodeURIComponent(p),d&&(p=atob(p));try{let f;const m=(this.responseType||"").toLowerCase();switch(m){case"arraybuffer":case"blob":const y=new Uint8Array(p.length);for(let T=0;T<p.length;T++)y[T]=p.charCodeAt(T);f=m==="blob"?new Blob([y.buffer],{type:h}):y.buffer;break;case"document":f=new DOMParser().parseFromString(p,h);break;case"json":f=JSON.parse(p);break;default:f=p}setTimeout(function(){t&&t(f),r.manager.itemEnd(e)},0)}catch(f){setTimeout(function(){i&&i(f),r.manager.itemError(e),r.manager.itemEnd(e)},0)}}else{ji[e]=[],ji[e].push({onLoad:t,onProgress:n,onError:i}),c=new XMLHttpRequest,c.open("GET",e,!0),c.addEventListener("load",function(h){const d=this.response,p=ji[e];if(delete ji[e],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),es.add(e,d);for(let f=0,m=p.length;f<m;f++){const y=p[f];y.onLoad&&y.onLoad(d)}r.manager.itemEnd(e)}else{for(let f=0,m=p.length;f<m;f++){const y=p[f];y.onError&&y.onError(h)}r.manager.itemError(e),r.manager.itemEnd(e)}},!1),c.addEventListener("progress",function(h){const d=ji[e];for(let p=0,f=d.length;p<f;p++){const m=d[p];m.onProgress&&m.onProgress(h)}},!1),c.addEventListener("error",function(h){const d=ji[e];delete ji[e];for(let p=0,f=d.length;p<f;p++){const m=d[p];m.onError&&m.onError(h)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),c.addEventListener("abort",function(h){const d=ji[e];delete ji[e];for(let p=0,f=d.length;p<f;p++){const m=d[p];m.onError&&m.onError(h)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),this.responseType!==void 0&&(c.responseType=this.responseType),this.withCredentials!==void 0&&(c.withCredentials=this.withCredentials),c.overrideMimeType&&c.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const h in this.requestHeader)c.setRequestHeader(h,this.requestHeader[h]);c.send(null)}return r.manager.itemStart(e),c}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class ha extends hi{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=es.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;const l=document.createElementNS("http://www.w3.org/1999/xhtml","img");function c(){l.removeEventListener("load",c,!1),l.removeEventListener("error",h,!1),es.add(e,this),t&&t(this),r.manager.itemEnd(e)}function h(d){l.removeEventListener("load",c,!1),l.removeEventListener("error",h,!1),i&&i(d),r.manager.itemError(e),r.manager.itemEnd(e)}return l.addEventListener("load",c,!1),l.addEventListener("error",h,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(l.crossOrigin=this.crossOrigin),r.manager.itemStart(e),l.src=e,l}}class eu extends hi{constructor(e){super(e)}load(e,t,n,i){const r=new gs,a=new ha(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let l=0;function c(h){a.load(e[h],function(d){r.images[h]=d,l++,l===6&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let h=0;h<e.length;++h)c(h);return r}}class tu extends hi{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new qr,l=new qi(this.manager);return l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setPath(this.path),l.setWithCredentials(r.withCredentials),l.load(e,function(c){const h=r.parse(c);h&&(h.image!==void 0?a.image=h.image:h.data!==void 0&&(a.image.width=h.width,a.image.height=h.height,a.image.data=h.data),a.wrapS=h.wrapS!==void 0?h.wrapS:1001,a.wrapT=h.wrapT!==void 0?h.wrapT:1001,a.magFilter=h.magFilter!==void 0?h.magFilter:1006,a.minFilter=h.minFilter!==void 0?h.minFilter:1006,a.anisotropy=h.anisotropy!==void 0?h.anisotropy:1,h.encoding!==void 0&&(a.encoding=h.encoding),h.flipY!==void 0&&(a.flipY=h.flipY),h.format!==void 0&&(a.format=h.format),h.type!==void 0&&(a.type=h.type),h.mipmaps!==void 0&&(a.mipmaps=h.mipmaps,a.minFilter=1008),h.mipmapCount===1&&(a.minFilter=1006),h.generateMipmaps!==void 0&&(a.generateMipmaps=h.generateMipmaps),a.needsUpdate=!0,t&&t(a,h))},n,i),a}}class nu extends hi{constructor(e){super(e)}load(e,t,n,i){const r=new wn,a=new ha(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(l){r.image=l;const c=e.search(/\.jpe?g($|\?)/i)>0||e.search(/^data\:image\/jpeg/)===0;r.format=c?1022:1023,r.needsUpdate=!0,t!==void 0&&t(r)},n,i),r}}class iu extends Ri{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new ra(t,e))}getPoint(e){const t=e*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=t){const r=n[i]-t,a=this.curves[i],l=a.getLength(),c=l===0?0:1-r/l;return a.getPointAt(c)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const a=r[i],l=a&&a.isEllipseCurve?2*e:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?e*a.points.length:e,c=a.getPoints(l);for(let h=0;h<c.length;h++){const d=c[h];n&&n.equals(d)||(t.push(d),n=d)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new Ko[i.type]().fromJSON(i))}return this}}class da extends iu{constructor(e){super(),this.type="Path",this.currentPoint=new at,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new ra(this.currentPoint.clone(),new at(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const r=new Ka(this.currentPoint.clone(),new at(e,t),new at(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,r,a){const l=new Ja(this.currentPoint.clone(),new at(e,t),new at(n,i),new at(r,a));return this.curves.push(l),this.currentPoint.set(r,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new Qa(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,r,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absarc(e+l,t+c,n,i,r,a),this}absarc(e,t,n,i,r,a){return this.absellipse(e,t,n,n,i,r,a),this}ellipse(e,t,n,i,r,a,l,c){const h=this.currentPoint.x,d=this.currentPoint.y;return this.absellipse(e+h,t+d,n,i,r,a,l,c),this}absellipse(e,t,n,i,r,a,l,c){const h=new ta(e,t,n,i,r,a,l,c);if(this.curves.length>0){const p=h.getPoint(0);p.equals(this.currentPoint)||this.lineTo(p.x,p.y)}this.curves.push(h);const d=h.getPoint(1);return this.currentPoint.copy(d),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Dr extends da{constructor(e){super(e),this.uuid=Ut(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new da().fromJSON(i))}return this}}class Xi extends E{constructor(e,t=1){super(),this.type="Light",this.color=new ut(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}Xi.prototype.isLight=!0;class dl extends Xi{constructor(e,t,n){super(e,n),this.type="HemisphereLight",this.position.copy(E.DefaultUp),this.updateMatrix(),this.groundColor=new ut(t)}copy(e){return Xi.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}dl.prototype.isHemisphereLight=!0;const ru=new Dt,su=new H,au=new H;class pl{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new at(512,512),this.map=null,this.mapPass=null,this.matrix=new Dt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ws,this._frameExtents=new at(1,1),this._viewportCount=1,this._viewports=[new en(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;su.setFromMatrixPosition(e.matrixWorld),t.position.copy(su),au.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(au),t.updateMatrixWorld(),ru.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ru),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),this.mapSize.x===512&&this.mapSize.y===512||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class ou extends pl{constructor(){super(new Jn(50,1,.5,500)),this.focus=1}updateMatrices(e){const t=this.camera,n=2*Nt*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;n===t.fov&&i===t.aspect&&r===t.far||(t.fov=n,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}ou.prototype.isSpotLightShadow=!0;class fl extends Xi{constructor(e,t,n=0,i=Math.PI/3,r=0,a=1){super(e,t),this.type="SpotLight",this.position.copy(E.DefaultUp),this.updateMatrix(),this.target=new E,this.distance=n,this.angle=i,this.penumbra=r,this.decay=a,this.shadow=new ou}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}fl.prototype.isSpotLight=!0;const lu=new Dt,pa=new H,ml=new H;class cu extends pl{constructor(){super(new Jn(90,1,.5,500)),this._frameExtents=new at(4,2),this._viewportCount=6,this._viewports=[new en(2,1,1,1),new en(0,1,1,1),new en(3,1,1,1),new en(1,1,1,1),new en(3,0,1,1),new en(1,0,1,1)],this._cubeDirections=[new H(1,0,0),new H(-1,0,0),new H(0,0,1),new H(0,0,-1),new H(0,1,0),new H(0,-1,0)],this._cubeUps=[new H(0,1,0),new H(0,1,0),new H(0,1,0),new H(0,1,0),new H(0,0,1),new H(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,r=e.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),pa.setFromMatrixPosition(e.matrixWorld),n.position.copy(pa),ml.copy(n.position),ml.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(ml),n.updateMatrixWorld(),i.makeTranslation(-pa.x,-pa.y,-pa.z),lu.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(lu)}}cu.prototype.isPointLightShadow=!0;class gl extends Xi{constructor(e,t,n=0,i=1){super(e,t),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new cu}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}gl.prototype.isPointLight=!0;class uu extends pl{constructor(){super(new js(-5,5,5,-5,.5,500))}}uu.prototype.isDirectionalLightShadow=!0;class yl extends Xi{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(E.DefaultUp),this.updateMatrix(),this.target=new E,this.shadow=new uu}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}yl.prototype.isDirectionalLight=!0;class vl extends Xi{constructor(e,t){super(e,t),this.type="AmbientLight"}}vl.prototype.isAmbientLight=!0;class xl extends Xi{constructor(e,t,n=10,i=10){super(e,t),this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}xl.prototype.isRectAreaLight=!0;class bl{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new H)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,r=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*i),t.addScaledVector(a[2],.488603*r),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],n*i*1.092548),t.addScaledVector(a[5],i*r*1.092548),t.addScaledVector(a[6],.315392*(3*r*r-1)),t.addScaledVector(a[7],n*r*1.092548),t.addScaledVector(a[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,r=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],1.023328*i),t.addScaledVector(a[2],1.023328*r),t.addScaledVector(a[3],1.023328*n),t.addScaledVector(a[4],.858086*n*i),t.addScaledVector(a[5],.858086*i*r),t.addScaledVector(a[6],.743125*r*r-.247708),t.addScaledVector(a[7],.858086*n*r),t.addScaledVector(a[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+3*i);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+3*i);return e}static getBasisAt(e,t){const n=e.x,i=e.y,r=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*r,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*n*r,t[8]=.546274*(n*n-i*i)}}bl.prototype.isSphericalHarmonics3=!0;class fa extends Xi{constructor(e=new bl,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}fa.prototype.isLightProbe=!0;class hu extends hi{constructor(e){super(e),this.textures={}}load(e,t,n,i){const r=this,a=new qi(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(l){try{t(r.parse(JSON.parse(l)))}catch(c){i?i(c):console.error(c),r.manager.itemError(e)}},n,i)}parse(e){const t=this.textures;function n(r){return t[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}const i=new bp[e.type];if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheenTint!==void 0&&(i.sheenTint=new ut().setHex(e.sheenTint)),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularTint!==void 0&&i.specularTint!==void 0&&i.specularTint.setHex(e.specularTint),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationTint!==void 0&&i.attenuationTint!==void 0&&i.attenuationTint.setHex(e.attenuationTint),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.format!==void 0&&(i.format=e.format),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const r in e.uniforms){const a=e.uniforms[r];switch(i.uniforms[r]={},a.type){case"t":i.uniforms[r].value=n(a.value);break;case"c":i.uniforms[r].value=new ut().setHex(a.value);break;case"v2":i.uniforms[r].value=new at().fromArray(a.value);break;case"v3":i.uniforms[r].value=new H().fromArray(a.value);break;case"v4":i.uniforms[r].value=new en().fromArray(a.value);break;case"m3":i.uniforms[r].value=new hn().fromArray(a.value);break;case"m4":i.uniforms[r].value=new Dt().fromArray(a.value);break;default:i.uniforms[r].value=a.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.extensions!==void 0)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(e.shading!==void 0&&(i.flatShading=e.shading===1),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new at().fromArray(r)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(e.specularIntensityMap)),e.specularTintMap!==void 0&&(i.specularTintMap=n(e.specularTintMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new at().fromArray(e.clearcoatNormalScale)),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=n(e.thicknessMap)),i}setTextures(e){return this.textures=e,this}}class so{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}}class wl extends Qt{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}wl.prototype.isInstancedBufferGeometry=!0;class du extends hi{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new qi(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(l){try{t(r.parse(JSON.parse(l)))}catch(c){i?i(c):console.error(c),r.manager.itemError(e)}},n,i)}parse(e){const t={},n={};function i(p,f){if(t[f]!==void 0)return t[f];const m=p.interleavedBuffers[f],y=function(_,F){if(n[F]!==void 0)return n[F];const U=_.arrayBuffers[F],k=new Uint32Array(U).buffer;return n[F]=k,k}(p,m.buffer),b=pr(m.type,y),T=new jr(b,m.stride);return T.uuid=m.uuid,t[f]=T,T}const r=e.isInstancedBufferGeometry?new wl:new Qt,a=e.data.index;if(a!==void 0){const p=pr(a.type,a.array);r.setIndex(new $t(p,1))}const l=e.data.attributes;for(const p in l){const f=l[p];let m;if(f.isInterleavedBufferAttribute){const y=i(e.data,f.data);m=new Cr(y,f.itemSize,f.offset,f.normalized)}else{const y=pr(f.type,f.array);m=new(f.isInstancedBufferAttribute?Xr:$t)(y,f.itemSize,f.normalized)}f.name!==void 0&&(m.name=f.name),f.usage!==void 0&&m.setUsage(f.usage),f.updateRange!==void 0&&(m.updateRange.offset=f.updateRange.offset,m.updateRange.count=f.updateRange.count),r.setAttribute(p,m)}const c=e.data.morphAttributes;if(c)for(const p in c){const f=c[p],m=[];for(let y=0,b=f.length;y<b;y++){const T=f[y];let _;if(T.isInterleavedBufferAttribute){const F=i(e.data,T.data);_=new Cr(F,T.itemSize,T.offset,T.normalized)}else{const F=pr(T.type,T.array);_=new $t(F,T.itemSize,T.normalized)}T.name!==void 0&&(_.name=T.name),m.push(_)}r.morphAttributes[p]=m}e.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const h=e.data.groups||e.data.drawcalls||e.data.offsets;if(h!==void 0)for(let p=0,f=h.length;p!==f;++p){const m=h[p];r.addGroup(m.start,m.count,m.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const p=new H;d.center!==void 0&&p.fromArray(d.center),r.boundingSphere=new Si(p,d.radius)}return e.name&&(r.name=e.name),e.userData&&(r.userData=e.userData),r}}const _p={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,CubeUVReflectionMapping:306,CubeUVRefractionMapping:307},pu={RepeatWrapping:1e3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},fu={NearestFilter:1003,NearestMipmapNearestFilter:1004,NearestMipmapLinearFilter:1005,LinearFilter:1006,LinearMipmapNearestFilter:1007,LinearMipmapLinearFilter:1008};class mu extends hi{constructor(e){super(e),typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=es.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;const l={};l.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",l.headers=this.requestHeader,fetch(e,l).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(c){es.add(e,c),t&&t(c),r.manager.itemEnd(e)}).catch(function(c){i&&i(c),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}mu.prototype.isImageBitmapLoader=!0;class gu{constructor(){this.type="ShapePath",this.color=new ut,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new da,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,r,a){return this.currentPath.bezierCurveTo(e,t,n,i,r,a),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function n(F){const U=[];for(let k=0,X=F.length;k<X;k++){const K=F[k],ye=new Dr;ye.curves=K.curves,U.push(ye)}return U}function i(F,U){const k=U.length;let X=!1;for(let K=k-1,ye=0;ye<k;K=ye++){let we=U[K],Fe=U[ye],Te=Fe.x-we.x,Ce=Fe.y-we.y;if(Math.abs(Ce)>Number.EPSILON){if(Ce<0&&(we=U[ye],Te=-Te,Fe=U[K],Ce=-Ce),F.y<we.y||F.y>Fe.y)continue;if(F.y===we.y){if(F.x===we.x)return!0}else{const St=Ce*(F.x-we.x)-Te*(F.y-we.y);if(St===0)return!0;if(St<0)continue;X=!X}}else{if(F.y!==we.y)continue;if(Fe.x<=F.x&&F.x<=we.x||we.x<=F.x&&F.x<=Fe.x)return!0}}return X}const r=ar.isClockWise,a=this.subPaths;if(a.length===0)return[];if(t===!0)return n(a);let l,c,h;const d=[];if(a.length===1)return c=a[0],h=new Dr,h.curves=c.curves,d.push(h),d;let p=!r(a[0].getPoints());p=e?!p:p;const f=[],m=[];let y,b,T=[],_=0;m[_]=void 0,T[_]=[];for(let F=0,U=a.length;F<U;F++)c=a[F],y=c.getPoints(),l=r(y),l=e?!l:l,l?(!p&&m[_]&&_++,m[_]={s:new Dr,p:y},m[_].s.curves=c.curves,p&&_++,T[_]=[]):T[_].push({h:c,p:y[0]});if(!m[0])return n(a);if(m.length>1){let F=!1;const U=[];for(let k=0,X=m.length;k<X;k++)f[k]=[];for(let k=0,X=m.length;k<X;k++){const K=T[k];for(let ye=0;ye<K.length;ye++){const we=K[ye];let Fe=!0;for(let Te=0;Te<m.length;Te++)i(we.p,m[Te].p)&&(k!==Te&&U.push({froms:k,tos:Te,hole:ye}),Fe?(Fe=!1,f[Te].push(we)):F=!0);Fe&&f[k].push(we)}}U.length>0&&(F||(T=f))}for(let F=0,U=m.length;F<U;F++){h=m[F].s,d.push(h),b=T[F];for(let k=0,X=b.length;k<X;k++)h.holes.push(b[k].h)}return d}}class _l{constructor(e){this.type="Font",this.data=e}generateShapes(e,t=100){const n=[],i=function(r,a,l){const c=Array.from(r),h=a/l.resolution,d=(l.boundingBox.yMax-l.boundingBox.yMin+l.underlineThickness)*h,p=[];let f=0,m=0;for(let y=0;y<c.length;y++){const b=c[y];if(b===`
`)f=0,m-=d;else{const T=Mp(b,h,f,m,l);f+=T.offsetX,p.push(T.path)}}return p}(e,t,this.data);for(let r=0,a=i.length;r<a;r++)Array.prototype.push.apply(n,i[r].toShapes());return n}}function Mp(s,e,t,n,i){const r=i.glyphs[s]||i.glyphs["?"];if(!r)return void console.error('THREE.Font: character "'+s+'" does not exists in font family '+i.familyName+".");const a=new gu;let l,c,h,d,p,f,m,y;if(r.o){const b=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let T=0,_=b.length;T<_;)switch(b[T++]){case"m":l=b[T++]*e+t,c=b[T++]*e+n,a.moveTo(l,c);break;case"l":l=b[T++]*e+t,c=b[T++]*e+n,a.lineTo(l,c);break;case"q":h=b[T++]*e+t,d=b[T++]*e+n,p=b[T++]*e+t,f=b[T++]*e+n,a.quadraticCurveTo(p,f,h,d);break;case"b":h=b[T++]*e+t,d=b[T++]*e+n,p=b[T++]*e+t,f=b[T++]*e+n,m=b[T++]*e+t,y=b[T++]*e+n,a.bezierCurveTo(p,f,m,y,h,d)}}return{offsetX:r.ha*e,path:a}}_l.prototype.isFont=!0;let ao;const Ml={getContext:function(){return ao===void 0&&(ao=new(window.AudioContext||window.webkitAudioContext)),ao},setContext:function(s){ao=s}};class yu extends hi{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new qi(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){try{const c=l.slice(0);Ml.getContext().decodeAudioData(c,function(h){t(h)})}catch(c){i?i(c):console.error(c),r.manager.itemError(e)}},n,i)}}class vu extends fa{constructor(e,t,n=1){super(void 0,n);const i=new ut().set(e),r=new ut().set(t),a=new H(i.r,i.g,i.b),l=new H(r.r,r.g,r.b),c=Math.sqrt(Math.PI),h=c*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(l).multiplyScalar(c),this.sh.coefficients[1].copy(a).sub(l).multiplyScalar(h)}}vu.prototype.isHemisphereLightProbe=!0;class xu extends fa{constructor(e,t=1){super(void 0,t);const n=new ut().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}xu.prototype.isAmbientLightProbe=!0;const bu=new Dt,wu=new Dt;class _u{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Mu(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Mu();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Mu(){return(typeof performance>"u"?Date:performance).now()}const ts=new H,Su=new In,Sp=new H,ns=new H;class Sl extends E{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0)return void console.warn("THREE.Audio: Audio is already playing.");if(this.hasPlaybackControl===!1)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl!==!1)return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(this.hasPlaybackControl!==!1)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl!==!1)return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl!==!1)return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const is=new H,Tu=new In,Tp=new H,rs=new H;class Eu{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class Au{constructor(e,t,n){let i,r,a;switch(this.binding=e,this.valueSize=n,t){case"quaternion":i=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,r=e*i+i;let a=this.cumulativeWeight;if(a===0){for(let l=0;l!==i;++l)n[r+l]=n[l];a=t}else{a+=t;const l=t/a;this._mixBufferRegion(n,r,0,l,i)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,l=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const c=t*this._origIndex;this._mixBufferRegion(n,i,c,1-r,t)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let c=t,h=t+t;c!==h;++c)if(n[c]!==n[c+t]){l.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let r=n,a=i;r!==a;++r)t[r]=t[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,r){if(i>=.5)for(let a=0;a!==r;++a)e[t+a]=e[n+a]}_slerp(e,t,n,i){In.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,r){const a=this._workIndex*r;In.multiplyQuaternionsFlat(e,a,e,t,e,n),In.slerpFlat(e,t,e,t,e,a,i)}_lerp(e,t,n,i,r){const a=1-i;for(let l=0;l!==r;++l){const c=t+l;e[c]=e[c]*a+e[n+l]*i}}_lerpAdditive(e,t,n,i,r){for(let a=0;a!==r;++a){const l=t+a;e[l]=e[l]+e[n+a]*i}}}const Ep="\\[\\]\\.:\\/",Ap=new RegExp("[\\[\\]\\.:\\/]","g"),Tl="[^\\[\\]\\.:\\/]",Lp="[^"+Ep.replace("\\.","")+"]",Rp=/((?:WC+[\/:])*)/.source.replace("WC",Tl),Cp=/(WCOD+)?/.source.replace("WCOD",Lp),Pp=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Tl),Ip=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Tl),Dp=new RegExp("^"+Rp+Cp+Pp+Ip+"$"),Op=["material","materials","bones"];class vn{constructor(e,t,n){this.path=t,this.parsedPath=n||vn.parseTrackName(t),this.node=vn.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new vn.Composite(e,t,n):new vn(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(Ap,"")}static parseTrackName(e){const t=Dp.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);Op.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(r){for(let a=0;a<r.length;a++){const l=r[a];if(l.name===t||l.uuid===t)return l;const c=n(l.children);if(c)return c}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=vn.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let h=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let d=0;d<e.length;d++)if(e[d].name===h){h=d;break}break;default:if(e[n]===void 0)return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(h!==void 0){if(e[h]===void 0)return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[h]}}const a=e[i];if(a===void 0){const h=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+i+" but it wasn't found.",e)}let l=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?l=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(l=this.Versioning.MatrixWorldNeedsUpdate);let c=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}c=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(c=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(c=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[c],this.setValue=this.SetterByBindingTypeAndVersioning[c][l]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}vn.Composite=class{constructor(s,e,t){const n=t||vn.parseTrackName(e);this._targetGroup=s,this._bindings=s.subscribe_(e,n)}getValue(s,e){this.bind();const t=this._targetGroup.nCachedObjects_,n=this._bindings[t];n!==void 0&&n.getValue(s,e)}setValue(s,e){const t=this._bindings;for(let n=this._targetGroup.nCachedObjects_,i=t.length;n!==i;++n)t[n].setValue(s,e)}bind(){const s=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=s.length;e!==t;++e)s[e].bind()}unbind(){const s=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=s.length;e!==t;++e)s[e].unbind()}},vn.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},vn.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},vn.prototype.GetterByBindingType=[vn.prototype._getValue_direct,vn.prototype._getValue_array,vn.prototype._getValue_arrayElement,vn.prototype._getValue_toArray],vn.prototype.SetterByBindingTypeAndVersioning=[[vn.prototype._setValue_direct,vn.prototype._setValue_direct_setNeedsUpdate,vn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[vn.prototype._setValue_array,vn.prototype._setValue_array_setNeedsUpdate,vn.prototype._setValue_array_setMatrixWorldNeedsUpdate],[vn.prototype._setValue_arrayElement,vn.prototype._setValue_arrayElement_setNeedsUpdate,vn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[vn.prototype._setValue_fromArray,vn.prototype._setValue_fromArray_setNeedsUpdate,vn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Lu{constructor(){this.uuid=Ut(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,a=r.length;let l,c=e.length,h=this.nCachedObjects_;for(let d=0,p=arguments.length;d!==p;++d){const f=arguments[d],m=f.uuid;let y=t[m];if(y===void 0){y=c++,t[m]=y,e.push(f);for(let b=0,T=a;b!==T;++b)r[b].push(new vn(f,n[b],i[b]))}else if(y<h){l=e[y];const b=--h,T=e[b];t[T.uuid]=y,e[y]=T,t[m]=b,e[b]=f;for(let _=0,F=a;_!==F;++_){const U=r[_],k=U[b];let X=U[y];U[y]=k,X===void 0&&(X=new vn(f,n[_],i[_])),U[b]=X}}else e[y]!==l&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=h}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let a=0,l=arguments.length;a!==l;++a){const c=arguments[a],h=c.uuid,d=t[h];if(d!==void 0&&d>=r){const p=r++,f=e[p];t[f.uuid]=d,e[d]=f,t[h]=p,e[p]=c;for(let m=0,y=i;m!==y;++m){const b=n[m],T=b[p],_=b[d];b[d]=T,b[p]=_}}}this.nCachedObjects_=r}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,a=e.length;for(let l=0,c=arguments.length;l!==c;++l){const h=arguments[l].uuid,d=t[h];if(d!==void 0)if(delete t[h],d<r){const p=--r,f=e[p],m=--a,y=e[m];t[f.uuid]=d,e[d]=f,t[y.uuid]=p,e[p]=y,e.pop();for(let b=0,T=i;b!==T;++b){const _=n[b],F=_[p],U=_[m];_[d]=F,_[p]=U,_.pop()}}else{const p=--a,f=e[p];p>0&&(t[f.uuid]=d),e[d]=f,e.pop();for(let m=0,y=i;m!==y;++m){const b=n[m];b[d]=b[p],b.pop()}}}this.nCachedObjects_=r}subscribe_(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const r=this._bindings;if(i!==void 0)return r[i];const a=this._paths,l=this._parsedPaths,c=this._objects,h=c.length,d=this.nCachedObjects_,p=new Array(h);i=r.length,n[e]=i,a.push(e),l.push(t),r.push(p);for(let f=d,m=c.length;f!==m;++f){const y=c[f];p[f]=new vn(y,e,t)}return p}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const i=this._paths,r=this._parsedPaths,a=this._bindings,l=a.length-1,c=a[l];t[e[l]]=n,a[n]=c,a.pop(),r[n]=r[l],r.pop(),i[n]=i[l],i.pop()}}}Lu.prototype.isAnimationObjectGroup=!0;class Fp{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const r=t.tracks,a=r.length,l=new Array(a),c={endingStart:2400,endingEnd:2400};for(let h=0;h!==a;++h){const d=r[h].createInterpolant(null);l[h]=d,d.settings=c}this._interpolantSettings=c,this._interpolants=l,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const i=this._clip.duration,r=e._clip.duration,a=r/i,l=i/r;e.warp(1,a,t),this.warp(l,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,r=i.time,a=this.timeScale;let l=this._timeScaleInterpolant;l===null&&(l=i._lendControlInterpolant(),this._timeScaleInterpolant=l);const c=l.parameterPositions,h=l.sampleValues;return c[0]=r,c[1]=r+n,h[0]=e/a,h[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled)return void this._updateWeight(e);const r=this._startTime;if(r!==null){const c=(e-r)*n;if(c<0||n===0)return;this._startTime=null,t=n*c}t*=this._updateTimeScale(e);const a=this._updateTime(t),l=this._updateWeight(e);if(l>0){const c=this._interpolants,h=this._propertyBindings;switch(this.blendMode){case 2501:for(let d=0,p=c.length;d!==p;++d)c[d].evaluate(a),h[d].accumulateAdditive(l);break;case 2500:default:for(let d=0,p=c.length;d!==p;++d)c[d].evaluate(a),h[d].accumulate(i,l)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,r=this._loopCount;const a=n===2202;if(e===0)return r===-1?i:a&&(1&r)==1?t-i:i;if(n===2200){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else{if(!(i<0)){this.time=i;break e}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=t||i<0){const l=Math.floor(i/t);i-=t*l,r+=Math.abs(l);const c=this.repetitions-r;if(c<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(c===1){const h=e<0;this._setEndings(h,!h,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:l})}}else this.time=i;if(a&&(1&r)==1)return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=2401,i.endingEnd=2401):(i.endingStart=e?this.zeroSlopeAtStart?2401:2400:2402,i.endingEnd=t?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(e,t,n){const i=this._mixer,r=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=r,c[0]=t,l[1]=r+e,c[1]=n,this}}class Ru extends Re{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,r=i.length,a=e._propertyBindings,l=e._interpolants,c=n.uuid,h=this._bindingsByRootAndName;let d=h[c];d===void 0&&(d={},h[c]=d);for(let p=0;p!==r;++p){const f=i[p],m=f.name;let y=d[m];if(y!==void 0)a[p]=y;else{if(y=a[p],y!==void 0){y._cacheIndex===null&&(++y.referenceCount,this._addInactiveBinding(y,c,m));continue}const b=t&&t._propertyBindings[p].binding.parsedPath;y=new Au(vn.create(n,m,b),f.ValueTypeName,f.getValueSize()),++y.referenceCount,this._addInactiveBinding(y,c,m),a[p]=y}l[p].resultBuffer=y.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];r.useCount++==0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.useCount==0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,r=this._actionsByClip;let a=r[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=a;else{const l=a.knownActions;e._byClipCacheIndex=l.length,l.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,a=this._actionsByClip,l=a[r],c=l.knownActions,h=c[c.length-1],d=e._byClipCacheIndex;h._byClipCacheIndex=d,c[d]=h,c.pop(),e._byClipCacheIndex=null,delete l.actionByRoot[(e._localRoot||this._root).uuid],c.length===0&&delete a[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.referenceCount==0&&this._removeInactiveBinding(r)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,r=this._bindings;let a=i[t];a===void 0&&(a={},i[t]=a),a[n]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,r=n.path,a=this._bindingsByRootAndName,l=a[i],c=t[t.length-1],h=e._cacheIndex;c._cacheIndex=h,t[h]=c,t.pop(),delete l[r],Object.keys(l).length===0&&delete a[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new cl(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=n,t[n]=r}clipAction(e,t,n){const i=t||this._root,r=i.uuid;let a=typeof e=="string"?ua.findByName(i,e):e;const l=a!==null?a.uuid:e,c=this._actionsByClip[l];let h=null;if(n===void 0&&(n=a!==null?a.blendMode:2500),c!==void 0){const p=c.actionByRoot[r];if(p!==void 0&&p.blendMode===n)return p;h=c.knownActions[0],a===null&&(a=h._clip)}if(a===null)return null;const d=new Fp(this,a,t,n);return this._bindAction(d,h),this._addInactiveAction(d,l,r),d}existingAction(e,t){const n=t||this._root,i=n.uuid,r=typeof e=="string"?ua.findByName(n,e):e,a=r?r.uuid:e,l=this._actionsByClip[a];return l!==void 0&&l.actionByRoot[i]||null}stopAllAction(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,r=Math.sign(e),a=this._accuIndex^=1;for(let h=0;h!==n;++h)t[h]._update(i,e,r,a);const l=this._bindings,c=this._nActiveBindings;for(let h=0;h!==c;++h)l[h].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){const a=r.knownActions;for(let l=0,c=a.length;l!==c;++l){const h=a[l];this._deactivateAction(h);const d=h._cacheIndex,p=t[t.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,p._cacheIndex=d,t[d]=p,t.pop(),this._removeInactiveBindingsForAction(h)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const r in n){const a=n[r].actionByRoot[t];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const i=this._bindingsByRootAndName[t];if(i!==void 0)for(const r in i){const a=i[r];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}Ru.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class oo{constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new oo(this.value.clone===void 0?this.value:this.value.clone())}}class Cu extends jr{constructor(e,t,n=1){super(e,t),this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}Cu.prototype.isInstancedInterleavedBuffer=!0;class Pu{constructor(e,t,n,i,r){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}Pu.prototype.isGLBufferAttribute=!0;function Iu(s,e){return s.distance-e.distance}function El(s,e,t,n){if(s.layers.test(e.layers)&&s.raycast(e,t),n===!0){const i=s.children;for(let r=0,a=i.length;r<a;r++)El(i[r],e,t,!0)}}const Du=new at;class zs{constructor(e=new at(1/0,1/0),t=new at(-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Du.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Du.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}zs.prototype.isBox2=!0;const Ou=new H,lo=new H;class Fu{constructor(e=new H,t=new H){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Ou.subVectors(e,this.start),lo.subVectors(this.end,this.start);const n=lo.dot(lo);let i=lo.dot(Ou)/n;return t&&(i=Bt(i,0,1)),i}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}class Nu extends E{constructor(e){super(),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}Nu.prototype.isImmediateRenderObject=!0;const Bu=new H,Or=new H,co=new Dt,Al=new Dt;class zu extends xi{constructor(e){const t=ku(e),n=new Qt,i=[],r=[],a=new ut(0,0,1),l=new ut(0,1,0);for(let c=0;c<t.length;c++){const h=t[c];h.parent&&h.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(a.r,a.g,a.b),r.push(l.r,l.g,l.b))}n.setAttribute("position",new Ot(i,3)),n.setAttribute("color",new Ot(r,3)),super(n,new Kn({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");Al.copy(this.root.matrixWorld).invert();for(let r=0,a=0;r<t.length;r++){const l=t[r];l.parent&&l.parent.isBone&&(co.multiplyMatrices(Al,l.matrixWorld),Or.setFromMatrixPosition(co),i.setXYZ(a,Or.x,Or.y,Or.z),co.multiplyMatrices(Al,l.parent.matrixWorld),Or.setFromMatrixPosition(co),i.setXYZ(a+1,Or.x,Or.y,Or.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function ku(s){const e=[];s&&s.isBone&&e.push(s);for(let t=0;t<s.children.length;t++)e.push.apply(e,ku(s.children[t]));return e}const Np=new H,Uu=new ut,Hu=new ut;class Gu extends xi{constructor(e=10,t=10,n=4473924,i=8947848){n=new ut(n),i=new ut(i);const r=t/2,a=e/t,l=e/2,c=[],h=[];for(let p=0,f=0,m=-l;p<=t;p++,m+=a){c.push(-l,0,m,l,0,m),c.push(m,0,-l,m,0,l);const y=p===r?n:i;y.toArray(h,f),f+=3,y.toArray(h,f),f+=3,y.toArray(h,f),f+=3,y.toArray(h,f),f+=3}const d=new Qt;d.setAttribute("position",new Ot(c,3)),d.setAttribute("color",new Ot(h,3)),super(d,new Kn({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}const Vu=new H,uo=new H,Wu=new H,ho=new H,Bn=new Vs;function Hn(s,e,t,n,i,r,a){ho.set(i,r,a).unproject(n);const l=e[s];if(l!==void 0){const c=t.getAttribute("position");for(let h=0,d=l.length;h<d;h++)c.setXYZ(l[h],ho.x,ho.y,ho.z)}}const po=new qn;class ju extends xi{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new Qt;r.setIndex(new $t(n,1)),r.setAttribute("position",new $t(i,3)),super(r,new Kn({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&po.setFromObject(this.object),po.isEmpty())return;const t=po.min,n=po.max,i=this.geometry.attributes.position,r=i.array;r[0]=n.x,r[1]=n.y,r[2]=n.z,r[3]=t.x,r[4]=n.y,r[5]=n.z,r[6]=t.x,r[7]=t.y,r[8]=n.z,r[9]=n.x,r[10]=t.y,r[11]=n.z,r[12]=n.x,r[13]=n.y,r[14]=t.z,r[15]=t.x,r[16]=n.y,r[17]=t.z,r[18]=t.x,r[19]=t.y,r[20]=t.z,r[21]=n.x,r[22]=t.y,r[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return xi.prototype.copy.call(this,e),this.object=e.object,this}}const qu=new H;let fo,Ll;class Xu extends xi{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=new Qt;n.setAttribute("position",new Ot(t,3)),n.setAttribute("color",new Ot([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new Kn({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(e,t,n){const i=new ut,r=this.geometry.attributes.color.array;return i.set(e),i.toArray(r,0),i.toArray(r,3),i.set(t),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}const Zu=new Float32Array(1),Bp=new Int32Array(Zu.buffer);Ri.create=function(s,e){return console.log("THREE.Curve.create() has been deprecated"),s.prototype=Object.create(Ri.prototype),s.prototype.constructor=s,s.prototype.getPoint=e,s},da.prototype.fromPoints=function(s){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(s)},Gu.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},zu.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},hi.prototype.extractUrlBase=function(s){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),so.extractUrlBase(s)},hi.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},zs.prototype.center=function(s){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(s)},zs.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},zs.prototype.isIntersectionBox=function(s){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)},zs.prototype.size=function(s){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(s)},qn.prototype.center=function(s){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(s)},qn.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},qn.prototype.isIntersectionBox=function(s){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)},qn.prototype.isIntersectionSphere=function(s){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(s)},qn.prototype.size=function(s){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(s)},Si.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Ws.prototype.setFromMatrix=function(s){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(s)},Fu.prototype.center=function(s){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(s)},hn.prototype.flattenToArrayOffset=function(s,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(s,e)},hn.prototype.multiplyVector3=function(s){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),s.applyMatrix3(this)},hn.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},hn.prototype.applyToBufferAttribute=function(s){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),s.applyMatrix3(this)},hn.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},hn.prototype.getInverse=function(s){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(s).invert()},Dt.prototype.extractPosition=function(s){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(s)},Dt.prototype.flattenToArrayOffset=function(s,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(s,e)},Dt.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new H().setFromMatrixColumn(this,3)},Dt.prototype.setRotationFromQuaternion=function(s){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(s)},Dt.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Dt.prototype.multiplyVector3=function(s){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)},Dt.prototype.multiplyVector4=function(s){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)},Dt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Dt.prototype.rotateAxis=function(s){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),s.transformDirection(this)},Dt.prototype.crossVector=function(s){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)},Dt.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Dt.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Dt.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Dt.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Dt.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Dt.prototype.applyToBufferAttribute=function(s){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),s.applyMatrix4(this)},Dt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Dt.prototype.makeFrustum=function(s,e,t,n,i,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(s,e,n,t,i,r)},Dt.prototype.getInverse=function(s){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(s).invert()},nr.prototype.isIntersectionLine=function(s){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(s)},In.prototype.multiplyVector3=function(s){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),s.applyQuaternion(this)},In.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},Ti.prototype.isIntersectionBox=function(s){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(s)},Ti.prototype.isIntersectionPlane=function(s){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(s)},Ti.prototype.isIntersectionSphere=function(s){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(s)},Ke.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Ke.prototype.barycoordFromPoint=function(s,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(s,e)},Ke.prototype.midpoint=function(s){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(s)},Ke.prototypenormal=function(s){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(s)},Ke.prototype.plane=function(s){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(s)},Ke.barycoordFromPoint=function(s,e,t,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Ke.getBarycoord(s,e,t,n,i)},Ke.normal=function(s,e,t,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Ke.getNormal(s,e,t,n)},Dr.prototype.extractAllPoints=function(s){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(s)},Dr.prototype.extrude=function(s){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Vi(this,s)},Dr.prototype.makeGeometry=function(s){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Jr(this,s)},at.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)},at.prototype.distanceToManhattan=function(s){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(s)},at.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},H.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},H.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},H.prototype.getPositionFromMatrix=function(s){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(s)},H.prototype.getScaleFromMatrix=function(s){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(s)},H.prototype.getColumnFromMatrix=function(s,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,s)},H.prototype.applyProjection=function(s){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(s)},H.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)},H.prototype.distanceToManhattan=function(s){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(s)},H.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},en.prototype.fromAttribute=function(s,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(s,e,t)},en.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},E.prototype.getChildByName=function(s){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(s)},E.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},E.prototype.translate=function(s,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,s)},E.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},E.prototype.applyMatrix=function(s){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(s)},Object.defineProperties(E.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(s){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=s}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Vn.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(Vn.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),ka.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Jn.prototype.setLens=function(s,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(s)},Object.defineProperties(Xi.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(s){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=s}},shadowCameraLeft:{set:function(s){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=s}},shadowCameraRight:{set:function(s){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=s}},shadowCameraTop:{set:function(s){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=s}},shadowCameraBottom:{set:function(s){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=s}},shadowCameraNear:{set:function(s){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=s}},shadowCameraFar:{set:function(s){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=s}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(s){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=s}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(s){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=s}},shadowMapHeight:{set:function(s){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=s}}}),Object.defineProperties($t.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===35048},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),$t.prototype.setDynamic=function(s){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(s===!0?35048:35044),this},$t.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},$t.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Qt.prototype.addIndex=function(s){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(s)},Qt.prototype.addAttribute=function(s,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?s==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(s,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(s,new $t(arguments[1],arguments[2])))},Qt.prototype.addDrawCall=function(s,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(s,e)},Qt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},Qt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},Qt.prototype.removeAttribute=function(s){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(s)},Qt.prototype.applyMatrix=function(s){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(s)},Object.defineProperties(Qt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),jr.prototype.setDynamic=function(s){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(s===!0?35048:35044),this},jr.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Vi.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},Vi.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},Vi.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},Ia.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},oo.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(We.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new ut}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(s){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=s===1}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(s){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=s}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(mr.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(s){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=s}}}),En.prototype.clearTarget=function(s,e,t,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(s),this.clear(e,t,n)},En.prototype.animate=function(s){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(s)},En.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},En.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},En.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},En.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},En.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},En.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},En.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},En.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},En.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},En.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},En.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},En.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},En.prototype.enableScissorTest=function(s){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(s)},En.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},En.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},En.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},En.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},En.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},En.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},En.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},En.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},En.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},En.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(En.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(s){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=s}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(s){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=s}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(s){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=s===!0?3001:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(mc.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(Nn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(s){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=s}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(s){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=s}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(s){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=s}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(s){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=s}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(s){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=s}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(s){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=s}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(s){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=s}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(s){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=s}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(s){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=s}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(s){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=s}}}),Sl.prototype.load=function(s){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new yu().load(s,function(t){e.setBuffer(t)}),this},Eu.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},Sa.prototype.updateCubeMap=function(s,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(s,e)},Sa.prototype.clear=function(s,e,t,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(s,e,t,n)},Wn.crossOrigin=void 0,Wn.loadTexture=function(s,e,t,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new nu;i.setCrossOrigin(this.crossOrigin);const r=i.load(s,t,void 0,n);return e&&(r.mapping=e),r},Wn.loadTextureCube=function(s,e,t,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new eu;i.setCrossOrigin(this.crossOrigin);const r=i.load(s,t,void 0,n);return e&&(r.mapping=e),r},Wn.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Wn.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const zp={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:me}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=me),u.ACESFilmicToneMapping=4,u.AddEquation=100,u.AddOperation=2,u.AdditiveAnimationBlendMode=2501,u.AdditiveBlending=2,u.AlphaFormat=1021,u.AlwaysDepth=1,u.AlwaysStencilFunc=519,u.AmbientLight=vl,u.AmbientLightProbe=xu,u.AnimationClip=ua,u.AnimationLoader=class extends hi{constructor(s){super(s)}load(s,e,t,n){const i=this,r=new qi(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(s,function(a){try{e(i.parse(JSON.parse(a)))}catch(l){n?n(l):console.error(l),i.manager.itemError(s)}},t,n)}parse(s){const e=[];for(let t=0;t<s.length;t++){const n=ua.parse(s[t]);e.push(n)}return e}},u.AnimationMixer=Ru,u.AnimationObjectGroup=Lu,u.AnimationUtils=Pn,u.ArcCurve=Vo,u.ArrayCamera=Do,u.ArrowHelper=class extends E{constructor(s=new H(0,0,1),e=new H(0,0,0),t=1,n=16776960,i=.2*t,r=.2*i){super(),this.type="ArrowHelper",fo===void 0&&(fo=new Qt,fo.setAttribute("position",new Ot([0,0,0,0,1,0],3)),Ll=new Pr(0,.5,1,5,1),Ll.translate(0,-.5,0)),this.position.copy(e),this.line=new gr(fo,new Kn({color:n,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Vn(Ll,new _n({color:n,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(s),this.setLength(t,i,r)}setDirection(s){if(s.y>.99999)this.quaternion.set(0,0,0,1);else if(s.y<-.99999)this.quaternion.set(1,0,0,0);else{qu.set(s.z,0,-s.x).normalize();const e=Math.acos(s.y);this.quaternion.setFromAxisAngle(qu,e)}}setLength(s,e=.2*s,t=.2*e){this.line.scale.set(1,Math.max(1e-4,s-e),1),this.line.updateMatrix(),this.cone.scale.set(t,e,t),this.cone.position.y=s,this.cone.updateMatrix()}setColor(s){this.line.material.color.set(s),this.cone.material.color.set(s)}copy(s){return super.copy(s,!1),this.line.copy(s.line),this.cone.copy(s.cone),this}},u.Audio=Sl,u.AudioAnalyser=Eu,u.AudioContext=Ml,u.AudioListener=class extends E{constructor(){super(),this.type="AudioListener",this.context=Ml.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new _u}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(s){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=s,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(s){return this.gain.gain.setTargetAtTime(s,this.context.currentTime,.01),this}updateMatrixWorld(s){super.updateMatrixWorld(s);const e=this.context.listener,t=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(ts,Su,Sp),ns.set(0,0,-1).applyQuaternion(Su),e.positionX){const n=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(ts.x,n),e.positionY.linearRampToValueAtTime(ts.y,n),e.positionZ.linearRampToValueAtTime(ts.z,n),e.forwardX.linearRampToValueAtTime(ns.x,n),e.forwardY.linearRampToValueAtTime(ns.y,n),e.forwardZ.linearRampToValueAtTime(ns.z,n),e.upX.linearRampToValueAtTime(t.x,n),e.upY.linearRampToValueAtTime(t.y,n),e.upZ.linearRampToValueAtTime(t.z,n)}else e.setPosition(ts.x,ts.y,ts.z),e.setOrientation(ns.x,ns.y,ns.z,t.x,t.y,t.z)}},u.AudioLoader=yu,u.AxesHelper=Xu,u.AxisHelper=function(s){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Xu(s)},u.BackSide=1,u.BasicDepthPacking=3200,u.BasicShadowMap=0,u.BinaryTextureLoader=function(s){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new tu(s)},u.Bone=Ua,u.BooleanKeyframeTrack=Qr,u.BoundingBoxHelper=function(s,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new ju(s,e)},u.Box2=zs,u.Box3=qn,u.Box3Helper=class extends xi{constructor(s,e=16776960){const t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Qt;n.setIndex(new $t(t,1)),n.setAttribute("position",new Ot([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(n,new Kn({color:e,toneMapped:!1})),this.box=s,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(s){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(s))}},u.BoxBufferGeometry=fr,u.BoxGeometry=fr,u.BoxHelper=ju,u.BufferAttribute=$t,u.BufferGeometry=Qt,u.BufferGeometryLoader=du,u.ByteType=1010,u.Cache=es,u.Camera=Vs,u.CameraHelper=class extends xi{constructor(s){const e=new Qt,t=new Kn({color:16777215,vertexColors:!0,toneMapped:!1}),n=[],i=[],r={},a=new ut(16755200),l=new ut(16711680),c=new ut(43775),h=new ut(16777215),d=new ut(3355443);function p(m,y,b){f(m,b),f(y,b)}function f(m,y){n.push(0,0,0),i.push(y.r,y.g,y.b),r[m]===void 0&&(r[m]=[]),r[m].push(n.length/3-1)}p("n1","n2",a),p("n2","n4",a),p("n4","n3",a),p("n3","n1",a),p("f1","f2",a),p("f2","f4",a),p("f4","f3",a),p("f3","f1",a),p("n1","f1",a),p("n2","f2",a),p("n3","f3",a),p("n4","f4",a),p("p","n1",l),p("p","n2",l),p("p","n3",l),p("p","n4",l),p("u1","u2",c),p("u2","u3",c),p("u3","u1",c),p("c","t",h),p("p","c",d),p("cn1","cn2",d),p("cn3","cn4",d),p("cf1","cf2",d),p("cf3","cf4",d),e.setAttribute("position",new Ot(n,3)),e.setAttribute("color",new Ot(i,3)),super(e,t),this.type="CameraHelper",this.camera=s,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=s.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=r,this.update()}update(){const s=this.geometry,e=this.pointMap;Bn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Hn("c",e,s,Bn,0,0,-1),Hn("t",e,s,Bn,0,0,1),Hn("n1",e,s,Bn,-1,-1,-1),Hn("n2",e,s,Bn,1,-1,-1),Hn("n3",e,s,Bn,-1,1,-1),Hn("n4",e,s,Bn,1,1,-1),Hn("f1",e,s,Bn,-1,-1,1),Hn("f2",e,s,Bn,1,-1,1),Hn("f3",e,s,Bn,-1,1,1),Hn("f4",e,s,Bn,1,1,1),Hn("u1",e,s,Bn,.7,1.1,-1),Hn("u2",e,s,Bn,-.7,1.1,-1),Hn("u3",e,s,Bn,0,2,-1),Hn("cf1",e,s,Bn,-1,0,1),Hn("cf2",e,s,Bn,1,0,1),Hn("cf3",e,s,Bn,0,-1,1),Hn("cf4",e,s,Bn,0,1,1),Hn("cn1",e,s,Bn,-1,0,-1),Hn("cn2",e,s,Bn,1,0,-1),Hn("cn3",e,s,Bn,0,-1,-1),Hn("cn4",e,s,Bn,0,1,-1),s.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},u.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been removed")},u.CanvasTexture=zc,u.CatmullRomCurve3=Zo,u.CineonToneMapping=3,u.CircleBufferGeometry=Es,u.CircleGeometry=Es,u.ClampToEdgeWrapping=1001,u.Clock=_u,u.Color=ut,u.ColorKeyframeTrack=ul,u.CompressedTexture=Uo,u.CompressedTextureLoader=class extends hi{constructor(s){super(s)}load(s,e,t,n){const i=this,r=[],a=new Uo,l=new qi(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(i.withCredentials);let c=0;function h(d){l.load(s[d],function(p){const f=i.parse(p,!0);r[d]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},c+=1,c===6&&(f.mipmapCount===1&&(a.minFilter=1006),a.image=r,a.format=f.format,a.needsUpdate=!0,e&&e(a))},t,n)}if(Array.isArray(s))for(let d=0,p=s.length;d<p;++d)h(d);else l.load(s,function(d){const p=i.parse(d,!0);if(p.isCubemap){const f=p.mipmaps.length/p.mipmapCount;for(let m=0;m<f;m++){r[m]={mipmaps:[]};for(let y=0;y<p.mipmapCount;y++)r[m].mipmaps.push(p.mipmaps[m*p.mipmapCount+y]),r[m].format=p.format,r[m].width=p.width,r[m].height=p.height}a.image=r}else a.image.width=p.width,a.image.height=p.height,a.mipmaps=p.mipmaps;p.mipmapCount===1&&(a.minFilter=1006),a.format=p.format,a.needsUpdate=!0,e&&e(a)},t,n);return a}},u.ConeBufferGeometry=As,u.ConeGeometry=As,u.CubeCamera=Sa,u.CubeReflectionMapping=301,u.CubeRefractionMapping=302,u.CubeTexture=gs,u.CubeTextureLoader=eu,u.CubeUVReflectionMapping=306,u.CubeUVRefractionMapping=307,u.CubicBezierCurve=Ja,u.CubicBezierCurve3=Yo,u.CubicInterpolant=Jc,u.CullFaceBack=1,u.CullFaceFront=2,u.CullFaceFrontBack=3,u.CullFaceNone=0,u.Curve=Ri,u.CurvePath=iu,u.CustomBlending=5,u.CustomToneMapping=5,u.CylinderBufferGeometry=Pr,u.CylinderGeometry=Pr,u.Cylindrical=class{constructor(s=1,e=0,t=0){return this.radius=s,this.theta=e,this.y=t,this}set(s,e,t){return this.radius=s,this.theta=e,this.y=t,this}copy(s){return this.radius=s.radius,this.theta=s.theta,this.y=s.y,this}setFromVector3(s){return this.setFromCartesianCoords(s.x,s.y,s.z)}setFromCartesianCoords(s,e,t){return this.radius=Math.sqrt(s*s+t*t),this.theta=Math.atan2(s,t),this.y=e,this}clone(){return new this.constructor().copy(this)}},u.DataTexture=qr,u.DataTexture2DArray=Ro,u.DataTexture3D=Co,u.DataTextureLoader=tu,u.DataUtils=class{static toHalfFloat(s){Zu[0]=s;const e=Bp[0];let t=e>>16&32768,n=e>>12&2047;const i=e>>23&255;return i<103?t:i>142?(t|=31744,t|=(i==255?0:1)&&8388607&e,t):i<113?(n|=2048,t|=(n>>114-i)+(n>>113-i&1),t):(t|=i-112<<10|n>>1,t+=1&n,t)}},u.DecrementStencilOp=7683,u.DecrementWrapStencilOp=34056,u.DefaultLoadingManager=$c,u.DepthFormat=1026,u.DepthStencilFormat=1027,u.DepthTexture=kc,u.DirectionalLight=yl,u.DirectionalLightHelper=class extends E{constructor(s,e,t){super(),this.light=s,this.light.updateMatrixWorld(),this.matrix=s.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,e===void 0&&(e=1);let n=new Qt;n.setAttribute("position",new Ot([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const i=new Kn({fog:!1,toneMapped:!1});this.lightPlane=new gr(n,i),this.add(this.lightPlane),n=new Qt,n.setAttribute("position",new Ot([0,0,0,0,0,1],3)),this.targetLine=new gr(n,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Vu.setFromMatrixPosition(this.light.matrixWorld),uo.setFromMatrixPosition(this.light.target.matrixWorld),Wu.subVectors(uo,Vu),this.lightPlane.lookAt(uo),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(uo),this.targetLine.scale.z=Wu.length()}},u.DiscreteInterpolant=Kc,u.DodecahedronBufferGeometry=Ls,u.DodecahedronGeometry=Ls,u.DoubleSide=2,u.DstAlphaFactor=206,u.DstColorFactor=208,u.DynamicBufferAttribute=function(s,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new $t(s,e).setUsage(35048)},u.DynamicCopyUsage=35050,u.DynamicDrawUsage=35048,u.DynamicReadUsage=35049,u.EdgesGeometry=Go,u.EdgesHelper=function(s,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new xi(new Go(s.geometry),new Kn({color:e!==void 0?e:16777215}))},u.EllipseCurve=ta,u.EqualDepth=4,u.EqualStencilFunc=514,u.EquirectangularReflectionMapping=303,u.EquirectangularRefractionMapping=304,u.Euler=Hi,u.EventDispatcher=Re,u.ExtrudeBufferGeometry=Vi,u.ExtrudeGeometry=Vi,u.FaceColors=1,u.FileLoader=qi,u.FlatShading=1,u.Float16BufferAttribute=Hr,u.Float32Attribute=function(s,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Ot(s,e)},u.Float32BufferAttribute=Ot,u.Float64Attribute=function(s,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new dr(s,e)},u.Float64BufferAttribute=dr,u.FloatType=1015,u.Fog=Ys,u.FogExp2=Zs,u.Font=_l,u.FontLoader=class extends hi{constructor(s){super(s)}load(s,e,t,n){const i=this,r=new qi(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(i.withCredentials),r.load(s,function(a){let l;try{l=JSON.parse(a)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),l=JSON.parse(a.substring(65,a.length-2))}const c=i.parse(l);e&&e(c)},t,n)}parse(s){return new _l(s)}},u.FrontSide=0,u.Frustum=Ws,u.GLBufferAttribute=Pu,u.GLSL1="100",u.GLSL3=he,u.GammaEncoding=3007,u.GreaterDepth=6,u.GreaterEqualDepth=5,u.GreaterEqualStencilFunc=518,u.GreaterStencilFunc=516,u.GridHelper=Gu,u.Group=Wr,u.HalfFloatType=1016,u.HemisphereLight=dl,u.HemisphereLightHelper=class extends E{constructor(s,e,t){super(),this.light=s,this.light.updateMatrixWorld(),this.matrix=s.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const n=new Yr(e);n.rotateY(.5*Math.PI),this.material=new _n({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=n.getAttribute("position"),r=new Float32Array(3*i.count);n.setAttribute("color",new $t(r,3)),this.add(new Vn(n,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const s=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const e=s.geometry.getAttribute("color");Uu.copy(this.light.color),Hu.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const i=t<n/2?Uu:Hu;e.setXYZ(t,i.r,i.g,i.b)}e.needsUpdate=!0}s.lookAt(Np.setFromMatrixPosition(this.light.matrixWorld).negate())}},u.HemisphereLightProbe=vu,u.IcosahedronBufferGeometry=Cs,u.IcosahedronGeometry=Cs,u.ImageBitmapLoader=mu,u.ImageLoader=ha,u.ImageUtils=Wn,u.ImmediateRenderObject=Nu,u.IncrementStencilOp=7682,u.IncrementWrapStencilOp=34055,u.InstancedBufferAttribute=Xr,u.InstancedBufferGeometry=wl,u.InstancedInterleavedBuffer=Cu,u.InstancedMesh=No,u.Int16Attribute=function(s,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new Bi(s,e)},u.Int16BufferAttribute=Bi,u.Int32Attribute=function(s,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new ri(s,e)},u.Int32BufferAttribute=ri,u.Int8Attribute=function(s,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new fi(s,e)},u.Int8BufferAttribute=fi,u.IntType=1013,u.InterleavedBuffer=jr,u.InterleavedBufferAttribute=Cr,u.Interpolant=yr,u.InterpolateDiscrete=2300,u.InterpolateLinear=2301,u.InterpolateSmooth=2302,u.InvertStencilOp=5386,u.JSONLoader=function(){console.error("THREE.JSONLoader has been removed.")},u.KeepStencilOp=7680,u.KeyframeTrack=Wi,u.LOD=_c,u.LatheBufferGeometry=Ps,u.LatheGeometry=Ps,u.Layers=Sr,u.LensFlare=function(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")},u.LessDepth=2,u.LessEqualDepth=3,u.LessEqualStencilFunc=515,u.LessStencilFunc=513,u.Light=Xi,u.LightProbe=fa,u.Line=gr,u.Line3=Fu,u.LineBasicMaterial=Kn,u.LineCurve=ra,u.LineCurve3=Hc,u.LineDashedMaterial=ll,u.LineLoop=zo,u.LinePieces=1,u.LineSegments=xi,u.LineStrip=0,u.LinearEncoding=3e3,u.LinearFilter=1006,u.LinearInterpolant=cl,u.LinearMipMapLinearFilter=1008,u.LinearMipMapNearestFilter=1007,u.LinearMipmapLinearFilter=1008,u.LinearMipmapNearestFilter=1007,u.LinearToneMapping=1,u.Loader=hi,u.LoaderUtils=so,u.LoadingManager=hl,u.LogLuvEncoding=3003,u.LoopOnce=2200,u.LoopPingPong=2202,u.LoopRepeat=2201,u.LuminanceAlphaFormat=1025,u.LuminanceFormat=1024,u.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},u.Material=We,u.MaterialLoader=hu,u.Math=ni,u.MathUtils=ni,u.Matrix3=hn,u.Matrix4=Dt,u.MaxEquation=104,u.Mesh=Vn,u.MeshBasicMaterial=_n,u.MeshDepthMaterial=Ca,u.MeshDistanceMaterial=Pa,u.MeshFaceMaterial=function(s){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),s},u.MeshLambertMaterial=al,u.MeshMatcapMaterial=ol,u.MeshNormalMaterial=sl,u.MeshPhongMaterial=il,u.MeshPhysicalMaterial=nl,u.MeshStandardMaterial=ro,u.MeshToonMaterial=rl,u.MinEquation=103,u.MirroredRepeatWrapping=1002,u.MixOperation=1,u.MultiMaterial=function(s=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),s.isMultiMaterial=!0,s.materials=s,s.clone=function(){return s.slice()},s},u.MultiplyBlending=4,u.MultiplyOperation=0,u.NearestFilter=1003,u.NearestMipMapLinearFilter=1005,u.NearestMipMapNearestFilter=1004,u.NearestMipmapLinearFilter=1005,u.NearestMipmapNearestFilter=1004,u.NeverDepth=0,u.NeverStencilFunc=512,u.NoBlending=0,u.NoColors=0,u.NoToneMapping=0,u.NormalAnimationBlendMode=2500,u.NormalBlending=1,u.NotEqualDepth=7,u.NotEqualStencilFunc=517,u.NumberKeyframeTrack=la,u.Object3D=E,u.ObjectLoader=class extends hi{constructor(s){super(s)}load(s,e,t,n){const i=this,r=this.path===""?so.extractUrlBase(s):this.path;this.resourcePath=this.resourcePath||r;const a=new qi(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(s,function(l){let c=null;try{c=JSON.parse(l)}catch(d){return n!==void 0&&n(d),void console.error("THREE:ObjectLoader: Can't parse "+s+".",d.message)}const h=c.metadata;h!==void 0&&h.type!==void 0&&h.type.toLowerCase()!=="geometry"?i.parse(c,e):console.error("THREE.ObjectLoader: Can't load "+s)},t,n)}async loadAsync(s,e){const t=this.path===""?so.extractUrlBase(s):this.path;this.resourcePath=this.resourcePath||t;const n=new qi(this.manager);n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials);const i=await n.loadAsync(s,e),r=JSON.parse(i),a=r.metadata;if(a===void 0||a.type===void 0||a.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+s);return await this.parseAsync(r)}parse(s,e){const t=this.parseAnimations(s.animations),n=this.parseShapes(s.shapes),i=this.parseGeometries(s.geometries,n),r=this.parseImages(s.images,function(){e!==void 0&&e(c)}),a=this.parseTextures(s.textures,r),l=this.parseMaterials(s.materials,a),c=this.parseObject(s.object,i,l,a,t),h=this.parseSkeletons(s.skeletons,c);if(this.bindSkeletons(c,h),e!==void 0){let d=!1;for(const p in r)if(r[p]instanceof HTMLImageElement){d=!0;break}d===!1&&e(c)}return c}async parseAsync(s){const e=this.parseAnimations(s.animations),t=this.parseShapes(s.shapes),n=this.parseGeometries(s.geometries,t),i=await this.parseImagesAsync(s.images),r=this.parseTextures(s.textures,i),a=this.parseMaterials(s.materials,r),l=this.parseObject(s.object,n,a,r,e),c=this.parseSkeletons(s.skeletons,l);return this.bindSkeletons(l,c),l}parseShapes(s){const e={};if(s!==void 0)for(let t=0,n=s.length;t<n;t++){const i=new Dr().fromJSON(s[t]);e[i.uuid]=i}return e}parseSkeletons(s,e){const t={},n={};if(e.traverse(function(i){i.isBone&&(n[i.uuid]=i)}),s!==void 0)for(let i=0,r=s.length;i<r;i++){const a=new Ha().fromJSON(s[i],n);t[a.uuid]=a}return t}parseGeometries(s,e){const t={};if(s!==void 0){const n=new du;for(let i=0,r=s.length;i<r;i++){let a;const l=s[i];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=n.parse(l);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:l.type in Yc?a=Yc[l.type].fromJSON(l,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),a.isBufferGeometry===!0&&l.userData!==void 0&&(a.userData=l.userData),t[l.uuid]=a}}return t}parseMaterials(s,e){const t={},n={};if(s!==void 0){const i=new hu;i.setTextures(e);for(let r=0,a=s.length;r<a;r++){const l=s[r];if(l.type==="MultiMaterial"){const c=[];for(let h=0;h<l.materials.length;h++){const d=l.materials[h];t[d.uuid]===void 0&&(t[d.uuid]=i.parse(d)),c.push(t[d.uuid])}n[l.uuid]=c}else t[l.uuid]===void 0&&(t[l.uuid]=i.parse(l)),n[l.uuid]=t[l.uuid]}}return n}parseAnimations(s){const e={};if(s!==void 0)for(let t=0;t<s.length;t++){const n=s[t],i=ua.parse(n);e[i.uuid]=i}return e}parseImages(s,e){const t=this,n={};let i;function r(a){if(typeof a=="string"){const l=a;return function(c){return t.manager.itemStart(c),i.load(c,function(){t.manager.itemEnd(c)},void 0,function(){t.manager.itemError(c),t.manager.itemEnd(c)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(l)?l:t.resourcePath+l)}return a.data?{data:pr(a.type,a.data),width:a.width,height:a.height}:null}if(s!==void 0&&s.length>0){const a=new hl(e);i=new ha(a),i.setCrossOrigin(this.crossOrigin);for(let l=0,c=s.length;l<c;l++){const h=s[l],d=h.url;if(Array.isArray(d)){n[h.uuid]=[];for(let p=0,f=d.length;p<f;p++){const m=r(d[p]);m!==null&&(m instanceof HTMLImageElement?n[h.uuid].push(m):n[h.uuid].push(new qr(m.data,m.width,m.height)))}}else{const p=r(h.url);p!==null&&(n[h.uuid]=p)}}}return n}async parseImagesAsync(s){const e=this,t={};let n;async function i(r){if(typeof r=="string"){const a=r,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:e.resourcePath+a;return await n.loadAsync(l)}return r.data?{data:pr(r.type,r.data),width:r.width,height:r.height}:null}if(s!==void 0&&s.length>0){n=new ha(this.manager),n.setCrossOrigin(this.crossOrigin);for(let r=0,a=s.length;r<a;r++){const l=s[r],c=l.url;if(Array.isArray(c)){t[l.uuid]=[];for(let h=0,d=c.length;h<d;h++){const p=c[h],f=await i(p);f!==null&&(f instanceof HTMLImageElement?t[l.uuid].push(f):t[l.uuid].push(new qr(f.data,f.width,f.height)))}}else{const h=await i(l.url);h!==null&&(t[l.uuid]=h)}}}return t}parseTextures(s,e){function t(i,r){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),r[i])}const n={};if(s!==void 0)for(let i=0,r=s.length;i<r;i++){const a=s[i];let l;a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),e[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const c=e[a.image];Array.isArray(c)?(l=new gs(c),c.length===6&&(l.needsUpdate=!0)):(l=c&&c.data?new qr(c.data,c.width,c.height):new wn(c),c&&(l.needsUpdate=!0)),l.uuid=a.uuid,a.name!==void 0&&(l.name=a.name),a.mapping!==void 0&&(l.mapping=t(a.mapping,_p)),a.offset!==void 0&&l.offset.fromArray(a.offset),a.repeat!==void 0&&l.repeat.fromArray(a.repeat),a.center!==void 0&&l.center.fromArray(a.center),a.rotation!==void 0&&(l.rotation=a.rotation),a.wrap!==void 0&&(l.wrapS=t(a.wrap[0],pu),l.wrapT=t(a.wrap[1],pu)),a.format!==void 0&&(l.format=a.format),a.type!==void 0&&(l.type=a.type),a.encoding!==void 0&&(l.encoding=a.encoding),a.minFilter!==void 0&&(l.minFilter=t(a.minFilter,fu)),a.magFilter!==void 0&&(l.magFilter=t(a.magFilter,fu)),a.anisotropy!==void 0&&(l.anisotropy=a.anisotropy),a.flipY!==void 0&&(l.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(l.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(l.unpackAlignment=a.unpackAlignment),n[a.uuid]=l}return n}parseObject(s,e,t,n,i){let r,a,l;function c(p){return e[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",p),e[p]}function h(p){if(p!==void 0){if(Array.isArray(p)){const f=[];for(let m=0,y=p.length;m<y;m++){const b=p[m];t[b]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",b),f.push(t[b])}return f}return t[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),t[p]}}function d(p){return n[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",p),n[p]}switch(s.type){case"Scene":r=new Ia,s.background!==void 0&&(Number.isInteger(s.background)?r.background=new ut(s.background):r.background=d(s.background)),s.environment!==void 0&&(r.environment=d(s.environment)),s.fog!==void 0&&(s.fog.type==="Fog"?r.fog=new Ys(s.fog.color,s.fog.near,s.fog.far):s.fog.type==="FogExp2"&&(r.fog=new Zs(s.fog.color,s.fog.density)));break;case"PerspectiveCamera":r=new Jn(s.fov,s.aspect,s.near,s.far),s.focus!==void 0&&(r.focus=s.focus),s.zoom!==void 0&&(r.zoom=s.zoom),s.filmGauge!==void 0&&(r.filmGauge=s.filmGauge),s.filmOffset!==void 0&&(r.filmOffset=s.filmOffset),s.view!==void 0&&(r.view=Object.assign({},s.view));break;case"OrthographicCamera":r=new js(s.left,s.right,s.top,s.bottom,s.near,s.far),s.zoom!==void 0&&(r.zoom=s.zoom),s.view!==void 0&&(r.view=Object.assign({},s.view));break;case"AmbientLight":r=new vl(s.color,s.intensity);break;case"DirectionalLight":r=new yl(s.color,s.intensity);break;case"PointLight":r=new gl(s.color,s.intensity,s.distance,s.decay);break;case"RectAreaLight":r=new xl(s.color,s.intensity,s.width,s.height);break;case"SpotLight":r=new fl(s.color,s.intensity,s.distance,s.angle,s.penumbra,s.decay);break;case"HemisphereLight":r=new dl(s.color,s.groundColor,s.intensity);break;case"LightProbe":r=new fa().fromJSON(s);break;case"SkinnedMesh":a=c(s.geometry),l=h(s.material),r=new ka(a,l),s.bindMode!==void 0&&(r.bindMode=s.bindMode),s.bindMatrix!==void 0&&r.bindMatrix.fromArray(s.bindMatrix),s.skeleton!==void 0&&(r.skeleton=s.skeleton);break;case"Mesh":a=c(s.geometry),l=h(s.material),r=new Vn(a,l);break;case"InstancedMesh":a=c(s.geometry),l=h(s.material);const p=s.count,f=s.instanceMatrix,m=s.instanceColor;r=new No(a,l,p),r.instanceMatrix=new Xr(new Float32Array(f.array),16),m!==void 0&&(r.instanceColor=new Xr(new Float32Array(m.array),m.itemSize));break;case"LOD":r=new _c;break;case"Line":r=new gr(c(s.geometry),h(s.material));break;case"LineLoop":r=new zo(c(s.geometry),h(s.material));break;case"LineSegments":r=new xi(c(s.geometry),h(s.material));break;case"PointCloud":case"Points":r=new ea(c(s.geometry),h(s.material));break;case"Sprite":r=new Na(h(s.material));break;case"Group":r=new Wr;break;case"Bone":r=new Ua;break;default:r=new E}if(r.uuid=s.uuid,s.name!==void 0&&(r.name=s.name),s.matrix!==void 0?(r.matrix.fromArray(s.matrix),s.matrixAutoUpdate!==void 0&&(r.matrixAutoUpdate=s.matrixAutoUpdate),r.matrixAutoUpdate&&r.matrix.decompose(r.position,r.quaternion,r.scale)):(s.position!==void 0&&r.position.fromArray(s.position),s.rotation!==void 0&&r.rotation.fromArray(s.rotation),s.quaternion!==void 0&&r.quaternion.fromArray(s.quaternion),s.scale!==void 0&&r.scale.fromArray(s.scale)),s.castShadow!==void 0&&(r.castShadow=s.castShadow),s.receiveShadow!==void 0&&(r.receiveShadow=s.receiveShadow),s.shadow&&(s.shadow.bias!==void 0&&(r.shadow.bias=s.shadow.bias),s.shadow.normalBias!==void 0&&(r.shadow.normalBias=s.shadow.normalBias),s.shadow.radius!==void 0&&(r.shadow.radius=s.shadow.radius),s.shadow.mapSize!==void 0&&r.shadow.mapSize.fromArray(s.shadow.mapSize),s.shadow.camera!==void 0&&(r.shadow.camera=this.parseObject(s.shadow.camera))),s.visible!==void 0&&(r.visible=s.visible),s.frustumCulled!==void 0&&(r.frustumCulled=s.frustumCulled),s.renderOrder!==void 0&&(r.renderOrder=s.renderOrder),s.userData!==void 0&&(r.userData=s.userData),s.layers!==void 0&&(r.layers.mask=s.layers),s.children!==void 0){const p=s.children;for(let f=0;f<p.length;f++)r.add(this.parseObject(p[f],e,t,n,i))}if(s.animations!==void 0){const p=s.animations;for(let f=0;f<p.length;f++){const m=p[f];r.animations.push(i[m])}}if(s.type==="LOD"){s.autoUpdate!==void 0&&(r.autoUpdate=s.autoUpdate);const p=s.levels;for(let f=0;f<p.length;f++){const m=p[f],y=r.getObjectByProperty("uuid",m.object);y!==void 0&&r.addLevel(y,m.distance)}}return r}bindSkeletons(s,e){Object.keys(e).length!==0&&s.traverse(function(t){if(t.isSkinnedMesh===!0&&t.skeleton!==void 0){const n=e[t.skeleton];n===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}})}setTexturePath(s){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(s)}},u.ObjectSpaceNormalMap=1,u.OctahedronBufferGeometry=Yr,u.OctahedronGeometry=Yr,u.OneFactor=201,u.OneMinusDstAlphaFactor=207,u.OneMinusDstColorFactor=209,u.OneMinusSrcAlphaFactor=205,u.OneMinusSrcColorFactor=203,u.OrthographicCamera=js,u.PCFShadowMap=1,u.PCFSoftShadowMap=2,u.PMREMGenerator=Vl,u.ParametricBufferGeometry=no,u.ParametricGeometry=no,u.Particle=function(s){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new Na(s)},u.ParticleBasicMaterial=function(s){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Zr(s)},u.ParticleSystem=function(s,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new ea(s,e)},u.ParticleSystemMaterial=function(s){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Zr(s)},u.Path=da,u.PerspectiveCamera=Jn,u.Plane=nr,u.PlaneBufferGeometry=Gr,u.PlaneGeometry=Gr,u.PlaneHelper=class extends gr{constructor(s,e=1,t=16776960){const n=t,i=new Qt;i.setAttribute("position",new Ot([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),i.computeBoundingSphere(),super(i,new Kn({color:n,toneMapped:!1})),this.type="PlaneHelper",this.plane=s,this.size=e;const r=new Qt;r.setAttribute("position",new Ot([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),r.computeBoundingSphere(),this.add(new Vn(r,new _n({color:n,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(s){let e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?1:0,this.lookAt(this.plane.normal),super.updateMatrixWorld(s)}},u.PointCloud=function(s,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new ea(s,e)},u.PointCloudMaterial=function(s){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Zr(s)},u.PointLight=gl,u.PointLightHelper=class extends Vn{constructor(s,e,t){super(new Kr(e,4,2),new _n({wireframe:!0,fog:!1,toneMapped:!1})),this.light=s,this.light.updateMatrixWorld(),this.color=t,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},u.Points=ea,u.PointsMaterial=Zr,u.PolarGridHelper=class extends xi{constructor(s=10,e=16,t=8,n=64,i=4473924,r=8947848){i=new ut(i),r=new ut(r);const a=[],l=[];for(let h=0;h<=e;h++){const d=h/e*(2*Math.PI),p=Math.sin(d)*s,f=Math.cos(d)*s;a.push(0,0,0),a.push(p,0,f);const m=1&h?i:r;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let h=0;h<=t;h++){const d=1&h?i:r,p=s-s/t*h;for(let f=0;f<n;f++){let m=f/n*(2*Math.PI),y=Math.sin(m)*p,b=Math.cos(m)*p;a.push(y,0,b),l.push(d.r,d.g,d.b),m=(f+1)/n*(2*Math.PI),y=Math.sin(m)*p,b=Math.cos(m)*p,a.push(y,0,b),l.push(d.r,d.g,d.b)}}const c=new Qt;c.setAttribute("position",new Ot(a,3)),c.setAttribute("color",new Ot(l,3)),super(c,new Kn({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}},u.PolyhedronBufferGeometry=sr,u.PolyhedronGeometry=sr,u.PositionalAudio=class extends Sl{constructor(s){super(s),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(s){return this.panner.refDistance=s,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(s){return this.panner.rolloffFactor=s,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(s){return this.panner.distanceModel=s,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(s){return this.panner.maxDistance=s,this}setDirectionalCone(s,e,t){return this.panner.coneInnerAngle=s,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=t,this}updateMatrixWorld(s){if(super.updateMatrixWorld(s),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(is,Tu,Tp),rs.set(0,0,1).applyQuaternion(Tu);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(is.x,t),e.positionY.linearRampToValueAtTime(is.y,t),e.positionZ.linearRampToValueAtTime(is.z,t),e.orientationX.linearRampToValueAtTime(rs.x,t),e.orientationY.linearRampToValueAtTime(rs.y,t),e.orientationZ.linearRampToValueAtTime(rs.z,t)}else e.setPosition(is.x,is.y,is.z),e.setOrientation(rs.x,rs.y,rs.z)}},u.PropertyBinding=vn,u.PropertyMixer=Au,u.QuadraticBezierCurve=Ka,u.QuadraticBezierCurve3=Jo,u.Quaternion=In,u.QuaternionKeyframeTrack=Bs,u.QuaternionLinearInterpolant=Qc,u.REVISION=me,u.RGBADepthPacking=3201,u.RGBAFormat=1023,u.RGBAIntegerFormat=1033,u.RGBA_ASTC_10x10_Format=37819,u.RGBA_ASTC_10x5_Format=37816,u.RGBA_ASTC_10x6_Format=37817,u.RGBA_ASTC_10x8_Format=37818,u.RGBA_ASTC_12x10_Format=37820,u.RGBA_ASTC_12x12_Format=37821,u.RGBA_ASTC_4x4_Format=37808,u.RGBA_ASTC_5x4_Format=37809,u.RGBA_ASTC_5x5_Format=37810,u.RGBA_ASTC_6x5_Format=37811,u.RGBA_ASTC_6x6_Format=37812,u.RGBA_ASTC_8x5_Format=37813,u.RGBA_ASTC_8x6_Format=37814,u.RGBA_ASTC_8x8_Format=37815,u.RGBA_BPTC_Format=36492,u.RGBA_ETC2_EAC_Format=37496,u.RGBA_PVRTC_2BPPV1_Format=35843,u.RGBA_PVRTC_4BPPV1_Format=35842,u.RGBA_S3TC_DXT1_Format=33777,u.RGBA_S3TC_DXT3_Format=33778,u.RGBA_S3TC_DXT5_Format=33779,u.RGBDEncoding=3006,u.RGBEEncoding=3002,u.RGBEFormat=1023,u.RGBFormat=1022,u.RGBIntegerFormat=1032,u.RGBM16Encoding=3005,u.RGBM7Encoding=3004,u.RGB_ETC1_Format=36196,u.RGB_ETC2_Format=37492,u.RGB_PVRTC_2BPPV1_Format=35841,u.RGB_PVRTC_4BPPV1_Format=35840,u.RGB_S3TC_DXT1_Format=33776,u.RGFormat=1030,u.RGIntegerFormat=1031,u.RawShaderMaterial=vs,u.Ray=Ti,u.Raycaster=class{constructor(s,e,t=0,n=1/0){this.ray=new Ti(s,e),this.near=t,this.far=n,this.camera=null,this.layers=new Sr,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(s,e){this.ray.set(s,e)}setFromCamera(s,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(s.x,s.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(s.x,s.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(s,e=!1,t=[]){return El(s,this,t,e),t.sort(Iu),t}intersectObjects(s,e=!1,t=[]){for(let n=0,i=s.length;n<i;n++)El(s[n],this,t,e);return t.sort(Iu),t}},u.RectAreaLight=xl,u.RedFormat=1028,u.RedIntegerFormat=1029,u.ReinhardToneMapping=2,u.RepeatWrapping=1e3,u.ReplaceStencilOp=7681,u.ReverseSubtractEquation=102,u.RingBufferGeometry=Is,u.RingGeometry=Is,u.SRGB8_ALPHA8_ASTC_10x10_Format=37851,u.SRGB8_ALPHA8_ASTC_10x5_Format=37848,u.SRGB8_ALPHA8_ASTC_10x6_Format=37849,u.SRGB8_ALPHA8_ASTC_10x8_Format=37850,u.SRGB8_ALPHA8_ASTC_12x10_Format=37852,u.SRGB8_ALPHA8_ASTC_12x12_Format=37853,u.SRGB8_ALPHA8_ASTC_4x4_Format=37840,u.SRGB8_ALPHA8_ASTC_5x4_Format=37841,u.SRGB8_ALPHA8_ASTC_5x5_Format=37842,u.SRGB8_ALPHA8_ASTC_6x5_Format=37843,u.SRGB8_ALPHA8_ASTC_6x6_Format=37844,u.SRGB8_ALPHA8_ASTC_8x5_Format=37845,u.SRGB8_ALPHA8_ASTC_8x6_Format=37846,u.SRGB8_ALPHA8_ASTC_8x8_Format=37847,u.Scene=Ia,u.SceneUtils=zp,u.ShaderChunk=dn,u.ShaderLib=Gi,u.ShaderMaterial=mr,u.ShadowMaterial=tl,u.Shape=Dr,u.ShapeBufferGeometry=Jr,u.ShapeGeometry=Jr,u.ShapePath=gu,u.ShapeUtils=ar,u.ShortType=1011,u.Skeleton=Ha,u.SkeletonHelper=zu,u.SkinnedMesh=ka,u.SmoothShading=2,u.Sphere=Si,u.SphereBufferGeometry=Kr,u.SphereGeometry=Kr,u.Spherical=class{constructor(s=1,e=0,t=0){return this.radius=s,this.phi=e,this.theta=t,this}set(s,e,t){return this.radius=s,this.phi=e,this.theta=t,this}copy(s){return this.radius=s.radius,this.phi=s.phi,this.theta=s.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(s){return this.setFromCartesianCoords(s.x,s.y,s.z)}setFromCartesianCoords(s,e,t){return this.radius=Math.sqrt(s*s+e*e+t*t),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(s,t),this.phi=Math.acos(Bt(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}},u.SphericalHarmonics3=bl,u.SplineCurve=Qa,u.SpotLight=fl,u.SpotLightHelper=class extends E{constructor(s,e){super(),this.light=s,this.light.updateMatrixWorld(),this.matrix=s.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const t=new Qt,n=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let r=0,a=1,l=32;r<l;r++,a++){const c=r/l*Math.PI*2,h=a/l*Math.PI*2;n.push(Math.cos(c),Math.sin(c),1,Math.cos(h),Math.sin(h),1)}t.setAttribute("position",new Ot(n,3));const i=new Kn({fog:!1,toneMapped:!1});this.cone=new xi(t,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const s=this.light.distance?this.light.distance:1e3,e=s*Math.tan(this.light.angle);this.cone.scale.set(e,e,s),Bu.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Bu),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},u.Sprite=Na,u.SpriteMaterial=Da,u.SrcAlphaFactor=204,u.SrcAlphaSaturateFactor=210,u.SrcColorFactor=202,u.StaticCopyUsage=35046,u.StaticDrawUsage=35044,u.StaticReadUsage=35045,u.StereoCamera=class{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Jn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Jn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(s){const e=this._cache;if(e.focus!==s.focus||e.fov!==s.fov||e.aspect!==s.aspect*this.aspect||e.near!==s.near||e.far!==s.far||e.zoom!==s.zoom||e.eyeSep!==this.eyeSep){e.focus=s.focus,e.fov=s.fov,e.aspect=s.aspect*this.aspect,e.near=s.near,e.far=s.far,e.zoom=s.zoom,e.eyeSep=this.eyeSep;const t=s.projectionMatrix.clone(),n=e.eyeSep/2,i=n*e.near/e.focus,r=e.near*Math.tan(It*e.fov*.5)/e.zoom;let a,l;wu.elements[12]=-n,bu.elements[12]=n,a=-r*e.aspect+i,l=r*e.aspect+i,t.elements[0]=2*e.near/(l-a),t.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(t),a=-r*e.aspect-i,l=r*e.aspect-i,t.elements[0]=2*e.near/(l-a),t.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(t)}this.cameraL.matrixWorld.copy(s.matrixWorld).multiply(wu),this.cameraR.matrixWorld.copy(s.matrixWorld).multiply(bu)}},u.StreamCopyUsage=35042,u.StreamDrawUsage=35040,u.StreamReadUsage=35041,u.StringKeyframeTrack=$r,u.SubtractEquation=101,u.SubtractiveBlending=3,u.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},u.TangentSpaceNormalMap=0,u.TetrahedronBufferGeometry=Ds,u.TetrahedronGeometry=Ds,u.TextBufferGeometry=io,u.TextGeometry=io,u.Texture=wn,u.TextureLoader=nu,u.TorusBufferGeometry=Os,u.TorusGeometry=Os,u.TorusKnotBufferGeometry=Fs,u.TorusKnotGeometry=Fs,u.Triangle=Ke,u.TriangleFanDrawMode=2,u.TriangleStripDrawMode=1,u.TrianglesDrawMode=0,u.TubeBufferGeometry=Ns,u.TubeGeometry=Ns,u.UVMapping=300,u.Uint16Attribute=function(s,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new mi(s,e)},u.Uint16BufferAttribute=mi,u.Uint32Attribute=function(s,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new kn(s,e)},u.Uint32BufferAttribute=kn,u.Uint8Attribute=function(s,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Ai(s,e)},u.Uint8BufferAttribute=Ai,u.Uint8ClampedAttribute=function(s,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new li(s,e)},u.Uint8ClampedBufferAttribute=li,u.Uniform=oo,u.UniformsLib=Ct,u.UniformsUtils=Nl,u.UnsignedByteType=1009,u.UnsignedInt248Type=1020,u.UnsignedIntType=1014,u.UnsignedShort4444Type=1017,u.UnsignedShort5551Type=1018,u.UnsignedShort565Type=1019,u.UnsignedShortType=1012,u.VSMShadowMap=3,u.Vector2=at,u.Vector3=H,u.Vector4=en,u.VectorKeyframeTrack=ca,u.Vertex=function(s,e,t){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new H(s,e,t)},u.VertexColors=2,u.VideoTexture=Bc,u.WebGL1Renderer=yc,u.WebGLCubeRenderTarget=Ta,u.WebGLMultipleRenderTargets=Gn,u.WebGLMultisampleRenderTarget=wi,u.WebGLRenderTarget=Nn,u.WebGLRenderTargetCube=function(s,e,t){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new Ta(s,t)},u.WebGLRenderer=En,u.WebGLUtils=gc,u.WireframeGeometry=el,u.WireframeHelper=function(s,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new xi(new el(s.geometry),new Kn({color:e!==void 0?e:16777215}))},u.WrapAroundEnding=2402,u.XHRLoader=function(s){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new qi(s)},u.ZeroCurvatureEnding=2400,u.ZeroFactor=200,u.ZeroSlopeEnding=2401,u.ZeroStencilOp=0,u.sRGBEncoding=3001,Object.defineProperty(u,"__esModule",{value:!0})})})(Pl,Pl.exports);var si=Pl.exports,lh={exports:{}},ch={exports:{}},uh={exports:{}};(function(Yt,Mn){const me=.0005555555555555556*Math.PI,ue=Math.atan(3/4),ve=63710088e-1,A=40075017;Yt.exports={WORLD_SIZE:1024e3,PROJECTION_WORLD_SIZE:1024e3/(ve*Math.PI*2),MERCATOR_A:ve,DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,EARTH_RADIUS:ve,EARTH_CIRCUMFERENCE:2*Math.PI*ve,EARTH_CIRCUMFERENCE_EQUATOR:A,FOV_ORTHO:me,FOV:ue,FOV_DEGREES:ue*180/Math.PI,TILE_SIZE:512}})(uh);var Dl=uh.exports,hh={exports:{}};(function(Yt,Mn){function u(){}u.prototype={Coords:function(me){if(me.constructor!==Array){console.error("Coords must be an array");return}if(me.length<2){console.error("Coords length must be at least 2");return}for(const ue of me)if(ue.constructor!==Number){console.error("Coords values must be numbers");return}if(Math.abs(me[1])>90){console.error("Latitude must be between -90 and 90");return}return me},Line:function(me){var ue=this;if(me.constructor!==Array){console.error("Line must be an array");return}for(const ve of me)if(!ue.Coords(ve)){console.error("Each coordinate in a line must be a valid Coords type");return}return me},Rotation:function(me){if(me.constructor===Number)me={z:me};else if(me.constructor===Object)for(const ue of Object.keys(me)){if(!["x","y","z"].includes(ue)){console.error("Rotation parameters must be x, y, or z");return}if(me[ue].constructor!==Number){console.error("Individual rotation values must be numbers");return}}else{console.error("Rotation must be an object or a number");return}return me},Scale:function(me){if(me.constructor===Number)me={x:me,y:me,z:me};else if(me.constructor===Object)for(const ue of Object.keys(me)){if(!["x","y","z"].includes(ue)){console.error("Scale parameters must be x, y, or z");return}if(me[ue].constructor!==Number){console.error("Individual scale values must be numbers");return}}else{console.error("Scale must be an object or a number");return}return me}},Yt.exports=u})(hh);var Gp=hh.exports;(function(Yt,Mn){var u=si,me=Dl,ue=Gp,ve={prettyPrintMatrix:function(A){for(var g=0;g<4;g++){var G=[A[g],A[g+4],A[g+8],A[g+12]];console.log(G.map(function(C){return C.toFixed(4)}))}},makePerspectiveMatrix:function(A,g,G,C){var te=new u.Matrix4,q=1/Math.tan(A/2),Ie=1/(G-C),De=[q/g,0,0,0,0,q,0,0,0,0,(C+G)*Ie,-1,0,0,2*C*G*Ie,0];return te.elements=De,te},makeOrthographicMatrix:function(A,g,G,C,te,q){var Ie=new u.Matrix4;const De=1/(g-A),et=1/(G-C),ie=1/(q-te),le=(g+A)*De,Oe=(G+C)*et,xe=te*ie;var tt=[2*De,0,0,0,0,2*et,0,0,0,0,-1*ie,0,-le,-Oe,-xe,1];return Ie.elements=tt,Ie},radify:function(A){function g(G){return G=G||0,Math.PI*2*G/360}return typeof A=="object"?A.length>0?A.map(function(G){return g(G)}):[g(A.x),g(A.y),g(A.z)]:g(A)},degreeify:function(A){function g(G){return G=G||0,G*360/(Math.PI*2)}return typeof A=="object"?[g(A.x),g(A.y),g(A.z)]:g(A)},projectToWorld:function(A){var g=[-me.MERCATOR_A*me.DEG2RAD*A[0]*me.PROJECTION_WORLD_SIZE,-me.MERCATOR_A*Math.log(Math.tan(Math.PI*.25+.5*me.DEG2RAD*A[1]))*me.PROJECTION_WORLD_SIZE];if(!A[2])g.push(0);else{var G=this.projectedUnitsPerMeter(A[1]);g.push(A[2]*G)}var C=new u.Vector3(g[0],g[1],g[2]);return C},projectedUnitsPerMeter:function(A){return Math.abs(me.WORLD_SIZE/Math.cos(me.DEG2RAD*A)/me.EARTH_CIRCUMFERENCE)},_circumferenceAtLatitude:function(A){return me.EARTH_CIRCUMFERENCE*Math.cos(A*Math.PI/180)},mercatorZfromAltitude:function(A,g){return A/this._circumferenceAtLatitude(g)},_scaleVerticesToMeters:function(A,g){var G=this.projectedUnitsPerMeter(A[1]);this.projectToWorld(A);for(var C=0;C<g.length;C++)g[C].multiplyScalar(G);return g},projectToScreen:function(A){console.log("WARNING: Projecting to screen coordinates is not yet implemented")},unprojectFromScreen:function(A){console.log("WARNING: unproject is not yet implemented")},unprojectFromWorld:function(A){var g=[-A.x/(me.MERCATOR_A*me.DEG2RAD*me.PROJECTION_WORLD_SIZE),2*(Math.atan(Math.exp(A.y/(me.PROJECTION_WORLD_SIZE*-me.MERCATOR_A)))-Math.PI/4)/me.DEG2RAD],G=this.projectedUnitsPerMeter(g[1]),C=A.z||0;return g.push(C/G),g},toScreenPosition:function(A,g){var G=new u.Vector3,C=.5*renderer.context.canvas.width,te=.5*renderer.context.canvas.height;return A.updateMatrixWorld(),G.setFromMatrixPosition(A.matrixWorld),G.project(g),G.x=G.x*C+C,G.y=-(G.y*te)+te,{x:G.x,y:G.y}},getFeatureCenter:function(g,G,C){let te=[],q=0,Ie=0,De=0,et=[...g.geometry.coordinates[0]];return g.geometry.type==="Point"?te=[...et[0]]:(g.geometry.type==="MultiPolygon"&&(et=et[0]),et.splice(-1,1),et.forEach(function(ie){q+=ie[0],Ie+=ie[1]}),te=[q/et.length,Ie/et.length]),De=this.getObjectHeightOnFloor(g,G,C),te.length<3?te.push(De):te[2]=De,te},getObjectHeightOnFloor:function(A,g,G=A.properties.level||0){let C=G*(A.properties.levelHeight||0),te=A.properties.base_height||A.properties.min_height||0,Ie=(g&&g.model?0:A.properties.height-te)+te;return C+Ie},_flipMaterialSides:function(A){},normalizeVertices(A){let g=new u.BufferGeometry,G=[];for(var C=0;C<A.length;C++){let Ie=A[C];G.push(Ie.x,Ie.y,Ie.z),G.push(Ie.x,Ie.y,Ie.z)}g.setAttribute("position",new u.BufferAttribute(new Float32Array(G),3)),g.computeBoundingSphere();var te=g.boundingSphere.center,q=A.map(function(Ie){var De=Ie.sub(te);return De});return{vertices:q,position:te}},flattenVectors(A){var g=[];for(let G of A)g.push(G.x,G.y,G.z);return g},lnglatsToWorld:function(A){var g=A.map(function(G){var C=ve.projectToWorld(G),te=new u.Vector3(C.x,C.y,C.z);return te});return g},extend:function(A,g){for(let G in g)A[G]=g[G]},clone:function(A){var g={};for(let G in A)g[G]=A[G];return g},clamp:function(A,g,G){return Math.min(G,Math.max(g,A))},types:{rotation:function(A,g){A||(A=0),typeof A=="number"&&(A={z:A});var G=this.applyDefault([A.x,A.y,A.z],g),C=ve.radify(G);return C},scale:function(A,g){return A||(A=1),typeof A=="number"?A=[A,A,A]:this.applyDefault([A.x,A.y,A.z],g)},applyDefault:function(A,g){var G=A.map(function(C,te){return C=C||g[te],C});return G}},toDecimal:function(A,g){return Number(A.toFixed(g))},equal:function(A,g){const G=Object.keys(A),C=Object.keys(g);if(G.length!==C.length||G.length==0&&C.length==0&&G!==C)return!1;for(const te of G){const q=A[te],Ie=g[te],De=this.isObject(q)&&this.isObject(Ie);if(De&&!equal(q,Ie)||!De&&q!==Ie)return!1}return!0},isObject:function(A){return A!=null&&typeof A=="object"},curveToLine:(A,g)=>{let{width:G,color:C}=g,te=new u.BufferGeometry().setFromPoints(A.getPoints(100)),q=new u.LineBasicMaterial({color:C,linewidth:G});return new u.Line(te,q)},curvesToLines:A=>{var g=[16711680,2031360,2490623],G=A.map((C,te)=>{let q={width:3,color:g[te]||"purple"};return curveToLine(C,q)});return G},_validate:function(A,g){A=A||{};var G={};ve.extend(G,A);for(let C of Object.keys(g))if(A[C]===void 0)if(g[C]===null){console.error(C+" is required");return}else G[C]=g[C];else G[C]=A[C];return G},Validator:new ue,exposedMethods:["projectToWorld","projectedUnitsPerMeter","extend","unprojectFromWorld"]};Yt.exports=ve})(ch);var Ii=ch.exports;(function(Yt,Mn){const u=si,me=Ii,ue=Dl;function ve(A,g,G){this.map=A,this.camera=g,this.active=!0,this.camera.matrixAutoUpdate=!1,this.world=G||new u.Group,this.world.position.x=this.world.position.y=ue.WORLD_SIZE/2,this.world.matrixAutoUpdate=!1,this.state={translateCenter:new u.Matrix4().makeTranslation(ue.WORLD_SIZE/2,-ue.WORLD_SIZE/2,0),worldSizeRatio:ue.TILE_SIZE/ue.WORLD_SIZE,worldSize:ue.TILE_SIZE*this.map.transform.scale};let C=this;this.map.on("move",function(){C.updateCamera()}).on("resize",function(){C.setupCamera()}),this.setupCamera()}ve.prototype={setupCamera:function(){const A=this.map.transform;this.camera.aspect=A.width/A.height,this.halfFov=A._fov/2,this.cameraToCenterDistance=.5/Math.tan(this.halfFov)*A.height;const g=A._maxPitch*Math.PI/180;this.acuteAngle=Math.PI/2-g,this.updateCamera()},updateCamera:function(A){if(!this.camera){console.log("nocamera");return}const g=this.map.transform;this.camera.aspect=g.width/g.height;const G=g.centerOffset||new u.Vector3;let C=0,te=0;this.halfFov=g._fov/2;const q=Math.PI/2+g._pitch,Ie=Math.cos(Math.PI/2-g._pitch);this.cameraToCenterDistance=.5/Math.tan(this.halfFov)*g.height;let De=1;const et=this.worldSize();if(this.map.tb.mapboxVersion>=2){De=this.mercatorZfromAltitude(1,g.center.lat)*et;const Q=g._fov*(.5+g.centerOffset.y/g.height),Y=g.elevation?g.elevation.getMinElevationBelowMSL()*De:0,Be=(g._camera.position[2]*et-Y)/Math.cos(g._pitch),yt=Math.sin(Q)*Be/Math.sin(me.clamp(Math.PI-q-Q,.01,Math.PI-.01));te=Ie*yt+Be;const He=Be*(1/g._horizonShift);C=Math.min(te*1.01,He)}else{const Q=Math.sin(this.halfFov)*this.cameraToCenterDistance/Math.sin(Math.PI-q-this.halfFov);te=Ie*Q+this.cameraToCenterDistance,C=te*1.01}this.cameraTranslateZ=new u.Matrix4().makeTranslation(0,0,this.cameraToCenterDistance);const ie=g.height/50,le=Math.max(ie*Ie,ie),Oe=g.height,xe=g.width;this.camera instanceof u.OrthographicCamera?this.camera.projectionMatrix=me.makeOrthographicMatrix(xe/-2,xe/2,Oe/2,Oe/-2,le,C):this.camera.projectionMatrix=me.makePerspectiveMatrix(g._fov,xe/Oe,le,C),this.camera.projectionMatrix.elements[8]=-G.x*2/g.width,this.camera.projectionMatrix.elements[9]=G.y*2/g.height;let tt=this.calcCameraMatrix(g._pitch,g.angle);g.elevation&&(tt.elements[14]=g._camera.position[2]*et),this.camera.matrixWorld.copy(tt);let bt=g.scale*this.state.worldSizeRatio,de=new u.Matrix4,ge=new u.Matrix4,Ge=new u.Matrix4;de.makeScale(bt,bt,bt);let gt=g.x||g.point.x,dt=g.y||g.point.y;ge.makeTranslation(-gt,dt,0),Ge.makeRotationZ(Math.PI),this.world.matrix=new u.Matrix4().premultiply(Ge).premultiply(this.state.translateCenter).premultiply(de).premultiply(ge),this.map.fire("CameraSynced",{detail:{nearZ:le,farZ:C,pitch:g._pitch,angle:g.angle,furthestDistance:te,cameraToCenterDistance:this.cameraToCenterDistance,t:this.map.transform,tbProjMatrix:this.camera.projectionMatrix.elements,tbWorldMatrix:this.world.matrix.elements,cameraSyn:ve}})},worldSize(){let A=this.map.transform;return A.tileSize*A.scale},worldSizeFromZoom(){let A=this.map.transform;return Math.pow(2,A.zoom)*A.tileSize},mercatorZfromAltitude(A,g){return A/this.circumferenceAtLatitude(g)},mercatorZfromZoom(){return this.cameraToCenterDistance/this.worldSizeFromZoom()},circumferenceAtLatitude(A){return ue.EARTH_CIRCUMFERENCE*Math.cos(A*Math.PI/180)},calcCameraMatrix(A,g,G){const C=this.map.transform,te=A===void 0?C._pitch:A,q=g===void 0?C.angle:g,Ie=G===void 0?this.cameraTranslateZ:G;return new u.Matrix4().premultiply(Ie).premultiply(new u.Matrix4().makeRotationX(te)).premultiply(new u.Matrix4().makeRotationZ(q))},updateCameraState(){let A=this.map.transform;if(!A.height)return;const g=A._camera.forward(),G=A.cameraToCenterDistance,C=A.point;A._cameraZoom?A._cameraZoom:A._zoom;const q=this.mercatorZfromZoom(A)-this.mercatorZfromAltitude(A._centerAltitude,A.center.lat),Ie=A.cameraToCenterDistance/q;return[C.x/this.worldSize()-g[0]*G/Ie,C.y/this.worldSize()-g[1]*G/Ie,this.mercatorZfromAltitude(A._centerAltitude,A._center.lat)+-g[2]*G/Ie]},getWorldToCamera(A,g){let G=this.map.transform;const C=new u.Matrix4,te=new u.Matrix4,q=G._camera._orientation,Ie=G._camera.position,De=new u.Vector3(Ie[0],Ie[1],Ie[2]),et=new u.Quaternion;et.set(q[0],q[1],q[2],q[3]);const ie=et.conjugate();return De.multiplyScalar(-A),te.makeTranslation(De.x,De.y,De.z),C.makeRotationFromQuaternion(ie).premultiply(te),C.elements[1]*=-1,C.elements[5]*=-1,C.elements[9]*=-1,C.elements[13]*=-1,C.elements[8]*=g,C.elements[9]*=g,C.elements[10]*=g,C.elements[11]*=g,C},translate(A,g,G){let C=G[0]||G.x,te=G[1]||G.y,q=G[2]||G.z,Ie,De,et,ie,le,Oe,xe,tt,bt,de,ge,Ge;return g===A?(A[12]=g[0]*C+g[4]*te+g[8]*q+g[12],A[13]=g[1]*C+g[5]*te+g[9]*q+g[13],A[14]=g[2]*C+g[6]*te+g[10]*q+g[14],A[15]=g[3]*C+g[7]*te+g[11]*q+g[15]):(Ie=g[0],De=g[1],et=g[2],ie=g[3],le=g[4],Oe=g[5],xe=g[6],tt=g[7],bt=g[8],de=g[9],ge=g[10],Ge=g[11],A[0]=Ie,A[1]=De,A[2]=et,A[3]=ie,A[4]=le,A[5]=Oe,A[6]=xe,A[7]=tt,A[8]=bt,A[9]=de,A[10]=ge,A[11]=Ge,A[12]=Ie*C+le*te+bt*q+g[12],A[13]=De*C+Oe*te+de*q+g[13],A[14]=et*C+xe*te+ge*q+g[14],A[15]=ie*C+tt*te+Ge*q+g[15]),A}},Yt.exports=ve})(lh);var Vp=lh.exports,dh={exports:{}};(function(Yt,Mn){(function(){var u=Math.PI,me=Math.sin,ue=Math.cos,ve=Math.tan,A=Math.asin,g=Math.atan2,G=Math.acos,C=u/180,te=1e3*60*60*24,q=2440588,Ie=2451545;function De(ne){return ne.valueOf()/te-.5+q}function et(ne){return new Date((ne+.5-q)*te)}function ie(ne){return De(ne)-Ie}var le=C*23.4397;function Oe(ne,ae){return g(me(ne)*ue(le)-ve(ae)*me(le),ue(ne))}function xe(ne,ae){return A(me(ae)*ue(le)+ue(ae)*me(le)*me(ne))}function tt(ne,ae,Me){return g(me(ne),ue(ne)*me(ae)-ve(Me)*ue(ae))}function bt(ne,ae,Me){return A(me(ae)*me(Me)+ue(ae)*ue(Me)*ue(ne))}function de(ne,ae){return C*(280.16+360.9856235*ne)-ae}function ge(ne){return ne<0&&(ne=0),2967e-7/Math.tan(ne+.00312536/(ne+.08901179))}function Ge(ne){return C*(357.5291+.98560028*ne)}function gt(ne){var ae=C*(1.9148*me(ne)+.02*me(2*ne)+3e-4*me(3*ne)),Me=C*102.9372;return ne+ae+Me+u}function dt(ne){var ae=Ge(ne),Me=gt(ae);return{dec:xe(Me,0),ra:Oe(Me,0)}}var Q={};Q.getPosition=function(ne,ae,Me){var oe=C*-Me,be=C*ae,ot=ie(ne),ct=dt(ot),wt=de(ot,oe)-ct.ra;return{azimuth:tt(wt,be,ct.dec),altitude:bt(wt,be,ct.dec)}},Q.toJulian=function(ne){return De(ne)};var Y=Q.times=[[-.833,"sunrise","sunset"],[-.3,"sunriseEnd","sunsetStart"],[-6,"dawn","dusk"],[-12,"nauticalDawn","nauticalDusk"],[-18,"nightEnd","night"],[6,"goldenHourEnd","goldenHour"]];Q.addTime=function(ne,ae,Me){Y.push([ne,ae,Me])};var Be=9e-4;function yt(ne,ae){return Math.round(ne-Be-ae/(2*u))}function He(ne,ae,Me){return Be+(ne+ae)/(2*u)+Me}function v(ne,ae,Me){return Ie+ne+.0053*me(ae)-.0069*me(2*Me)}function L(ne,ae,Me){return G((me(ne)-me(ae)*me(Me))/(ue(ae)*ue(Me)))}function R(ne){return-2.076*Math.sqrt(ne)/60}function D(ne,ae,Me,oe,be,ot,ct){var wt=L(ne,Me,oe),Jt=He(wt,ae,be);return v(Jt,ot,ct)}Q.getTimes=function(ne,ae,Me,oe){oe=oe||0;var be=C*-Me,ot=C*ae,ct=R(oe),wt=ie(ne),Jt=yt(wt,be),mn=He(0,be,Jt),on=Ge(mn),yn=gt(on),cn=xe(yn,0),gn=v(mn,on,yn),nt,z,B,$,V,ee,se={solarNoon:et(gn),nadir:et(gn-.5)};for(nt=0,z=Y.length;nt<z;nt+=1)B=Y[nt],$=(B[0]+ct)*C,V=D($,be,ot,cn,Jt,on,yn),ee=gn-(V-gn),se[B[1]]=et(ee),se[B[2]]=et(V);return se};function N(ne){var ae=C*(218.316+13.176396*ne),Me=C*(134.963+13.064993*ne),oe=C*(93.272+13.22935*ne),be=ae+C*6.289*me(Me),ot=C*5.128*me(oe),ct=385001-20905*ue(Me);return{ra:Oe(be,ot),dec:xe(be,ot),dist:ct}}Q.getMoonPosition=function(ne,ae,Me){var oe=C*-Me,be=C*ae,ot=ie(ne),ct=N(ot),wt=de(ot,oe)-ct.ra,Jt=bt(wt,be,ct.dec),mn=g(me(wt),ve(be)*ue(ct.dec)-me(ct.dec)*ue(wt));return Jt=Jt+ge(Jt),{azimuth:tt(wt,be,ct.dec),altitude:Jt,distance:ct.dist,parallacticAngle:mn}},Q.getMoonIllumination=function(ne){var ae=ie(ne||new Date),Me=dt(ae),oe=N(ae),be=149598e3,ot=G(me(Me.dec)*me(oe.dec)+ue(Me.dec)*ue(oe.dec)*ue(Me.ra-oe.ra)),ct=g(be*me(ot),oe.dist-be*ue(ot)),wt=g(ue(Me.dec)*me(Me.ra-oe.ra),me(Me.dec)*ue(oe.dec)-ue(Me.dec)*me(oe.dec)*ue(Me.ra-oe.ra));return{fraction:(1+ue(ct))/2,phase:.5+.5*ct*(wt<0?-1:1)/Math.PI,angle:wt}};function re(ne,ae){return new Date(ne.valueOf()+ae*te/24)}Q.getMoonTimes=function(ne,ae,Me,oe){var be=new Date(ne);oe?be.setUTCHours(0,0,0,0):be.setHours(0,0,0,0);for(var ot=.133*C,ct=Q.getMoonPosition(be,ae,Me).altitude-ot,wt,Jt,mn,on,yn,cn,gn,nt,z,B,$,V,ee,se=1;se<=24&&(wt=Q.getMoonPosition(re(be,se),ae,Me).altitude-ot,Jt=Q.getMoonPosition(re(be,se+1),ae,Me).altitude-ot,yn=(ct+Jt)/2-wt,cn=(Jt-ct)/2,gn=-cn/(2*yn),nt=(yn*gn+cn)*gn+wt,z=cn*cn-4*yn*wt,B=0,z>=0&&(ee=Math.sqrt(z)/(Math.abs(yn)*2),$=gn-ee,V=gn+ee,Math.abs($)<=1&&B++,Math.abs(V)<=1&&B++,$<-1&&($=V)),B===1?ct<0?mn=se+$:on=se+$:B===2&&(mn=se+(nt<0?V:$),on=se+(nt<0?$:V)),!(mn&&on));se+=2)ct=Jt;var fe={};return mn&&(fe.rise=re(be,mn)),on&&(fe.set=re(be,on)),!mn&&!on&&(fe[nt>0?"alwaysUp":"alwaysDown"]=!0),fe},Yt.exports=Q})()})(dh);var Wp=dh.exports,ph={exports:{}},fh={exports:{}};(function(Yt,Mn){var u=Ii,me=si,ue={material:"MeshBasicMaterial",color:"black",opacity:1};function ve(A){var g;A?(A=u._validate(A,ue),A.material&&A.material.isMaterial?g=A.material:A.material||A.color||A.opacity?g=new me[A.material]({color:A.color,transparent:A.opacity<1}):g=G(),g.opacity=A.opacity,A.side&&(g.side=A.side)):g=G();function G(){return new me[ue.material]({color:ue.color})}return g}Yt.exports=ve})(fh);var Ol=fh.exports,mh={exports:{}};(function(Yt,Mn){const u=si,me=Ii;function ue(A){this.map=A,this.enrolledObjects=[],this.previousFrameTime}ue.prototype={unenroll:function(A){this.enrolledObjects.splice(this.enrolledObjects.indexOf(A),1)},enroll:function(A){if(A.clock=new u.Clock,A.hasDefaultAnimation=!1,A.defaultAction,A.actions=[],A.mixer,A.animations&&A.animations.length>0){A.hasDefaultAnimation=!0;let C=A.userData.defaultAnimation?A.userData.defaultAnimation:0;A.mixer=new u.AnimationMixer(A),g(C)}function g(C){for(let te=0;te<A.animations.length;te++){C>A.animations.length&&console.log("The animation index "+C+" doesn't exist for this object");let q=A.animations[te],Ie=A.mixer.clipAction(q);A.actions.push(Ie),C===te?(A.defaultAction=Ie,Ie.setEffectiveWeight(1)):Ie.setEffectiveWeight(0),Ie.play()}}let G=!1;Object.defineProperty(A,"isPlaying",{get(){return G},set(C){G!=C&&(G=C,A.dispatchEvent({type:"IsPlayingChanged",detail:A}))}}),this.enrolledObjects.push(A),A.animationQueue=[],A.set=function(C){if(C.duration>0){let te={start:Date.now(),expiration:Date.now()+C.duration,endState:{}};me.extend(C,te);let q=C.coords,Ie=C.rotation,De=C.scale||C.scaleX||C.scaleY||C.scaleZ;if(Ie){let ie=A.rotation;C.startRotation=[ie.x,ie.y,ie.z],C.endState.rotation=me.types.rotation(C.rotation,C.startRotation),C.rotationPerMs=C.endState.rotation.map(function(le,Oe){return(le-C.startRotation[Oe])/C.duration})}if(De){let ie=A.scale;C.startScale=[ie.x,ie.y,ie.z],C.endState.scale=me.types.scale(C.scale,C.startScale),C.scalePerMs=C.endState.scale.map(function(le,Oe){return(le-C.startScale[Oe])/C.duration})}q&&(C.pathCurve=new u.CatmullRomCurve3(me.lnglatsToWorld([A.coordinates,C.coords])));let et={type:"set",parameters:C};this.animationQueue.push(et),tb.map.repaint=!0}else this.stop(),C.rotation=me.radify(C.rotation),this._setObject(C);return this},A.animationMethod=null,A.stop=function(C){return A.mixer&&(A.isPlaying=!1,cancelAnimationFrame(A.animationMethod)),this.animationQueue=[],this},A.followPath=function(C,te){let q={type:"followPath",parameters:me._validate(C,ve.followPath)};return me.extend(q.parameters,{pathCurve:new u.CatmullRomCurve3(me.lnglatsToWorld(C.path)),start:Date.now(),expiration:Date.now()+q.parameters.duration,cb:te}),this.animationQueue.push(q),tb.map.repaint=!0,this},A._setObject=function(C){A.setScale();let te=C.position,q=C.rotation,Ie=C.scale,De=C.worldCoordinates,et=C.quaternion,ie=C.translate,le=C.worldTranslate;if(te){this.coordinates=te;let xe=me.projectToWorld(te);this.position.copy(xe)}if(ie){this.coordinates=[this.coordinates[0]+ie[0],this.coordinates[1]+ie[1],this.coordinates[2]+ie[2]];let xe=me.projectToWorld(ie);this.position.copy(xe),C.position=this.coordinates}if(le){this.translateX(le.x),this.translateY(le.y),this.translateZ(le.z);let xe=me.unprojectFromWorld(this.position);this.coordinates=C.position=xe}if(q&&(this.rotation.set(q[0],q[1],q[2]),C.rotation=new u.Vector3(q[0],q[1],q[2])),Ie&&(this.scale.set(Ie[0],Ie[1],Ie[2]),C.scale=this.scale),et&&(this.quaternion.setFromAxisAngle(et[0],et[1]),C.rotation=et[0].multiplyScalar(et[1])),De){this.position.copy(De);let xe=me.unprojectFromWorld(De);this.coordinates=C.position=xe}this.setBoundingBoxShadowFloor(),this.setReceiveShadowFloor(),this.updateMatrixWorld(),tb.map.repaint=!0;let Oe={type:"ObjectChanged",detail:{object:this,action:{position:C.position,rotation:C.rotation,scale:C.scale}}};this.dispatchEvent(Oe)},A.playDefault=function(C){if(A.mixer&&A.hasDefaultAnimation){let te={start:Date.now(),expiration:Date.now()+C.duration,endState:{}};me.extend(C,te),A.mixer.timeScale=C.speed||1;let q={type:"playDefault",parameters:C};return this.animationQueue.push(q),tb.map.repaint=!0,this}},A.playAnimation=function(C){A.mixer&&(C.animation&&g(C.animation),A.playDefault(C))},A.pauseAllActions=function(){A.mixer&&A.actions.forEach(function(C){C.paused=!0})},A.unPauseAllActions=function(){A.mixer&&A.actions.forEach(function(C){C.paused=!1})},A.deactivateAllActions=function(){A.mixer&&A.actions.forEach(function(C){C.stop()})},A.activateAllActions=function(){A.mixer&&A.actions.forEach(function(C){C.play()})},A.idle=function(){return A.mixer&&A.mixer.update(.01),tb.map.repaint=!0,this}},update:function(A){if(this.previousFrameTime===void 0&&(this.previousFrameTime=A),!this.enrolledObjects)return!1;for(let g=this.enrolledObjects.length-1;g>=0;g--){let G=this.enrolledObjects[g];if(!(!G.animationQueue||G.animationQueue.length===0))for(let C=G.animationQueue.length-1;C>=0;C--){let te=G.animationQueue[C];if(!te)continue;let q=te.parameters;if(!q.expiration){G.animationQueue.splice(C,1),G.animationQueue[C]&&(G.animationQueue[C].parameters.start=A);return}if(A>=q.expiration)q.expiration=!1,te.type==="playDefault"?G.stop():(q.endState&&G._setObject(q.endState),typeof q.cb<"u"&&q.cb());else{let De=(A-q.start)/q.duration;if(te.type==="set"){let et={};q.pathCurve&&(et.worldCoordinates=q.pathCurve.getPoint(De)),q.rotationPerMs&&(et.rotation=q.startRotation.map(function(ie,le){return ie+q.rotationPerMs[le]*De*q.duration})),q.scalePerMs&&(et.scale=q.startScale.map(function(ie,le){return ie+q.scalePerMs[le]*De*q.duration})),G._setObject(et)}if(te.type==="followPath"){let ie={worldCoordinates:q.pathCurve.getPointAt(De)};if(q.trackHeading){let le=q.pathCurve.getTangentAt(De).normalize(),Oe=new u.Vector3(0,0,0),xe=new u.Vector3(0,1,0);Oe.crossVectors(xe,le).normalize();let tt=Math.acos(xe.dot(le));ie.quaternion=[Oe,tt]}G._setObject(ie)}te.type==="playDefault"&&(G.activateAllActions(),G.isPlaying=!0,G.animationMethod=requestAnimationFrame(this.update),G.mixer.update(G.clock.getDelta()),tb.map.repaint=!0)}}}this.previousFrameTime=A}};const ve={followPath:{path:null,duration:1e3,trackHeading:!0}};Yt.exports=ue})(mh);var jp=mh.exports,gh={exports:{}};(function(Yt,Mn){const u=si;(function(){class me extends u.Object3D{constructor(q){super(),this.element=q||document.createElement("div"),this.element.style.position="absolute",this.element.style.userSelect="none",this.element.setAttribute("draggable",!1),this.alwaysVisible=!1,Object.defineProperty(this,"layer",{get(){return this.parent&&this.parent.parent?this.parent.parent.layer:null}}),this.dispose=function(){this.remove(),this.element=null},this.remove=function(){this.element instanceof Element&&this.element.parentNode!==null&&this.element.parentNode.removeChild(this.element)},this.addEventListener("removed",function(){this.remove()})}copy(q,Ie){return super.copy(q,Ie),this.element=q.element.cloneNode(!0),this}}me.prototype.isCSS2DObject=!0;const ue=new u.Vector3,ve=new u.Matrix4,A=new u.Matrix4,g=new u.Vector3,G=new u.Vector3;class C{constructor(){const q=this;let Ie,De,et,ie;const le={objects:new WeakMap,list:new Map};this.cacheList=le.list;const Oe=document.createElement("div");Oe.style.overflow="hidden",this.domElement=Oe,this.getSize=function(){return{width:Ie,height:De}},this.render=function(ge,Ge){ge.autoUpdate===!0&&ge.updateMatrixWorld(),Ge.parent===null&&Ge.updateMatrixWorld(),ve.copy(Ge.matrixWorldInverse),A.multiplyMatrices(Ge.projectionMatrix,ve),xe(ge,ge,Ge),de(ge)},this.setSize=function(ge,Ge){Ie=ge,De=Ge,et=Ie/2,ie=De/2,Oe.style.width=ge+"px",Oe.style.height=Ge+"px"};function xe(ge,Ge,gt){if(ge.isCSS2DObject)if(!ge.visible)le.objects.delete({key:ge.uuid}),le.list.delete(ge.uuid),ge.remove();else{ge.onBeforeRender(q,Ge,gt),ue.setFromMatrixPosition(ge.matrixWorld),ue.applyMatrix4(A);const Q=ge.element;var dt;/apple/i.test(navigator.vendor)?dt="translate(-50%,-50%) translate("+Math.round(ue.x*et+et)+"px,"+Math.round(-ue.y*ie+ie)+"px)":dt="translate(-50%,-50%) translate("+(ue.x*et+et)+"px,"+(-ue.y*ie+ie)+"px)",Q.style.WebkitTransform=dt,Q.style.MozTransform=dt,Q.style.oTransform=dt,Q.style.transform=dt,Q.style.display=ge.visible&&ue.z>=-1&&ue.z<=1?"":"none";const Y={distanceToCameraSquared:tt(gt,ge)};le.objects.set({key:ge.uuid},Y),le.list.set(ge.uuid,ge),Q.parentNode!==Oe&&Oe.appendChild(Q),ge.onAfterRender(q,Ge,gt)}for(let Q=0,Y=ge.children.length;Q<Y;Q++)xe(ge.children[Q],Ge,gt)}function tt(ge,Ge){return g.setFromMatrixPosition(ge.matrixWorld),G.setFromMatrixPosition(Ge.matrixWorld),g.distanceToSquared(G)}function bt(ge){const Ge=[];return ge.traverse(function(gt){gt.isCSS2DObject&&Ge.push(gt)}),Ge}function de(ge){const Ge=bt(ge).sort(function(dt,Q){let Y=le.objects.get({key:dt.uuid}),Be=le.objects.get({key:Q.uuid});if(Y&&Be){const yt=Y.distanceToCameraSquared,He=Be.distanceToCameraSquared;return yt-He}}),gt=Ge.length;for(let dt=0,Q=Ge.length;dt<Q;dt++)Ge[dt].element.style.zIndex=gt-dt}}}u.CSS2DObject=me,u.CSS2DRenderer=C})(),Yt.exports={CSS2DRenderer:u.CSS2DRenderer,CSS2DObject:u.CSS2DObject}})(gh);var go=gh.exports;(function(Yt,Mn){const u=Ii,me=si,ue=jp,ve=go;function A(){}A.prototype={line:function(g){g=u._validate(g,this._defaults.line);var G=u.lnglatsToWorld(g.geometry),C=u.normalizeVertices(G),te=u.flattenVectors(C.vertices),q=new Float32Array(te),Ie=new me.BufferGeometry;Ie.setAttribute("position",new me.BufferAttribute(q,3));var De=new me.LineBasicMaterial({color:16711680,linewidth:21}),et=new me.Line(Ie,De);return et.options=options||{},et.position.copy(C.position),et},extrusion:function(g){},unenroll:function(g,G){var C=this;G||C.animationManager.unenroll(g)},_addMethods:function(g,G){var C=this;const te="label",q="tooltip",Ie="help",De="shadowPlane";if(!G){let ie=function(Q,Y,Be,yt){let He=u.radify(yt);Q.position.sub(Y),Q.position.applyAxisAngle(Be,He),Q.position.add(Y),Q.rotateOnAxis(Be,He),tb.map.repaint=!0},dt=function(Q){return Math.pow(2,Q)};g.coordinates||(g.coordinates=[0,0,0]),Object.defineProperty(g,"model",{get(){return g.getObjectByName("model")}}),Object.defineProperty(g,"animations",{get(){const Q=g.model;return Q?Q.animations:null}}),C.animationManager.enroll(g),g.setCoords=function(Q){return g.userData.topMargin&&g.userData.feature&&(Q[2]+=((g.userData.feature.properties.height||0)-(g.userData.feature.properties.base_height||g.userData.feature.properties.min_height||0))*(g.userData.topMargin||0)),g.coordinates=Q,g.set({position:Q}),g},g.setTranslate=function(Q){return g.set({translate:Q}),g},g.setRotation=function(Q){typeof Q=="number"&&(Q={z:Q});var Y={x:u.radify(Q.x)||g.rotation.x,y:u.radify(Q.y)||g.rotation.y,z:u.radify(Q.z)||g.rotation.z};g._setObject({rotation:[Y.x,Y.y,Y.z]})},g.calculateAdjustedPosition=function(Q,Y,Be){let yt=Q.slice(),He=u.unprojectFromWorld(g.modelSize);return Be?(yt[0]-=Y.x!=0?He[0]/Y.x:0,yt[1]-=Y.y!=0?He[1]/Y.y:0,yt[2]-=Y.z!=0?He[2]/Y.z:0):(yt[0]+=Y.x!=0?He[0]/Y.x:0,yt[1]+=Y.y!=0?He[1]/Y.y:0,yt[2]+=Y.z!=0?He[2]/Y.z:0),yt},g.setRotationAxis=function(Q){typeof Q=="number"&&(Q={z:Q});let Y=g.modelBox(),Be=new me.Vector3(Y.max.x,Y.max.y,Y.min.z);Q.x!=0&&ie(g,Be,new me.Vector3(0,0,1),Q.x),Q.y!=0&&ie(g,Be,new me.Vector3(0,0,1),Q.y),Q.z!=0&&ie(g,Be,new me.Vector3(0,0,1),Q.z)},Object.defineProperty(g,"scaleGroup",{get(){return g.getObjectByName("scaleGroup")}}),Object.defineProperty(g,"boxGroup",{get(){return g.getObjectByName("boxGroup")}}),Object.defineProperty(g,"boundingBox",{get(){return g.getObjectByName("boxModel")}}),Object.defineProperty(g,"boundingBoxShadow",{get(){return g.getObjectByName("boxShadow")}}),g.drawBoundingBox=function(){let Q=g.box3(),Y=new me.Group;Y.name="boxGroup",Y.updateMatrixWorld(!0);let Be=new me.Box3Helper(Q,A.prototype._defaults.colors.yellow);Be.name="boxModel",Y.add(Be),Be.layers.disable(0);let yt=Q.clone();yt.max.z=yt.min.z;let He=new me.Box3Helper(yt,A.prototype._defaults.colors.black);He.name="boxShadow",Y.add(He),He.layers.disable(0),Y.visible=!1,g.scaleGroup.add(Y),g.setBoundingBoxShadowFloor()},g.setBoundingBoxShadowFloor=function(){if(g.boundingBoxShadow){let Q=-g.modelHeight,Y=g.rotation,Be=g.boundingBoxShadow;Be.box.max.z=Be.box.min.z=Q,Be.rotation.y=Y.y,Be.rotation.x=-Y.x}},g.setAnchor=function(Q){const Y=g.box3(),Be=Y.getCenter(new me.Vector3);switch(g.none={x:0,y:0,z:0},g.center={x:Be.x,y:Be.y,z:Y.min.z},g.bottom={x:Be.x,y:Y.max.y,z:Y.min.z},g.bottomLeft={x:Y.max.x,y:Y.max.y,z:Y.min.z},g.bottomRight={x:Y.min.x,y:Y.max.y,z:Y.min.z},g.top={x:Be.x,y:Y.min.y,z:Y.min.z},g.topLeft={x:Y.max.x,y:Y.min.y,z:Y.min.z},g.topRight={x:Y.min.x,y:Y.min.y,z:Y.min.z},g.left={x:Y.max.x,y:Be.y,z:Y.min.z},g.right={x:Y.min.x,y:Be.y,z:Y.min.z},Q){case"center":g.anchor=g.center;break;case"top":g.anchor=g.top;break;case"top-left":g.anchor=g.topLeft;break;case"top-right":g.anchor=g.topRight;break;case"left":g.anchor=g.left;break;case"right":g.anchor=g.right;break;case"bottom":g.anchor=g.bottom;break;case"bottom-left":default:g.anchor=g.bottomLeft;break;case"bottom-right":g.anchor=g.bottomRight;break;case"auto":case"none":g.anchor=g.none}g.model.position.set(-g.anchor.x,-g.anchor.y,-g.anchor.z)},g.setCenter=function(Q){if(Q&&(Q.x!=0||Q.y!=0||Q.z!=0)){let Y=g.getSize();g.anchor={x:g.anchor.x-Y.x*Q.x,y:g.anchor.y-Y.y*Q.y,z:g.anchor.z-Y.z*Q.z},g.model.position.set(-g.anchor.x,-g.anchor.y,-g.anchor.z)}},Object.defineProperty(g,"label",{get(){return g.getObjectByName(te)}}),Object.defineProperty(g,"tooltip",{get(){return g.getObjectByName(q)}}),Object.defineProperty(g,"help",{get(){return g.getObjectByName(Ie)}});let le=!1;Object.defineProperty(g,"hidden",{get(){return le},set(Q){le!=Q&&(le=Q,g.visibility=!le)}}),Object.defineProperty(g,"visibility",{get(){return g.visible},set(Q){let Y=Q;if(Q=="visible"||Q==!0)Y=!0,g.label&&(g.label.visible=Y);else if(Q=="none"||Q==!1)Y=!1,g.label&&g.label.alwaysVisible&&(g.label.visible=Y),g.tooltip&&(g.tooltip.visible=Y);else return;if(g.visible!=Y){if(g.hidden&&Y)return;g.visible=Y,g.model&&g.model.traverse(function(Be){(Be.type=="Mesh"||Be.type=="SkinnedMesh")&&(Y&&g.raycasted?Be.layers.enable(0):Be.layers.disable(0)),Be.type=="LineSegments"&&Be.layers.disableAll()})}}}),g.addLabel=function(Q,Y,Be,yt){Q&&g.drawLabelHTML(Q,Y,Be,yt)},g.removeLabel=function(){g.removeCSS2D(te)},g.drawLabelHTML=function(Q,Y=!1,Be=g.anchor,yt=.5){let He=C.drawLabelHTML(Q,A.prototype._defaults.label.cssClass),v=g.addCSS2D(He,te,Be,yt);return v.alwaysVisible=Y,v.visible=Y,v},g.addTooltip=function(Q,Y,Be,yt=!0,He=1){let v=g.addHelp(Q,q,Y,Be,He);v.visible=!1,v.custom=yt},g.removeTooltip=function(){g.removeCSS2D(q)},g.addHelp=function(Q,Y=Ie,Be=!1,yt=g.anchor,He=0){let v=C.drawTooltip(Q,Be),L=g.addCSS2D(v,Y,yt,He);return L.visible=!0,L},g.removeHelp=function(){g.removeCSS2D(Ie)},g.addCSS2D=function(Q,Y,Be=g.anchor,yt=1){if(Q){const He=g.box3(),v=He.getSize(new me.Vector3);let L={x:He.max.x,y:He.max.y,z:He.min.z};g.removeCSS2D(Y);let R=new ve.CSS2DObject(Q);return R.name=Y,R.position.set(-v.x*.5-g.model.position.x-Be.x+L.x,-v.y*.5-g.model.position.y-Be.y+L.y,v.z*yt),R.visible=!1,g.scaleGroup.add(R),R}},g.removeCSS2D=function(Q){let Y=g.getObjectByName(Q);if(Y){Y.dispose();let Be=g.scaleGroup.children;Be.splice(Be.indexOf(Y),1)}},Object.defineProperty(g,"shadowPlane",{get(){return g.getObjectByName(De)}});let Oe=!1;Object.defineProperty(g,"castShadow",{get(){return Oe},set(Q){if(!(!g.model||Oe===Q)){if(g.model.traverse(function(Y){Y.isMesh&&(Y.castShadow=!0)}),Q){const Y=g.modelSize,Be=[Y.x,Y.y,Y.z,g.modelHeight],yt=Math.max(...Be)*10,He=new me.PlaneBufferGeometry(yt,yt),v=new me.ShadowMaterial;v.opacity=.5;let L=new me.Mesh(He,v);L.name=De,L.layers.enable(1),L.layers.disable(0),L.receiveShadow=Q,g.add(L)}else g.traverse(function(Y){Y.isMesh&&Y.material instanceof me.ShadowMaterial&&g.remove(Y)});Oe=Q}}}),g.setReceiveShadowFloor=function(){if(g.castShadow){let Q=g.shadowPlane,Y=Q.position,Be=Q.rotation;if(Y.z=-g.modelHeight,Be.y=g.rotation.y,Be.x=-g.rotation.x,g.userData.units==="meters"){const yt=g.modelSize,He=[yt.x,yt.y,yt.z,-Y.z],L=Math.max(...He)*10/Q.geometry.parameters.width;Q.scale.set(L,L,L)}}};let xe=!1;Object.defineProperty(g,"receiveShadow",{get(){return xe},set(Q){!g.model||xe===Q||(g.model.traverse(function(Y){Y.isMesh&&(Y.receiveShadow=!0)}),xe=Q)}});let tt=!1;Object.defineProperty(g,"wireframe",{get(){return tt},set(Q){!g.model||tt===Q||(g.model.traverse(function(Y){if(Y.type=="Mesh"||Y.type=="SkinnedMesh"){let Be=[];Array.isArray(Y.material)?Be=Y.material:Be.push(Y.material);let yt=Be[0];Q?(Y.userData.materials=yt,Y.material=yt.clone(),Y.material.wireframe=Y.material.transparent=Q,Y.material.opacity=.3):(Y.material.dispose(),Y.material=Y.userData.materials,Y.userData.materials.dispose(),Y.userData.materials=null),Q?(Y.layers.disable(0),Y.layers.enable(1)):(Y.layers.disable(1),Y.layers.enable(0))}Y.type=="LineSegments"&&Y.layers.disableAll()}),tt=Q,g.dispatchEvent({type:"Wireframed",detail:g}))}});let bt=null;Object.defineProperty(g,"color",{get(){return bt},set(Q){!g.model||bt===Q||(g.model.traverse(function(Y){if(Y.type=="Mesh"||Y.type=="SkinnedMesh"){let Be=[];Array.isArray(Y.material)?Be=Y.material:Be.push(Y.material);let yt=Be[0];Q?(Y.userData.materials=yt,Y.material=new me.MeshStandardMaterial,Y.material.color.setHex(Q)):(Y.material.dispose(),Y.material=Y.userData.materials,Y.userData.materials.dispose(),Y.userData.materials=null)}}),bt=Q)}});let de=!1;Object.defineProperty(g,"selected",{get(){return de},set(Q){Q?(g.userData.bbox&&!g.boundingBox&&g.drawBoundingBox(),g.boxGroup&&(g.boundingBox.material=A.prototype._defaults.materials.boxSelectedMaterial,g.boundingBox.parent.visible=!0,g.boundingBox.layers.enable(1),g.boundingBoxShadow.layers.enable(1)),g.label&&!g.label.alwaysVisible&&(g.label.visible=!0)):(g.boxGroup&&g.remove(g.boxGroup),g.label&&!g.label.alwaysVisible&&(g.label.visible=!1),g.removeHelp()),g.tooltip&&(g.tooltip.visible=Q),de!=Q&&(de=Q,g.dispatchEvent({type:"SelectedChange",detail:g}))}});let ge=!0;Object.defineProperty(g,"raycasted",{get(){return ge},set(Q){!g.model||ge===Q||(g.model.traverse(function(Y){(Y.type=="Mesh"||Y.type=="SkinnedMesh")&&(Q?(Y.layers.disable(1),Y.layers.enable(0)):(Y.layers.disable(0),Y.layers.enable(1)))}),ge=Q)}});let Ge=!1;Object.defineProperty(g,"over",{get(){return Ge},set(Q){Q?(g.selected||(g.userData.bbox&&!g.boundingBox&&g.drawBoundingBox(),g.userData.tooltip&&!g.tooltip&&g.addTooltip(g.uuid,!0,g.anchor,!1),g.boxGroup&&(g.boundingBox.material=A.prototype._defaults.materials.boxOverMaterial,g.boundingBox.parent.visible=!0,g.boundingBox.layers.enable(1),g.boundingBoxShadow.layers.enable(1))),g.label&&!g.label.alwaysVisible&&(g.label.visible=!0),g.dispatchEvent({type:"ObjectMouseOver",detail:g})):(g.selected||(g.boxGroup&&(g.remove(g.boxGroup),g.tooltip&&!g.tooltip.custom&&g.removeTooltip()),g.label&&!g.label.alwaysVisible&&(g.label.visible=!1)),g.dispatchEvent({type:"ObjectMouseOut",detail:g})),g.tooltip&&(g.tooltip.visible=Q||g.selected),Ge=Q}}),g.box3=function(){g.updateMatrix(),g.updateMatrixWorld(!0,!0);let Q;if(g.model){let Y=g.clone(!0),Be=g.model.clone();if(Q=new me.Box3().setFromObject(Be),g.parent){let yt=new me.Matrix4,He=new me.Matrix4;g.matrix.extractRotation(yt),He.copy(yt).invert(),Y.setRotationFromMatrix(He),Q=new me.Box3().setFromObject(Be)}}return Q},g.modelBox=function(){return g.box3()},g.getSize=function(){return g.box3().getSize(new me.Vector3(0,0,0))};let gt=!1;Object.defineProperty(g,"modelSize",{get(){return gt=g.getSize(),gt},set(Q){gt!=Q&&(gt=Q)}}),Object.defineProperty(g,"modelHeight",{get(){let Q=g.coordinates[2]||0;return g.userData.units==="scene"&&(Q*=g.unitsPerMeter/g.scale.x),Q}}),Object.defineProperty(g,"unitsPerMeter",{get(){return Number(u.projectedUnitsPerMeter(g.coordinates[1]).toFixed(7))}}),Object.defineProperty(g,"fixedZoom",{get(){return g.userData.fixedZoom},set(Q){g.userData.fixedZoom!==Q&&(g.userData.fixedZoom=Q,g.userData.units=Q?"scene":"meters")}}),g.setFixedZoom=function(Q){if(g.fixedZoom!=null&&g.fixedZoom!=0){Q||(Q=g.userData.mapScale);let Y=dt(g.fixedZoom);if(Y>Q){let Be=Y/Q;g.scale.set(Be,Be,Be)}else g.scale.set(1,1,1)}},g.setScale=function(Q){if(g.userData.units!="scene"){let Y=g.unitsPerMeter;g.scale.set(Y,Y,Y)}else g.fixedZoom?(Q&&(g.userData.mapScale=Q),g.setFixedZoom(g.userData.mapScale)):g.scale.set(1,1,1)},g.setObjectScale=function(Q){g.setScale(Q),g.setBoundingBoxShadowFloor(),g.setReceiveShadowFloor()}}g.add=function(ie){return g.scaleGroup.add(ie),ie.position.z=g.coordinates[2]?-g.coordinates[2]:0,ie},g.remove=function(ie){ie&&(ie.traverse(le=>{if(le.geometry&&le.geometry.dispose(),le.material)if(le.material.isMaterial)et(le.material);else for(const Oe of le.material)et(Oe);le.dispose&&le.dispose()}),g.scaleGroup.remove(ie),tb.map.repaint=!0)},g.duplicate=function(ie){let le=g.clone(!0);if(le.getObjectByName("model").animations=g.animations,le.userData.feature&&(ie&&ie.feature&&(le.userData.feature=ie.feature),le.userData.feature.properties.uuid=le.uuid),C._addMethods(le),!ie||u.equal(ie.scale,g.userData.scale))return le.copyAnchor(g),le;{le.userData=ie,le.userData.isGeoGroup=!0,le.remove(le.boxGroup);const Oe=u.types.rotation(ie.rotation,[0,0,0]),xe=u.types.scale(ie.scale,[1,1,1]);return le.model.position.set(0,0,0),le.model.rotation.set(Oe[0],Oe[1],Oe[2]),le.model.scale.set(xe[0],xe[1],xe[2]),le.setAnchor(ie.anchor),le.setCenter(ie.adjustment),le}},g.copyAnchor=function(ie){g.anchor=ie.anchor,g.none={x:0,y:0,z:0},g.center=ie.center,g.bottom=ie.bottom,g.bottomLeft=ie.bottomLeft,g.bottomRight=ie.bottomRight,g.top=ie.top,g.topLeft=ie.topLeft,g.topRight=ie.topRight,g.left=ie.left,g.right=ie.right},g.dispose=function(){A.prototype.unenroll(g),g.traverse(ie=>{if(!(ie.parent&&ie.parent.name=="world")&&ie.name!=="threeboxObject"){if(ie.geometry&&ie.geometry.dispose(),ie.material)if(ie.material.isMaterial)et(ie.material);else for(const le of ie.material)et(le);ie.dispose&&ie.dispose()}}),g.children=[]};const et=ie=>{ie.dispose();for(const xe of Object.keys(ie)){const tt=ie[xe];tt&&typeof tt=="object"&&"minFilter"in tt&&tt.dispose()}let le=ie;(le.map||le.alphaMap||le.aoMap||le.bumpMap||le.displacementMap||le.emissiveMap||le.envMap||le.lightMap||le.metalnessMap||le.normalMap||le.roughnessMap)&&(le.map&&le.map.dispose(),le.alphaMap&&le.alphaMap.dispose(),le.aoMap&&le.aoMap.dispose(),le.bumpMap&&le.bumpMap.dispose(),le.displacementMap&&le.displacementMap.dispose(),le.emissiveMap&&le.emissiveMap.dispose(),le.envMap&&le.envMap.dispose(),le.lightMap&&le.lightMap.dispose(),le.metalnessMap&&le.metalnessMap.dispose(),le.normalMap&&le.normalMap.dispose(),le.roughnessMap&&le.roughnessMap.dispose())};return g},_makeGroup:function(g,G){let C=new me.Group;C.name="scaleGroup",C.add(g);var te=new me.Group;te.userData=G||{},te.userData.isGeoGroup=!0,te.userData.feature&&(te.userData.feature.properties.uuid=te.uuid);var q=C.length;if(q)for(o of C)te.add(o);else te.add(C);return te.name="threeboxObject",te},animationManager:new ue,drawTooltip:function(g,G=!1){if(g){let C;if(G){let te=document.createElement("div");te.className="mapboxgl-popup-content";let q=document.createElement("strong");q.innerHTML=g,te.appendChild(q);let Ie=document.createElement("div");Ie.className="mapboxgl-popup-tip";let De=document.createElement("div");De.className="marker mapboxgl-popup-anchor-bottom",De.appendChild(Ie),De.appendChild(te),C=document.createElement("div"),C.className+="label3D",C.appendChild(De)}else C=document.createElement("span"),C.className=this._defaults.tooltip.cssClass,C.innerHTML=g;return C}},drawLabelHTML:function(g,G){let C=document.createElement("div");return C.className+=G,typeof g=="string"?C.innerHTML=g:C.innerHTML=g.outerHTML,C},_defaults:{colors:{red:new me.Color(16711680),yellow:new me.Color(16776960),green:new me.Color(65280),black:new me.Color(0)},materials:{boxNormalMaterial:new me.LineBasicMaterial({color:new me.Color(16711680)}),boxOverMaterial:new me.LineBasicMaterial({color:new me.Color(16776960)}),boxSelectedMaterial:new me.LineBasicMaterial({color:new me.Color(65280)})},line:{geometry:null,color:"black",width:1,opacity:1},label:{htmlElement:null,cssClass:" label3D",alwaysVisible:!1,topMargin:-.5},tooltip:{text:"",cssClass:"toolTip text-xs",mapboxStyle:!1,topMargin:0},sphere:{position:[0,0,0],radius:1,sides:20,units:"scene",material:"MeshBasicMaterial",anchor:"bottom-left",bbox:!0,tooltip:!0,raycasted:!0},tube:{geometry:null,radius:1,sides:6,units:"scene",material:"MeshBasicMaterial",anchor:"center",bbox:!0,tooltip:!0,raycasted:!0},loadObj:{type:null,obj:null,units:"scene",scale:1,rotation:0,defaultAnimation:0,anchor:"bottom-left",bbox:!0,tooltip:!0,raycasted:!0,clone:!0},Object3D:{obj:null,units:"scene",anchor:"bottom-left",bbox:!0,tooltip:!0,raycasted:!0},extrusion:{coordinates:[[[]]],geometryOptions:{},height:100,materials:new me.MeshPhongMaterial({color:6684672,side:me.DoubleSide}),scale:1,rotation:0,units:"scene",anchor:"center",bbox:!0,tooltip:!0,raycasted:!0}},geometries:{line:["LineString"],tube:["LineString"],sphere:["Point"]}},Yt.exports=A})(ph);var vr=ph.exports,yh={exports:{}},vh={exports:{}};(function(Yt,Mn){const u=vr,me=Ii;function ue(ve){ve=me._validate(ve,u.prototype._defaults.Object3D);let A=ve.obj;const g=me.types.rotation(ve.rotation,[0,0,0]),G=me.types.scale(ve.scale,[1,1,1]);A.rotation.set(g[0],g[1],g[2]),A.scale.set(G[0],G[1],G[2]),A.name="model";let C=u.prototype._makeGroup(A,ve);return ve.obj.name="model",u.prototype._addMethods(C),C.setAnchor(ve.anchor),C.setCenter(ve.adjustment),C.raycasted=ve.raycasted,C.visibility=!0,C}Yt.exports=ue})(vh);var yo=vh.exports;(function(Yt,Mn){const u=Ii,me=Ol,ue=si,ve=vr,A=yo;function g(G){G=u._validate(G,ve.prototype._defaults.sphere);let C=new ue.SphereBufferGeometry(G.radius,G.sides,G.sides),te=me(G),q=new ue.Mesh(C,te);return new A({obj:q,units:G.units,anchor:G.anchor,adjustment:G.adjustment,bbox:G.bbox,tooltip:G.tooltip,raycasted:G.raycasted})}Yt.exports=g})(yh);var qp=yh.exports,xh={exports:{}};(function(Yt,Mn){const u=vr,me=Ii,ue=si,ve=yo;function A(g){g=me._validate(g,u.prototype._defaults.extrusion);let G=A.prototype.buildShape(g.coordinates),C=A.prototype.buildGeometry(G,g.geometryOptions),te=new ue.Mesh(C,g.materials);return g.obj=te,new ve(g)}A.prototype={buildShape:function(g){if(g[0]instanceof(ue.Vector2||ue.Vector3))return new ue.Shape(g);let G=new ue.Shape;for(let C=0;C<g.length;C++)C===0?G=new ue.Shape(this.buildPoints(g[0],g[0])):G.holes.push(new ue.Path(this.buildPoints(g[C],g[0])));return G},buildPoints:function(g,G){const C=[];let te=me.projectToWorld([G[0][0],G[0][1],0]);for(let q=0;q<g.length;q++){let Ie=me.projectToWorld([g[q][0],g[q][1],0]);C.push(new ue.Vector2(me.toDecimal(Ie.x-te.x,9),me.toDecimal(Ie.y-te.y,9)))}return C},buildGeometry:function(g,G){let C=new ue.ExtrudeBufferGeometry(g,G);return C.computeBoundingBox(),C}},Yt.exports=A})(xh);var Xp=xh.exports,bh={exports:{}};(function(Yt,Mn){const u=Ii,me=vr,ue=go;function ve(A){A=u._validate(A,me.prototype._defaults.label);let g=me.prototype.drawLabelHTML(A.htmlElement,A.cssClass),G=new ue.CSS2DObject(g);G.name="label",G.visible=A.alwaysVisible,G.alwaysVisible=A.alwaysVisible;var C=me.prototype._makeGroup(G,A);return me.prototype._addMethods(C),C.visibility=A.alwaysVisible,C}Yt.exports=ve})(bh);var Zp=bh.exports,wh={exports:{}};(function(Yt,Mn){const u=Ii,me=vr,ue=go;function ve(A){if(A=u._validate(A,me.prototype._defaults.tooltip),A.text){let G=me.prototype.drawTooltip(A.text,A.mapboxStyle),C=new ue.CSS2DObject(G);C.visible=!1,C.name="tooltip";var g=me.prototype._makeGroup(C,A);return me.prototype._addMethods(g),g}}Yt.exports=ve})(wh);var Yp=wh.exports,_h={exports:{}},Mh={exports:{}};(function(Yt,Mn){const u=si;(function(){const me=/^[og]\s*(.+)?/,ue=/^mtllib /,ve=/^usemtl /,A=/^usemap /,g=new u.Vector3,G=new u.Vector3,C=new u.Vector3,te=new u.Vector3,q=new u.Vector3;function Ie(){const et={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(ie,le){if(this.object&&this.object.fromDeclaration===!1){this.object.name=ie,this.object.fromDeclaration=le!==!1;return}const Oe=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:ie||"",fromDeclaration:le!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(xe,tt){const bt=this._finalize(!1);bt&&(bt.inherited||bt.groupCount<=0)&&this.materials.splice(bt.index,1);const de={index:this.materials.length,name:xe||"",mtllib:Array.isArray(tt)&&tt.length>0?tt[tt.length-1]:"",smooth:bt!==void 0?bt.smooth:this.smooth,groupStart:bt!==void 0?bt.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(ge){const Ge={index:typeof ge=="number"?ge:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return Ge.clone=this.clone.bind(Ge),Ge}};return this.materials.push(de),de},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(xe){const tt=this.currentMaterial();if(tt&&tt.groupEnd===-1&&(tt.groupEnd=this.geometry.vertices.length/3,tt.groupCount=tt.groupEnd-tt.groupStart,tt.inherited=!1),xe&&this.materials.length>1)for(let bt=this.materials.length-1;bt>=0;bt--)this.materials[bt].groupCount<=0&&this.materials.splice(bt,1);return xe&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),tt}},Oe&&Oe.name&&typeof Oe.clone=="function"){const xe=Oe.clone(0);xe.inherited=!0,this.object.materials.push(xe)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(ie,le){const Oe=parseInt(ie,10);return(Oe>=0?Oe-1:Oe+le/3)*3},parseNormalIndex:function(ie,le){const Oe=parseInt(ie,10);return(Oe>=0?Oe-1:Oe+le/3)*3},parseUVIndex:function(ie,le){const Oe=parseInt(ie,10);return(Oe>=0?Oe-1:Oe+le/2)*2},addVertex:function(ie,le,Oe){const xe=this.vertices,tt=this.object.geometry.vertices;tt.push(xe[ie+0],xe[ie+1],xe[ie+2]),tt.push(xe[le+0],xe[le+1],xe[le+2]),tt.push(xe[Oe+0],xe[Oe+1],xe[Oe+2])},addVertexPoint:function(ie){const le=this.vertices;this.object.geometry.vertices.push(le[ie+0],le[ie+1],le[ie+2])},addVertexLine:function(ie){const le=this.vertices;this.object.geometry.vertices.push(le[ie+0],le[ie+1],le[ie+2])},addNormal:function(ie,le,Oe){const xe=this.normals,tt=this.object.geometry.normals;tt.push(xe[ie+0],xe[ie+1],xe[ie+2]),tt.push(xe[le+0],xe[le+1],xe[le+2]),tt.push(xe[Oe+0],xe[Oe+1],xe[Oe+2])},addFaceNormal:function(ie,le,Oe){const xe=this.vertices,tt=this.object.geometry.normals;g.fromArray(xe,ie),G.fromArray(xe,le),C.fromArray(xe,Oe),q.subVectors(C,G),te.subVectors(g,G),q.cross(te),q.normalize(),tt.push(q.x,q.y,q.z),tt.push(q.x,q.y,q.z),tt.push(q.x,q.y,q.z)},addColor:function(ie,le,Oe){const xe=this.colors,tt=this.object.geometry.colors;xe[ie]!==void 0&&tt.push(xe[ie+0],xe[ie+1],xe[ie+2]),xe[le]!==void 0&&tt.push(xe[le+0],xe[le+1],xe[le+2]),xe[Oe]!==void 0&&tt.push(xe[Oe+0],xe[Oe+1],xe[Oe+2])},addUV:function(ie,le,Oe){const xe=this.uvs,tt=this.object.geometry.uvs;tt.push(xe[ie+0],xe[ie+1]),tt.push(xe[le+0],xe[le+1]),tt.push(xe[Oe+0],xe[Oe+1])},addDefaultUV:function(){const ie=this.object.geometry.uvs;ie.push(0,0),ie.push(0,0),ie.push(0,0)},addUVLine:function(ie){const le=this.uvs;this.object.geometry.uvs.push(le[ie+0],le[ie+1])},addFace:function(ie,le,Oe,xe,tt,bt,de,ge,Ge){const gt=this.vertices.length;let dt=this.parseVertexIndex(ie,gt),Q=this.parseVertexIndex(le,gt),Y=this.parseVertexIndex(Oe,gt);if(this.addVertex(dt,Q,Y),this.addColor(dt,Q,Y),de!==void 0&&de!==""){const Be=this.normals.length;dt=this.parseNormalIndex(de,Be),Q=this.parseNormalIndex(ge,Be),Y=this.parseNormalIndex(Ge,Be),this.addNormal(dt,Q,Y)}else this.addFaceNormal(dt,Q,Y);if(xe!==void 0&&xe!==""){const Be=this.uvs.length;dt=this.parseUVIndex(xe,Be),Q=this.parseUVIndex(tt,Be),Y=this.parseUVIndex(bt,Be),this.addUV(dt,Q,Y),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(ie){this.object.geometry.type="Points";const le=this.vertices.length;for(let Oe=0,xe=ie.length;Oe<xe;Oe++){const tt=this.parseVertexIndex(ie[Oe],le);this.addVertexPoint(tt),this.addColor(tt)}},addLineGeometry:function(ie,le){this.object.geometry.type="Line";const Oe=this.vertices.length,xe=this.uvs.length;for(let tt=0,bt=ie.length;tt<bt;tt++)this.addVertexLine(this.parseVertexIndex(ie[tt],Oe));for(let tt=0,bt=le.length;tt<bt;tt++)this.addUVLine(this.parseUVIndex(le[tt],xe))}};return et.startObject("",!1),et}class De extends u.Loader{constructor(ie){super(ie),this.materials=null}load(ie,le,Oe,xe){const tt=this,bt=new u.FileLoader(this.manager);bt.setPath(this.path),bt.setRequestHeader(this.requestHeader),bt.setWithCredentials(this.withCredentials),bt.load(ie,function(de){try{le(tt.parse(de))}catch(ge){xe?xe(ge):console.error(ge),tt.manager.itemError(ie)}},Oe,xe)}setMaterials(ie){return this.materials=ie,this}parse(ie){const le=new Ie;ie.indexOf(`\r
`)!==-1&&(ie=ie.replace(/\r\n/g,`
`)),ie.indexOf(`\\
`)!==-1&&(ie=ie.replace(/\\\n/g,""));const Oe=ie.split(`
`);let xe="",tt="",bt=0,de=[];const ge=typeof"".trimLeft=="function";for(let dt=0,Q=Oe.length;dt<Q;dt++)if(xe=Oe[dt],xe=ge?xe.trimLeft():xe.trim(),bt=xe.length,bt!==0&&(tt=xe.charAt(0),tt!=="#"))if(tt==="v"){const Y=xe.split(/\s+/);switch(Y[0]){case"v":le.vertices.push(parseFloat(Y[1]),parseFloat(Y[2]),parseFloat(Y[3])),Y.length>=7?le.colors.push(parseFloat(Y[4]),parseFloat(Y[5]),parseFloat(Y[6])):le.colors.push(void 0,void 0,void 0);break;case"vn":le.normals.push(parseFloat(Y[1]),parseFloat(Y[2]),parseFloat(Y[3]));break;case"vt":le.uvs.push(parseFloat(Y[1]),parseFloat(Y[2]));break}}else if(tt==="f"){const Be=xe.substr(1).trim().split(/\s+/),yt=[];for(let v=0,L=Be.length;v<L;v++){const R=Be[v];if(R.length>0){const D=R.split("/");yt.push(D)}}const He=yt[0];for(let v=1,L=yt.length-1;v<L;v++){const R=yt[v],D=yt[v+1];le.addFace(He[0],R[0],D[0],He[1],R[1],D[1],He[2],R[2],D[2])}}else if(tt==="l"){const Y=xe.substring(1).trim().split(" ");let Be=[];const yt=[];if(xe.indexOf("/")===-1)Be=Y;else for(let He=0,v=Y.length;He<v;He++){const L=Y[He].split("/");L[0]!==""&&Be.push(L[0]),L[1]!==""&&yt.push(L[1])}le.addLineGeometry(Be,yt)}else if(tt==="p"){const Be=xe.substr(1).trim().split(" ");le.addPointGeometry(Be)}else if((de=me.exec(xe))!==null){const Y=(" "+de[0].substr(1).trim()).substr(1);le.startObject(Y)}else if(ve.test(xe))le.object.startMaterial(xe.substring(7).trim(),le.materialLibraries);else if(ue.test(xe))le.materialLibraries.push(xe.substring(7).trim());else if(A.test(xe))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(tt==="s"){if(de=xe.split(" "),de.length>1){const Be=de[1].trim().toLowerCase();le.object.smooth=Be!=="0"&&Be!=="off"}else le.object.smooth=!0;const Y=le.object.currentMaterial();Y&&(Y.smooth=le.object.smooth)}else{if(xe==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+xe+'"')}le.finalize();const Ge=new u.Group;if(Ge.materialLibraries=[].concat(le.materialLibraries),!(le.objects.length===1&&le.objects[0].geometry.vertices.length===0)===!0)for(let dt=0,Q=le.objects.length;dt<Q;dt++){const Y=le.objects[dt],Be=Y.geometry,yt=Y.materials,He=Be.type==="Line",v=Be.type==="Points";let L=!1;if(Be.vertices.length===0)continue;const R=new u.BufferGeometry;R.setAttribute("position",new u.Float32BufferAttribute(Be.vertices,3)),Be.normals.length>0&&R.setAttribute("normal",new u.Float32BufferAttribute(Be.normals,3)),Be.colors.length>0&&(L=!0,R.setAttribute("color",new u.Float32BufferAttribute(Be.colors,3))),Be.hasUVIndices===!0&&R.setAttribute("uv",new u.Float32BufferAttribute(Be.uvs,2));const D=[];for(let re=0,ne=yt.length;re<ne;re++){const ae=yt[re],Me=ae.name+"_"+ae.smooth+"_"+L;let oe=le.materials[Me];if(this.materials!==null){if(oe=this.materials.create(ae.name),He&&oe&&!(oe instanceof u.LineBasicMaterial)){const be=new u.LineBasicMaterial;u.Material.prototype.copy.call(be,oe),be.color.copy(oe.color),oe=be}else if(v&&oe&&!(oe instanceof u.PointsMaterial)){const be=new u.PointsMaterial({size:10,sizeAttenuation:!1});u.Material.prototype.copy.call(be,oe),be.color.copy(oe.color),be.map=oe.map,oe=be}}oe===void 0&&(He?oe=new u.LineBasicMaterial:v?oe=new u.PointsMaterial({size:1,sizeAttenuation:!1}):oe=new u.MeshPhongMaterial,oe.name=ae.name,oe.flatShading=!ae.smooth,oe.vertexColors=L,le.materials[Me]=oe),D.push(oe)}let N;if(D.length>1){for(let re=0,ne=yt.length;re<ne;re++){const ae=yt[re];R.addGroup(ae.groupStart,ae.groupCount,re)}He?N=new u.LineSegments(R,D):v?N=new u.Points(R,D):N=new u.Mesh(R,D)}else He?N=new u.LineSegments(R,D[0]):v?N=new u.Points(R,D[0]):N=new u.Mesh(R,D[0]);N.name=Y.name,Ge.add(N)}else if(le.vertices.length>0){const dt=new u.PointsMaterial({size:1,sizeAttenuation:!1}),Q=new u.BufferGeometry;Q.setAttribute("position",new u.Float32BufferAttribute(le.vertices,3)),le.colors.length>0&&le.colors[0]!==void 0&&(Q.setAttribute("color",new u.Float32BufferAttribute(le.colors,3)),dt.vertexColors=!0);const Y=new u.Points(Q,dt);Ge.add(Y)}return Ge}}u.OBJLoader=De})(),Yt.exports=u.OBJLoader})(Mh);var Jp=Mh.exports,Sh={exports:{}};(function(Yt,Mn){const u=si;(function(){class me extends u.Loader{constructor(A){super(A)}load(A,g,G,C){const te=this,q=this.path===""?u.LoaderUtils.extractUrlBase(A||""):this.path,Ie=new u.FileLoader(this.manager);Ie.setPath(this.path),Ie.setRequestHeader(this.requestHeader),Ie.setWithCredentials(this.withCredentials),Ie.load(A,function(De){try{g(te.parse(De,q))}catch(et){C?C(et):console.error(et),te.manager.itemError(A)}},G,C)}setMaterialOptions(A){return this.materialOptions=A,this}parse(A,g){const G=A.split(`
`);let C={};const te=/\s+/,q={};for(let De=0;De<G.length;De++){let et=G[De];if(et=et.trim(),et.length===0||et.charAt(0)==="#")continue;const ie=et.indexOf(" ");let le=ie>=0?et.substring(0,ie):et;le=le.toLowerCase();let Oe=ie>=0?et.substring(ie+1):"";if(Oe=Oe.trim(),le==="newmtl")C={name:Oe},q[Oe]=C;else if(le==="ka"||le==="kd"||le==="ks"||le==="ke"){const xe=Oe.split(te,3);C[le]=[parseFloat(xe[0]),parseFloat(xe[1]),parseFloat(xe[2])]}else C[le]=Oe}const Ie=new ue(this.resourcePath||g,this.materialOptions);return Ie.setCrossOrigin(this.crossOrigin),Ie.setManager(this.manager),Ie.setMaterials(q),Ie}}class ue{constructor(A="",g={}){this.baseUrl=A,this.options=g,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.side=this.options.side!==void 0?this.options.side:u.FrontSide,this.wrap=this.options.wrap!==void 0?this.options.wrap:u.RepeatWrapping}setCrossOrigin(A){return this.crossOrigin=A,this}setManager(A){this.manager=A}setMaterials(A){this.materialsInfo=this.convert(A),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(A){if(!this.options)return A;const g={};for(const G in A){const C=A[G],te={};g[G]=te;for(const q in C){let Ie=!0,De=C[q];const et=q.toLowerCase();switch(et){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(De=[De[0]/255,De[1]/255,De[2]/255]),this.options&&this.options.ignoreZeroRGBs&&De[0]===0&&De[1]===0&&De[2]===0&&(Ie=!1);break}Ie&&(te[et]=De)}}return g}preload(){for(const A in this.materialsInfo)this.create(A)}getIndex(A){return this.nameLookup[A]}getAsArray(){let A=0;for(const g in this.materialsInfo)this.materialsArray[A]=this.create(g),this.nameLookup[g]=A,A++;return this.materialsArray}create(A){return this.materials[A]===void 0&&this.createMaterial_(A),this.materials[A]}createMaterial_(A){const g=this,G=this.materialsInfo[A],C={name:A,side:this.side};function te(Ie,De){return typeof De!="string"||De===""?"":/^https?:\/\//i.test(De)?De:Ie+De}function q(Ie,De){if(C[Ie])return;const et=g.getTextureParams(De,C),ie=g.loadTexture(te(g.baseUrl,et.url));ie.repeat.copy(et.scale),ie.offset.copy(et.offset),ie.wrapS=g.wrap,ie.wrapT=g.wrap,C[Ie]=ie}for(const Ie in G){const De=G[Ie];let et;if(De!=="")switch(Ie.toLowerCase()){case"kd":C.color=new u.Color().fromArray(De);break;case"ks":C.specular=new u.Color().fromArray(De);break;case"ke":C.emissive=new u.Color().fromArray(De);break;case"map_kd":q("map",De);break;case"map_ks":q("specularMap",De);break;case"map_ke":q("emissiveMap",De);break;case"norm":q("normalMap",De);break;case"map_bump":case"bump":q("bumpMap",De);break;case"map_d":q("alphaMap",De),C.transparent=!0;break;case"ns":C.shininess=parseFloat(De);break;case"d":et=parseFloat(De),et<1&&(C.opacity=et,C.transparent=!0);break;case"tr":et=parseFloat(De),this.options&&this.options.invertTrProperty&&(et=1-et),et>0&&(C.opacity=1-et,C.transparent=!0);break}}return this.materials[A]=new u.MeshPhongMaterial(C),this.materials[A]}getTextureParams(A,g){const G={scale:new u.Vector2(1,1),offset:new u.Vector2(0,0)},C=A.split(/\s+/);let te;return te=C.indexOf("-bm"),te>=0&&(g.bumpScale=parseFloat(C[te+1]),C.splice(te,2)),te=C.indexOf("-s"),te>=0&&(G.scale.set(parseFloat(C[te+1]),parseFloat(C[te+2])),C.splice(te,4)),te=C.indexOf("-o"),te>=0&&(G.offset.set(parseFloat(C[te+1]),parseFloat(C[te+2])),C.splice(te,4)),G.url=C.join(" ").trim(),G}loadTexture(A,g,G,C,te){const q=this.manager!==void 0?this.manager:u.DefaultLoadingManager;let Ie=q.getHandler(A);Ie===null&&(Ie=new u.TextureLoader(q)),Ie.setCrossOrigin&&Ie.setCrossOrigin(this.crossOrigin);const De=Ie.load(A,G,C,te);return g!==void 0&&(De.mapping=g),De}}u.MTLLoader=me})(),Yt.exports=u.MTLLoader})(Sh);var Kp=Sh.exports,Th={exports:{}},Il={exports:{}};/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
*/(function(Yt,Mn){(function(u){Yt.exports=u()})(function(){var u={};u.__esModule=!0;var me=function(S){var M;try{M("require('worker_threads')").Worker}catch{}return Mn.default=function(P,W,Le,ze,_e){setImmediate(function(){return _e(Error("async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)"),null)});var qe=function(){};return{terminate:qe,postMessage:qe}},S}({}),ue=Uint8Array,ve=Uint16Array,A=Uint32Array,g=new ue([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),G=new ue([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),C=new ue([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),te=function(S,M){for(var P=new ve(31),W=0;W<31;++W)P[W]=M+=1<<S[W-1];var Le=new A(P[30]);for(W=1;W<30;++W)for(var ze=P[W];ze<P[W+1];++ze)Le[ze]=ze-P[W]<<5|W;return[P,Le]},q=te(g,2),Ie=q[0],De=q[1];Ie[28]=258,De[258]=28;for(var et=te(G,0),ie=et[0],le=et[1],Oe=new ve(32768),xe=0;xe<32768;++xe){var tt=(43690&xe)>>>1|(21845&xe)<<1;Oe[xe]=((65280&(tt=(61680&(tt=(52428&tt)>>>2|(13107&tt)<<2))>>>4|(3855&tt)<<4))>>>8|(255&tt)<<8)>>>1}var bt=function(S,M,P){for(var W=S.length,Le=0,ze=new ve(M);Le<W;++Le)++ze[S[Le]-1];var _e,qe=new ve(M);for(Le=0;Le<M;++Le)qe[Le]=qe[Le-1]+ze[Le-1]<<1;if(P){_e=new ve(1<<M);var w=15-M;for(Le=0;Le<W;++Le)if(S[Le])for(var x=Le<<4|S[Le],E=M-S[Le],O=qe[S[Le]-1]++<<E,I=O|(1<<E)-1;O<=I;++O)_e[Oe[O]>>>w]=x}else for(_e=new ve(W),Le=0;Le<W;++Le)S[Le]&&(_e[Le]=Oe[qe[S[Le]-1]++]>>>15-S[Le]);return _e},de=new ue(288);for(xe=0;xe<144;++xe)de[xe]=8;for(xe=144;xe<256;++xe)de[xe]=9;for(xe=256;xe<280;++xe)de[xe]=7;for(xe=280;xe<288;++xe)de[xe]=8;var ge=new ue(32);for(xe=0;xe<32;++xe)ge[xe]=5;var Ge=bt(de,9,0),gt=bt(de,9,1),dt=bt(ge,5,0),Q=bt(ge,5,1),Y=function(S){for(var M=S[0],P=1;P<S.length;++P)S[P]>M&&(M=S[P]);return M},Be=function(S,M,P){var W=M/8|0;return(S[W]|S[W+1]<<8)>>(7&M)&P},yt=function(S,M){var P=M/8|0;return(S[P]|S[P+1]<<8|S[P+2]<<16)>>(7&M)},He=function(S){return(S/8|0)+(7&S&&1)},v=function(S,M,P){(M==null||M<0)&&(M=0),(P==null||P>S.length)&&(P=S.length);var W=new(S instanceof ve?ve:S instanceof A?A:ue)(P-M);return W.set(S.subarray(M,P)),W},L=function(S,M,P){var W=S.length;if(!W||P&&!P.l&&W<5)return M||new ue(0);var Le=!M||P,ze=!P||P.i;P||(P={}),M||(M=new ue(3*W));var _e=function(Hr){var Ot=M.length;if(Hr>Ot){var dr=new ue(Math.max(2*Ot,Hr));dr.set(M),M=dr}},qe=P.f||0,w=P.p||0,x=P.b||0,E=P.l,O=P.d,I=P.m,pe=P.n,Se=8*W;do{if(!E){P.f=qe=Be(S,w,1);var Ve=Be(S,w+1,3);if(w+=3,!Ve){var lt=S[(qt=He(w)+4)-4]|S[qt-3]<<8,xt=qt+lt;if(xt>W){if(ze)throw"unexpected EOF";break}Le&&_e(x+lt),M.set(S.subarray(qt,xt),x),P.b=x+=lt,P.p=w=8*xt;continue}if(Ve==1)E=gt,O=Q,I=9,pe=5;else{if(Ve!=2)throw"invalid block type";var Ye=Be(S,w,31)+257,ke=Be(S,w+10,15)+4,Et=Ye+Be(S,w+5,31)+1;w+=14;for(var Ke=new ue(Et),Tt=new ue(19),We=0;We<ke;++We)Tt[C[We]]=Be(S,w+3*We,7);w+=3*ke;var Rt=Y(Tt),zt=(1<<Rt)-1;if(!ze&&w+Et*(Rt+7)>Se)break;var jt=bt(Tt,Rt,1);for(We=0;We<Et;){var qt,un=jt[Be(S,w,zt)];if(w+=15&un,(qt=un>>>4)<16)Ke[We++]=qt;else{var rn=0,ut=0;for(qt==16?(ut=3+Be(S,w,3),w+=2,rn=Ke[We-1]):qt==17?(ut=3+Be(S,w,7),w+=3):qt==18&&(ut=11+Be(S,w,127),w+=7);ut--;)Ke[We++]=rn}}var _n=Ke.subarray(0,Ye),Kt=Ke.subarray(Ye);I=Y(_n),pe=Y(Kt),E=bt(_n,I,1),O=bt(Kt,pe,1)}if(w>Se)throw"unexpected EOF"}Le&&_e(x+131072);for(var On=(1<<I)-1,$t=(1<<pe)-1,fi=I+pe+18;ze||w+fi<Se;){var Ai=(rn=E[yt(S,w)&On])>>>4;if((w+=15&rn)>Se)throw"unexpected EOF";if(!rn)throw"invalid length/literal";if(Ai<256)M[x++]=Ai;else{if(Ai==256){E=null;break}var li=Ai-254;Ai>264&&(li=Be(S,w,(1<<(ri=g[We=Ai-257]))-1)+Ie[We],w+=ri);var Bi=O[yt(S,w)&$t],mi=Bi>>>4;if(!Bi)throw"invalid distance";if(w+=15&Bi,Kt=ie[mi],mi>3){var ri=G[mi];Kt+=yt(S,w)&(1<<ri)-1,w+=ri}if(w>Se)throw"unexpected EOF";Le&&_e(x+131072);for(var kn=x+li;x<kn;x+=4)M[x]=M[x-Kt],M[x+1]=M[x+1-Kt],M[x+2]=M[x+2-Kt],M[x+3]=M[x+3-Kt];x=kn}}P.l=E,P.p=w,P.b=x,E&&(qe=1,P.m=I,P.d=O,P.n=pe)}while(!qe);return x==M.length?M:v(M,0,x)},R=function(S,M,P){var W=M/8|0;S[W]|=P<<=7&M,S[W+1]|=P>>>8},D=function(S,M,P){var W=M/8|0;S[W]|=P<<=7&M,S[W+1]|=P>>>8,S[W+2]|=P>>>16},N=function(S,M){for(var P=[],W=0;W<S.length;++W)S[W]&&P.push({s:W,f:S[W]});var Le=P.length,ze=P.slice();if(!Le)return[ot,0];if(Le==1){var _e=new ue(P[0].s+1);return _e[P[0].s]=1,[_e,1]}P.sort(function(Ke,Tt){return Ke.f-Tt.f}),P.push({s:-1,f:25001});var qe=P[0],w=P[1],x=0,E=1,O=2;for(P[0]={s:-1,f:qe.f+w.f,l:qe,r:w};E!=Le-1;)qe=P[P[x].f<P[O].f?x++:O++],w=P[x!=E&&P[x].f<P[O].f?x++:O++],P[E++]={s:-1,f:qe.f+w.f,l:qe,r:w};var I=ze[0].s;for(W=1;W<Le;++W)ze[W].s>I&&(I=ze[W].s);var pe=new ve(I+1),Se=re(P[E-1],pe,0);if(Se>M){W=0;var Ve=0,lt=Se-M,xt=1<<lt;for(ze.sort(function(Ke,Tt){return pe[Tt.s]-pe[Ke.s]||Ke.f-Tt.f});W<Le;++W){var Ye=ze[W].s;if(!(pe[Ye]>M))break;Ve+=xt-(1<<Se-pe[Ye]),pe[Ye]=M}for(Ve>>>=lt;Ve>0;){var ke=ze[W].s;pe[ke]<M?Ve-=1<<M-pe[ke]++-1:++W}for(;W>=0&&Ve;--W){var Et=ze[W].s;pe[Et]==M&&(--pe[Et],++Ve)}Se=M}return[new ue(pe),Se]},re=function(S,M,P){return S.s==-1?Math.max(re(S.l,M,P+1),re(S.r,M,P+1)):M[S.s]=P},ne=function(S){for(var M=S.length;M&&!S[--M];);for(var P=new ve(++M),W=0,Le=S[0],ze=1,_e=function(w){P[W++]=w},qe=1;qe<=M;++qe)if(S[qe]==Le&&qe!=M)++ze;else{if(!Le&&ze>2){for(;ze>138;ze-=138)_e(32754);ze>2&&(_e(ze>10?ze-11<<5|28690:ze-3<<5|12305),ze=0)}else if(ze>3){for(_e(Le),--ze;ze>6;ze-=6)_e(8304);ze>2&&(_e(ze-3<<5|8208),ze=0)}for(;ze--;)_e(Le);ze=1,Le=S[qe]}return[P.subarray(0,W),M]},ae=function(S,M){for(var P=0,W=0;W<M.length;++W)P+=S[W]*M[W];return P},Me=function(S,M,P){var W=P.length,Le=He(M+2);S[Le]=255&W,S[Le+1]=W>>>8,S[Le+2]=255^S[Le],S[Le+3]=255^S[Le+1];for(var ze=0;ze<W;++ze)S[Le+ze+4]=P[ze];return 8*(Le+4+W)},oe=function(S,M,P,W,Le,ze,_e,qe,w,x,E){R(M,E++,P),++Le[256];for(var O=N(Le,15),I=O[0],pe=O[1],Se=N(ze,15),Ve=Se[0],lt=Se[1],xt=ne(I),Ye=xt[0],ke=xt[1],Et=ne(Ve),Ke=Et[0],Tt=Et[1],We=new ve(19),Rt=0;Rt<Ye.length;++Rt)We[31&Ye[Rt]]++;for(Rt=0;Rt<Ke.length;++Rt)We[31&Ke[Rt]]++;for(var zt=N(We,7),jt=zt[0],qt=zt[1],un=19;un>4&&!jt[C[un-1]];--un);var rn,ut,_n,Kt,On=x+5<<3,$t=ae(Le,de)+ae(ze,ge)+_e,fi=ae(Le,I)+ae(ze,Ve)+_e+14+3*un+ae(We,jt)+(2*We[16]+3*We[17]+7*We[18]);if(On<=$t&&On<=fi)return Me(M,E,S.subarray(w,w+x));if(R(M,E,1+(fi<$t)),E+=2,fi<$t){rn=bt(I,pe,0),ut=I,_n=bt(Ve,lt,0),Kt=Ve;var Ai=bt(jt,qt,0);for(R(M,E,ke-257),R(M,E+5,Tt-1),R(M,E+10,un-4),E+=14,Rt=0;Rt<un;++Rt)R(M,E+3*Rt,jt[C[Rt]]);E+=3*un;for(var li=[Ye,Ke],Bi=0;Bi<2;++Bi){var mi=li[Bi];for(Rt=0;Rt<mi.length;++Rt)R(M,E,Ai[ri=31&mi[Rt]]),E+=jt[ri],ri>15&&(R(M,E,mi[Rt]>>>5&127),E+=mi[Rt]>>>12)}}else rn=Ge,ut=de,_n=dt,Kt=ge;for(Rt=0;Rt<qe;++Rt)if(W[Rt]>255){var ri;D(M,E,rn[257+(ri=W[Rt]>>>18&31)]),E+=ut[ri+257],ri>7&&(R(M,E,W[Rt]>>>23&31),E+=g[ri]);var kn=31&W[Rt];D(M,E,_n[kn]),E+=Kt[kn],kn>3&&(D(M,E,W[Rt]>>>5&8191),E+=G[kn])}else D(M,E,rn[W[Rt]]),E+=ut[W[Rt]];return D(M,E,rn[256]),E+ut[256]},be=new A([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),ot=new ue(0),ct=function(S,M,P,W,Le,ze){var _e=S.length,qe=new ue(W+_e+5*(1+Math.ceil(_e/7e3))+Le),w=qe.subarray(W,qe.length-Le),x=0;if(!M||_e<8)for(var E=0;E<=_e;E+=65535){var O=E+65535;O<_e?x=Me(w,x,S.subarray(E,O)):(w[E]=ze,x=Me(w,x,S.subarray(E,_e)))}else{for(var I=be[M-1],pe=I>>>13,Se=8191&I,Ve=(1<<P)-1,lt=new ve(32768),xt=new ve(Ve+1),Ye=Math.ceil(P/3),ke=2*Ye,Et=function(Hs){return(S[Hs]^S[Hs+1]<<Ye^S[Hs+2]<<ke)&Ve},Ke=new A(25e3),Tt=new ve(288),We=new ve(32),Rt=0,zt=0,jt=(E=0,0),qt=0,un=0;E<_e;++E){var rn=Et(E),ut=32767&E,_n=xt[rn];if(lt[ut]=_n,xt[rn]=ut,qt<=E){var Kt=_e-E;if((Rt>7e3||jt>24576)&&Kt>423){x=oe(S,w,0,Ke,Tt,We,zt,jt,un,E-un,x),jt=Rt=zt=0,un=E;for(var On=0;On<286;++On)Tt[On]=0;for(On=0;On<30;++On)We[On]=0}var $t=2,fi=0,Ai=Se,li=ut-_n&32767;if(Kt>2&&rn==Et(E-li))for(var Bi=Math.min(pe,Kt)-1,mi=Math.min(32767,E),ri=Math.min(258,Kt);li<=mi&&--Ai&&ut!=_n;){if(S[E+$t]==S[E+$t-li]){for(var kn=0;kn<ri&&S[E+kn]==S[E+kn-li];++kn);if(kn>$t){if($t=kn,fi=li,kn>Bi)break;var Hr=Math.min(li,kn-2),Ot=0;for(On=0;On<Hr;++On){var dr=E-li+On+32768&32767,Us=dr-lt[dr]+32768&32767;Us>Ot&&(Ot=Us,_n=dr)}}}li+=(ut=_n)-(_n=lt[ut])+32768&32767}if(fi){Ke[jt++]=268435456|De[$t]<<18|le[fi];var ma=31&De[$t],pr=31&le[fi];zt+=g[ma]+G[pr],++Tt[257+ma],++We[pr],qt=E+$t,++Rt}else Ke[jt++]=S[E],++Tt[S[E]]}}x=oe(S,w,ze,Ke,Tt,We,zt,jt,un,E-un,x),!ze&&7&x&&(x=Me(w,x+1,ot))}return v(qe,0,W+He(x)+Le)},wt=function(){for(var S=new A(256),M=0;M<256;++M){for(var P=M,W=9;--W;)P=(1&P&&3988292384)^P>>>1;S[M]=P}return S}(),Jt=function(){var S=-1;return{p:function(M){for(var P=S,W=0;W<M.length;++W)P=wt[255&P^M[W]]^P>>>8;S=P},d:function(){return~S}}},mn=function(){var S=1,M=0;return{p:function(P){for(var W=S,Le=M,ze=P.length,_e=0;_e!=ze;){for(var qe=Math.min(_e+2655,ze);_e<qe;++_e)Le+=W+=P[_e];W=(65535&W)+15*(W>>16),Le=(65535&Le)+15*(Le>>16)}S=W,M=Le},d:function(){return((S%=65521)>>>8<<16|(255&(M%=65521))<<8|M>>>8)+2*((255&S)<<23)}}},on=function(S,M,P,W,Le){return ct(S,M.level==null?6:M.level,M.mem==null?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(S.length)))):12+M.mem,P,W,!Le)},yn=function(S,M){var P={};for(var W in S)P[W]=S[W];for(var W in M)P[W]=M[W];return P},cn=function(S,M,P){for(var W=S(),Le=""+S,ze=Le.slice(Le.indexOf("[")+1,Le.lastIndexOf("]")).replace(/ /g,"").split(","),_e=0;_e<W.length;++_e){var qe=W[_e],w=ze[_e];if(typeof qe=="function"){M+=";"+w+"=";var x=""+qe;if(qe.prototype)if(x.indexOf("[native code]")!=-1){var E=x.indexOf(" ",8)+1;M+=x.slice(E,x.indexOf("(",E))}else for(var O in M+=x,qe.prototype)M+=";"+w+".prototype."+O+"="+qe.prototype[O];else M+=x}else P[w]=qe}return[M,P]},gn=[],nt=function(S){var M=[];for(var P in S)(S[P]instanceof ue||S[P]instanceof ve||S[P]instanceof A)&&M.push((S[P]=new S[P].constructor(S[P])).buffer);return M},z=function(S,M,P,W){var Le;if(!gn[P]){for(var ze="",_e={},qe=S.length-1,w=0;w<qe;++w)ze=(Le=cn(S[w],ze,_e))[0],_e=Le[1];gn[P]=cn(S[qe],ze,_e)}var x=yn({},gn[P][1]);return me.default(gn[P][0]+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+M+"}",P,x,nt(x),W)},B=function(){return[ue,ve,A,g,G,C,Ie,ie,gt,Q,Oe,bt,Y,Be,yt,He,v,L,Gn,he,Re]},$=function(){return[ue,ve,A,g,G,C,De,le,Ge,de,dt,ge,Oe,be,ot,bt,R,D,N,re,ne,ae,Me,oe,He,v,ct,on,wn,he]},V=function(){return[Vt,ti,At,Jt,wt]},ee=function(){return[Tn,bn]},se=function(){return[ni,At,mn]},fe=function(){return[at]},he=function(S){return postMessage(S,[S.buffer])},Re=function(S){return S&&S.size&&new ue(S.size)},it=function(S,M,P,W,Le,ze){var _e=z(P,W,Le,function(qe,w){_e.terminate(),ze(qe,w)});return _e.postMessage([S,M],M.consume?[S.buffer]:[]),function(){_e.terminate()}},st=function(S){return S.ondata=function(M,P){return postMessage([M,P],[M.buffer])},function(M){return S.push(M.data[0],M.data[1])}},It=function(S,M,P,W,Le){var ze,_e=z(S,W,Le,function(qe,w){qe?(_e.terminate(),M.ondata.call(M,qe)):(w[1]&&_e.terminate(),M.ondata.call(M,qe,w[0],w[1]))});_e.postMessage(P),M.push=function(qe,w){if(ze)throw"stream finished";if(!M.ondata)throw"no stream handler";_e.postMessage([qe,ze=w],[qe.buffer])},M.terminate=function(){_e.terminate()}},Nt=function(S,M){return S[M]|S[M+1]<<8},Ut=function(S,M){return(S[M]|S[M+1]<<8|S[M+2]<<16)+2*(S[M+3]<<23)},Bt=function(S,M){return Ut(S,M)|4294967296*Ut(S,M)},At=function(S,M,P){for(;P;++M)S[M]=P,P>>>=8},Vt=function(S,M){var P=M.filename;if(S[0]=31,S[1]=139,S[2]=8,S[8]=M.level<2?4:M.level==9?2:0,S[9]=3,M.mtime!=0&&At(S,4,Math.floor(new Date(M.mtime||Date.now())/1e3)),P){S[3]=8;for(var W=0;W<=P.length;++W)S[W+10]=P.charCodeAt(W)}},Tn=function(S){if(S[0]!=31||S[1]!=139||S[2]!=8)throw"invalid gzip data";var M=S[3],P=10;4&M&&(P+=S[10]|2+(S[11]<<8));for(var W=(M>>3&1)+(M>>4&1);W>0;W-=!S[P++]);return P+(2&M)},bn=function(S){var M=S.length;return(S[M-4]|S[M-3]<<8|S[M-2]<<16)+2*(S[M-1]<<23)},ti=function(S){return 10+(S.filename&&S.filename.length+1||0)},ni=function(S,M){var P=M.level,W=P==0?0:P<6?1:P==9?3:2;S[0]=120,S[1]=W<<6|(W?32-2*W:1)},at=function(S){if((15&S[0])!=8||S[0]>>>4>7||(S[0]<<8|S[1])%31)throw"invalid zlib data";if(32&S[1])throw"invalid zlib data: preset dictionaries not supported"};function hn(S,M){return M||typeof S!="function"||(M=S,S={}),this.ondata=M,S}var Rn=function(){function S(M,P){P||typeof M!="function"||(P=M,M={}),this.ondata=P,this.o=M||{}}return S.prototype.p=function(M,P){this.ondata(on(M,this.o,0,0,!P),P)},S.prototype.push=function(M,P){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";this.d=P,this.p(M,P||!1)},S}();u.Deflate=Rn;var Wn=function(){return function(S,M){It([$,function(){return[st,Rn]}],this,hn.call(this,S,M),function(P){var W=new Rn(P.data);onmessage=st(W)},6)}}();function lr(S,M,P){if(P||(P=M,M={}),typeof P!="function")throw"no callback";return it(S,M,[$],function(W){return he(wn(W.data[0],W.data[1]))},0,P)}function wn(S,M){return on(S,M||{},0,0)}u.AsyncDeflate=Wn,u.deflate=lr,u.deflateSync=wn;var Ln=function(){function S(M){this.s={},this.p=new ue(0),this.ondata=M}return S.prototype.e=function(M){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";var P=this.p.length,W=new ue(P+M.length);W.set(this.p),W.set(M,P),this.p=W},S.prototype.c=function(M){this.d=this.s.i=M||!1;var P=this.s.b,W=L(this.p,this.o,this.s);this.ondata(v(W,P,this.s.b),this.d),this.o=v(W,this.s.b-32768),this.s.b=this.o.length,this.p=v(this.p,this.s.p/8|0),this.s.p&=7},S.prototype.push=function(M,P){this.e(M),this.c(P)},S}();u.Inflate=Ln;var en=function(){return function(S){this.ondata=S,It([B,function(){return[st,Ln]}],this,0,function(){var M=new Ln;onmessage=st(M)},7)}}();function Nn(S,M,P){if(P||(P=M,M={}),typeof P!="function")throw"no callback";return it(S,M,[B],function(W){return he(Gn(W.data[0],Re(W.data[1])))},1,P)}function Gn(S,M){return L(S,M)}u.AsyncInflate=en,u.inflate=Nn,u.inflateSync=Gn;var wi=function(){function S(M,P){this.c=Jt(),this.l=0,this.v=1,Rn.call(this,M,P)}return S.prototype.push=function(M,P){Rn.prototype.push.call(this,M,P)},S.prototype.p=function(M,P){this.c.p(M),this.l+=M.length;var W=on(M,this.o,this.v&&ti(this.o),P&&8,!P);this.v&&(Vt(W,this.o),this.v=0),P&&(At(W,W.length-8,this.c.d()),At(W,W.length-4,this.l)),this.ondata(W,P)},S}();u.Gzip=wi,u.Compress=wi;var In=function(){return function(S,M){It([$,V,function(){return[st,Rn,wi]}],this,hn.call(this,S,M),function(P){var W=new wi(P.data);onmessage=st(W)},8)}}();function H(S,M,P){if(P||(P=M,M={}),typeof P!="function")throw"no callback";return it(S,M,[$,V,function(){return[Ki]}],function(W){return he(Ki(W.data[0],W.data[1]))},2,P)}function Ki(S,M){M||(M={});var P=Jt(),W=S.length;P.p(S);var Le=on(S,M,ti(M),8),ze=Le.length;return Vt(Le,M),At(Le,ze-8,P.d()),At(Le,ze-4,W),Le}u.AsyncGzip=In,u.AsyncCompress=In,u.gzip=H,u.compress=H,u.gzipSync=Ki,u.compressSync=Ki;var jn=function(){function S(M){this.v=1,Ln.call(this,M)}return S.prototype.push=function(M,P){if(Ln.prototype.e.call(this,M),this.v){var W=this.p.length>3?Tn(this.p):4;if(W>=this.p.length&&!P)return;this.p=this.p.subarray(W),this.v=0}if(P){if(this.p.length<8)throw"invalid gzip stream";this.p=this.p.subarray(0,-8)}Ln.prototype.c.call(this,P)},S}();u.Gunzip=jn;var qn=function(){return function(S){this.ondata=S,It([B,ee,function(){return[st,Ln,jn]}],this,0,function(){var M=new jn;onmessage=st(M)},9)}}();function yi(S,M,P){if(P||(P=M,M={}),typeof P!="function")throw"no callback";return it(S,M,[B,ee,function(){return[Di]}],function(W){return he(Di(W.data[0]))},3,P)}function Di(S,M){return L(S.subarray(Tn(S),-8),M||new ue(bn(S)))}u.AsyncGunzip=qn,u.gunzip=yi,u.gunzipSync=Di;var cr=function(){function S(M,P){this.c=mn(),this.v=1,Rn.call(this,M,P)}return S.prototype.push=function(M,P){Rn.prototype.push.call(this,M,P)},S.prototype.p=function(M,P){this.c.p(M);var W=on(M,this.o,this.v&&2,P&&4,!P);this.v&&(ni(W,this.o),this.v=0),P&&At(W,W.length-4,this.c.d()),this.ondata(W,P)},S}();u.Zlib=cr;var Qi=function(){return function(S,M){It([$,se,function(){return[st,Rn,cr]}],this,hn.call(this,S,M),function(P){var W=new cr(P.data);onmessage=st(W)},10)}}();function $i(S,M,P){if(P||(P=M,M={}),typeof P!="function")throw"no callback";return it(S,M,[$,se,function(){return[Oi]}],function(W){return he(Oi(W.data[0],W.data[1]))},4,P)}function Oi(S,M){M||(M={});var P=mn();P.p(S);var W=on(S,M,2,4);return ni(W,M),At(W,W.length-4,P.d()),W}u.AsyncZlib=Qi,u.zlib=$i,u.zlibSync=Oi;var ai=function(){function S(M){this.v=1,Ln.call(this,M)}return S.prototype.push=function(M,P){if(Ln.prototype.e.call(this,M),this.v){if(this.p.length<2&&!P)return;this.p=this.p.subarray(2),this.v=0}if(P){if(this.p.length<4)throw"invalid zlib stream";this.p=this.p.subarray(0,-4)}Ln.prototype.c.call(this,P)},S}();u.Unzlib=ai;var _i=function(){return function(S){this.ondata=S,It([B,fe,function(){return[st,Ln,ai]}],this,0,function(){var M=new ai;onmessage=st(M)},11)}}();function Mi(S,M,P){if(P||(P=M,M={}),typeof P!="function")throw"no callback";return it(S,M,[B,fe,function(){return[Fi]}],function(W){return he(Fi(W.data[0],Re(W.data[1])))},5,P)}function Fi(S,M){return L((at(S),S.subarray(2,-4)),M)}u.AsyncUnzlib=_i,u.unzlib=Mi,u.unzlibSync=Fi;var ur=function(){function S(M){this.G=jn,this.I=Ln,this.Z=ai,this.ondata=M}return S.prototype.push=function(M,P){if(!this.ondata)throw"no stream handler";if(this.s)this.s.push(M,P);else{if(this.p&&this.p.length){var W=new ue(this.p.length+M.length);W.set(this.p),W.set(M,this.p.length)}else this.p=M;if(this.p.length>2){var Le=this,ze=function(){Le.ondata.apply(Le,arguments)};this.s=this.p[0]==31&&this.p[1]==139&&this.p[2]==8?new this.G(ze):(15&this.p[0])!=8||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(ze):new this.Z(ze),this.s.push(this.p,P),this.p=null}}},S}();u.Decompress=ur;var xr=function(){function S(M){this.G=qn,this.I=en,this.Z=_i,this.ondata=M}return S.prototype.push=function(M,P){ur.prototype.push.call(this,M,P)},S}();function Ui(S,M,P){if(P||(P=M,M={}),typeof P!="function")throw"no callback";return S[0]==31&&S[1]==139&&S[2]==8?yi(S,M,P):(15&S[0])!=8||S[0]>>4>7||(S[0]<<8|S[1])%31?Nn(S,M,P):Mi(S,M,P)}function Br(S,M){return S[0]==31&&S[1]==139&&S[2]==8?Di(S,M):(15&S[0])!=8||S[0]>>4>7||(S[0]<<8|S[1])%31?Gn(S,M):Fi(S,M)}u.AsyncDecompress=xr,u.decompress=Ui,u.decompressSync=Br;var zr=function(S,M,P,W){for(var Le in S){var ze=S[Le],_e=M+Le;ze instanceof ue?P[_e]=[ze,W]:Array.isArray(ze)?P[_e]=[ze[0],yn(W,ze[1])]:zr(ze,_e+"/",P,W)}},kr=typeof TextEncoder<"u"&&new TextEncoder,hr=typeof TextDecoder<"u"&&new TextDecoder,br=0;try{hr.decode(ot,{stream:!0}),br=1}catch{}var Si=function(S){for(var M="",P=0;;){var W=S[P++],Le=(W>127)+(W>223)+(W>239);if(P+Le>S.length)return[M,v(S,P-1)];Le?Le==3?(W=((15&W)<<18|(63&S[P++])<<12|(63&S[P++])<<6|63&S[P++])-65536,M+=String.fromCharCode(55296|W>>10,56320|1023&W)):M+=String.fromCharCode(1&Le?(31&W)<<6|63&S[P++]:(15&W)<<12|(63&S[P++])<<6|63&S[P++]):M+=String.fromCharCode(W)}},Cn=function(){function S(M){this.ondata=M,br?this.t=new TextDecoder:this.p=ot}return S.prototype.push=function(M,P){if(!this.ondata)throw"no callback";if(P||(P=!1),this.t)return this.ondata(this.t.decode(M,{stream:!P}),P);var W=new ue(this.p.length+M.length);W.set(this.p),W.set(M,this.p.length);var Le=Si(W),ze=Le[0],_e=Le[1];if(P&&_e.length)throw"invalid utf-8 data";this.p=_e,this.ondata(ze,P)},S}();u.DecodeUTF8=Cn;var Ni=function(){function S(M){this.ondata=M}return S.prototype.push=function(M,P){if(!this.ondata)throw"no callback";this.ondata(ii(M),P||!1)},S}();function ii(S,M){if(M){for(var P=new ue(S.length),W=0;W<S.length;++W)P[W]=S.charCodeAt(W);return P}if(kr)return kr.encode(S);var Le=S.length,ze=new ue(S.length+(S.length>>1)),_e=0,qe=function(E){ze[_e++]=E};for(W=0;W<Le;++W){if(_e+5>ze.length){var w=new ue(_e+8+(Le-W<<1));w.set(ze),ze=w}var x=S.charCodeAt(W);x<128||M?qe(x):x<2048?(qe(192|x>>>6),qe(128|63&x)):x>55295&&x<57344?(qe(240|(x=65536+(1047552&x)|1023&S.charCodeAt(++W))>>>18),qe(128|x>>>12&63),qe(128|x>>>6&63),qe(128|63&x)):(qe(224|x>>>12),qe(128|x>>>6&63),qe(128|63&x))}return v(ze,0,_e)}function pi(S,M){if(M){for(var P="",W=0;W<S.length;W+=16384)P+=String.fromCharCode.apply(null,S.subarray(W,W+16384));return P}if(hr)return hr.decode(S);var Le=Si(S);if(Le[1].length)throw"invalid utf-8 data";return Le[0]}u.EncodeUTF8=Ni,u.strToU8=ii,u.strFromU8=pi;var wr=function(S){return S==1?3:S<6?2:S==9?1:0},er=function(S,M){return M+30+Nt(S,M+26)+Nt(S,M+28)},_r=function(S,M,P){var W=Nt(S,M+28),Le=pi(S.subarray(M+46,M+46+W),!(2048&Nt(S,M+8))),ze=M+46+W,_e=Ut(S,M+20),qe=P&&_e==4294967295?Ti(S,ze):[_e,Ut(S,M+24),Ut(S,M+42)],w=qe[0],x=qe[1],E=qe[2];return[Nt(S,M+10),w,x,Le,ze+Nt(S,M+30)+Nt(S,M+32),E]},Ti=function(S,M){for(;Nt(S,M)!=1;M+=4+Nt(S,M+2));return[Bt(S,M+12),Bt(S,M+4),Bt(S,M+20)]},Dt=function(S){var M=0;if(S)for(var P in S){var W=S[P].length;if(W>65535)throw"extra field too long";M+=W+4}return M},oi=function(S,M,P,W,Le,ze,_e,qe){var w=W.length,x=P.extra,E=qe&&qe.length,O=Dt(x);At(S,M,_e!=null?33639248:67324752),M+=4,_e!=null&&(S[M++]=20,S[M++]=P.os),S[M]=20,M+=2,S[M++]=P.flag<<1|(ze==null&&8),S[M++]=Le&&8,S[M++]=255&P.compression,S[M++]=P.compression>>8;var I=new Date(P.mtime==null?Date.now():P.mtime),pe=I.getFullYear()-1980;if(pe<0||pe>119)throw"date not in range 1980-2099";if(At(S,M,2*(pe<<24)|I.getMonth()+1<<21|I.getDate()<<16|I.getHours()<<11|I.getMinutes()<<5|I.getSeconds()>>>1),M+=4,ze!=null&&(At(S,M,P.crc),At(S,M+4,ze),At(S,M+8,P.size)),At(S,M+12,w),At(S,M+14,O),M+=16,_e!=null&&(At(S,M,E),At(S,M+6,P.attrs),At(S,M+10,_e),M+=14),S.set(W,M),M+=w,O)for(var Se in x){var Ve=x[Se],lt=Ve.length;At(S,M,+Se),At(S,M+2,lt),S.set(Ve,M+4),M+=4+lt}return E&&(S.set(qe,M),M+=E),M},Xn=function(S,M,P,W,Le){At(S,M,101010256),At(S,M+8,P),At(S,M+10,P),At(S,M+12,W),At(S,M+16,Le)},vi=function(){function S(M){this.filename=M,this.c=Jt(),this.size=0,this.compression=0}return S.prototype.process=function(M,P){this.ondata(null,M,P)},S.prototype.push=function(M,P){if(!this.ondata)throw"no callback - add to ZIP archive before pushing";this.c.p(M),this.size+=M.length,P&&(this.crc=this.c.d()),this.process(M,P||!1)},S}();u.ZipPassThrough=vi;var ks=function(){function S(M,P){var W=this;P||(P={}),vi.call(this,M),this.d=new Rn(P,function(Le,ze){W.ondata(null,Le,ze)}),this.compression=8,this.flag=wr(P.level)}return S.prototype.process=function(M,P){try{this.d.push(M,P)}catch(W){this.ondata(W,null,P)}},S.prototype.push=function(M,P){vi.prototype.push.call(this,M,P)},S}();u.ZipDeflate=ks;var Ei=function(){function S(M,P){var W=this;P||(P={}),vi.call(this,M),this.d=new Wn(P,function(Le,ze,_e){W.ondata(Le,ze,_e)}),this.compression=8,this.flag=wr(P.level),this.terminate=this.d.terminate}return S.prototype.process=function(M,P){this.d.push(M,P)},S.prototype.push=function(M,P){vi.prototype.push.call(this,M,P)},S}();u.AsyncZipDeflate=Ei;var Mr=function(){function S(M){this.ondata=M,this.u=[],this.d=1}return S.prototype.add=function(M){var P=this;if(2&this.d)throw"stream finished";var W=ii(M.filename),Le=W.length,ze=M.comment,_e=ze&&ii(ze),qe=Le!=M.filename.length||_e&&ze.length!=_e.length,w=Le+Dt(M.extra)+30;if(Le>65535)throw"filename too long";var x=new ue(w);oi(x,0,M,W,qe);var E=[x],O=function(){for(var lt=0,xt=E;lt<xt.length;lt++)P.ondata(null,xt[lt],!1);E=[]},I=this.d;this.d=0;var pe=this.u.length,Se=yn(M,{f:W,u:qe,o:_e,t:function(){M.terminate&&M.terminate()},r:function(){if(O(),I){var lt=P.u[pe+1];lt?lt.r():P.d=1}I=1}}),Ve=0;M.ondata=function(lt,xt,Ye){if(lt)P.ondata(lt,xt,Ye),P.terminate();else if(Ve+=xt.length,E.push(xt),Ye){var ke=new ue(16);At(ke,0,134695760),At(ke,4,M.crc),At(ke,8,Ve),At(ke,12,M.size),E.push(ke),Se.c=Ve,Se.b=w+Ve+16,Se.crc=M.crc,Se.size=M.size,I&&Se.r(),I=1}else I&&O()},this.u.push(Se)},S.prototype.end=function(){var M=this;if(2&this.d)throw 1&this.d?"stream finishing":"stream finished";this.d?this.e():this.u.push({r:function(){1&M.d&&(M.u.splice(-1,1),M.e())},t:function(){}}),this.d=3},S.prototype.e=function(){for(var M=0,P=0,W=0,Le=0,ze=this.u;Le<ze.length;Le++)W+=46+(x=ze[Le]).f.length+Dt(x.extra)+(x.o?x.o.length:0);for(var _e=new ue(W+22),qe=0,w=this.u;qe<w.length;qe++){var x;oi(_e,M,x=w[qe],x.f,x.u,x.c,P,x.o),M+=46+x.f.length+Dt(x.extra)+(x.o?x.o.length:0),P+=x.b}Xn(_e,M,this.u.length,W,P),this.ondata(null,_e,!0),this.d=2},S.prototype.terminate=function(){for(var M=0,P=this.u;M<P.length;M++)P[M].t();this.d=2},S}();function Zn(S,M,P){if(P||(P=M,M={}),typeof P!="function")throw"no callback";var W={};zr(S,"",W,M);var Le=Object.keys(W),ze=Le.length,_e=0,qe=0,w=ze,x=Array(ze),E=[],O=function(){for(var Ve=0;Ve<E.length;++Ve)E[Ve]()},I=function(){var Ve=new ue(qe+22),lt=_e,xt=qe-_e;qe=0;for(var Ye=0;Ye<w;++Ye){var ke=x[Ye];try{var Et=ke.c.length;oi(Ve,qe,ke,ke.f,ke.u,Et);var Ke=30+ke.f.length+Dt(ke.extra),Tt=qe+Ke;Ve.set(ke.c,Tt),oi(Ve,_e,ke,ke.f,ke.u,Et,qe,ke.m),_e+=16+Ke+(ke.m?ke.m.length:0),qe=Tt+Et}catch(We){return P(We,null)}}Xn(Ve,_e,x.length,xt,lt),P(null,Ve)};ze||I();for(var pe=function(Ve){var lt=Le[Ve],xt=W[lt],Ye=xt[0],ke=xt[1],Et=Jt(),Ke=Ye.length;Et.p(Ye);var Tt=ii(lt),We=Tt.length,Rt=ke.comment,zt=Rt&&ii(Rt),jt=zt&&zt.length,qt=Dt(ke.extra),un=ke.level==0?0:8,rn=function(ut,_n){if(ut)O(),P(ut,null);else{var Kt=_n.length;x[Ve]=yn(ke,{size:Ke,crc:Et.d(),c:_n,f:Tt,m:zt,u:We!=lt.length||zt&&Rt.length!=jt,compression:un}),_e+=30+We+qt+Kt,qe+=76+2*(We+qt)+(jt||0)+Kt,--ze||I()}};if(We>65535&&rn("filename too long",null),un)if(Ke<16e4)try{rn(null,wn(Ye,ke))}catch(ut){rn(ut,null)}else E.push(lr(Ye,ke,rn));else rn(null,Ye)},Se=0;Se<w;++Se)pe(Se);return O}function hs(S,M){M||(M={});var P={},W=[];zr(S,"",P,M);var Le=0,ze=0;for(var _e in P){var qe=P[_e],w=qe[0],x=qe[1],E=x.level==0?0:8,O=(We=ii(_e)).length,I=x.comment,pe=I&&ii(I),Se=pe&&pe.length,Ve=Dt(x.extra);if(O>65535)throw"filename too long";var lt=E?wn(w,x):w,xt=lt.length,Ye=Jt();Ye.p(w),W.push(yn(x,{size:w.length,crc:Ye.d(),c:lt,f:We,m:pe,u:O!=_e.length||pe&&I.length!=Se,o:Le,compression:E})),Le+=30+O+Ve+xt,ze+=76+2*(O+Ve)+(Se||0)+xt}for(var ke=new ue(ze+22),Et=Le,Ke=ze-Le,Tt=0;Tt<W.length;++Tt){var We;oi(ke,(We=W[Tt]).o,We,We.f,We.u,We.c.length);var Rt=30+We.f.length+Dt(We.extra);ke.set(We.c,We.o+Rt),oi(ke,Le,We,We.f,We.u,We.c.length,We.o,We.m),Le+=16+Rt+(We.m?We.m.length:0)}return Xn(ke,Le,W.length,Ke,Et),ke}u.Zip=Mr,u.zip=Zn,u.zipSync=hs;var Ur=function(){function S(){}return S.prototype.push=function(M,P){this.ondata(null,M,P)},S.compression=0,S}();u.UnzipPassThrough=Ur;var Hi=function(){function S(){var M=this;this.i=new Ln(function(P,W){M.ondata(null,P,W)})}return S.prototype.push=function(M,P){try{this.i.push(M,P)}catch(W){this.ondata(W,M,P)}},S.compression=8,S}();u.UnzipInflate=Hi;var Sr=function(){function S(M,P){var W=this;P<32e4?this.i=new Ln(function(Le,ze){W.ondata(null,Le,ze)}):(this.i=new en(function(Le,ze,_e){W.ondata(Le,ze,_e)}),this.terminate=this.i.terminate)}return S.prototype.push=function(M,P){this.i.terminate&&(M=v(M,0)),this.i.push(M,P)},S.compression=8,S}();u.AsyncUnzipInflate=Sr;var Dn=function(){function S(M){this.onfile=M,this.k=[],this.o={0:Ur},this.p=ot}return S.prototype.push=function(M,P){var W=this;if(!this.onfile)throw"no callback";if(this.c>0){var Le=Math.min(this.c,M.length),ze=M.subarray(0,Le);if(this.c-=Le,this.d?this.d.push(ze,!this.c):this.k[0].push(ze),(M=M.subarray(Le)).length)return this.push(M,P)}else{var _e=0,qe=0,w=void 0,x=void 0;this.p.length?M.length?((x=new ue(this.p.length+M.length)).set(this.p),x.set(M,this.p.length)):x=this.p:x=M;for(var E=x.length,O=this.c,I=O&&this.d,pe=function(){var lt,xt=Ut(x,qe);if(xt==67324752){_e=1,w=qe,Se.d=null,Se.c=0;var Ye=Nt(x,qe+6),ke=Nt(x,qe+8),Et=2048&Ye,Ke=8&Ye,Tt=Nt(x,qe+26),We=Nt(x,qe+28);if(E>qe+30+Tt+We){var Rt=[];Se.k.unshift(Rt),_e=2;var zt=Ut(x,qe+18),jt=Ut(x,qe+22),qt=pi(x.subarray(qe+30,qe+=30+Tt),!Et);zt==4294967295?(lt=Ke?[-2]:Ti(x,qe),zt=lt[0],jt=lt[1]):Ke&&(zt=-1),qe+=We,Se.c=zt;var un={name:qt,compression:ke,start:function(){if(!un.ondata)throw"no callback";if(zt){var rn=W.o[ke];if(!rn)throw"unknown compression type "+ke;var ut=zt<0?new rn(qt):new rn(qt,zt,jt);ut.ondata=function(On,$t,fi){un.ondata(On,$t,fi)};for(var _n=0,Kt=Rt;_n<Kt.length;_n++)ut.push(Kt[_n],!1);W.k[0]==Rt?W.d=ut:ut.push(ot,!0)}else un.ondata(null,ot,!0)},terminate:function(){W.k[0]==Rt&&W.d.terminate&&W.d.terminate()}};zt>=0&&(un.size=zt,un.originalSize=jt),Se.onfile(un)}return"break"}if(O){if(xt==134695760)return w=qe+=12+(O==-2&&8),_e=2,Se.c=0,"break";if(xt==33639248)return w=qe-=4,_e=2,Se.c=0,"break"}},Se=this;qe<E-4&&pe()!=="break";++qe);if(this.p=ot,O<0){var Ve=x.subarray(0,_e?w-12-(O==-2&&8)-(Ut(x,w-16)==134695760&&4):qe);I?I.push(Ve,!!_e):this.k[+(_e==2)].push(Ve)}if(2&_e)return this.push(x.subarray(qe),P);this.p=x.subarray(qe)}if(P&&this.c)throw"invalid zip file"},S.prototype.register=function(M){this.o[M.compression]=M},S}();function Tr(S,M){if(typeof M!="function")throw"no callback";for(var P=[],W=function(){for(var I=0;I<P.length;++I)P[I]()},Le={},ze=S.length-22;Ut(S,ze)!=101010256;--ze)if(!ze||S.length-ze>65558)return void M("invalid zip file",null);var _e=Nt(S,ze+8);_e||M(null,{});var qe=_e,w=Ut(S,ze+16),x=w==4294967295;if(x){if(ze=Ut(S,ze-12),Ut(S,ze)!=101075792)return void M("invalid zip file",null);qe=_e=Ut(S,ze+32),w=Ut(S,ze+48)}for(var E=function(I){var pe=_r(S,w,x),Se=pe[0],Ve=pe[1],lt=pe[2],xt=pe[3],Ye=pe[4],ke=er(S,pe[5]);w=Ye;var Et=function(Tt,We){Tt?(W(),M(Tt,null)):(Le[xt]=We,--_e||M(null,Le))};if(Se)if(Se==8){var Ke=S.subarray(ke,ke+Ve);if(Ve<32e4)try{Et(null,Gn(Ke,new ue(lt)))}catch(Tt){Et(Tt,null)}else P.push(Nn(Ke,{size:lt},Et))}else Et("unknown compression type "+Se,null);else Et(null,v(S,ke,ke+Ve))},O=0;O<qe;++O)E();return W}function tr(S){for(var M={},P=S.length-22;Ut(S,P)!=101010256;--P)if(!P||S.length-P>65558)throw"invalid zip file";var W=Nt(S,P+8);if(!W)return{};var Le=Ut(S,P+16),ze=Le==4294967295;if(ze){if(P=Ut(S,P-12),Ut(S,P)!=101075792)throw"invalid zip file";W=Ut(S,P+32),Le=Ut(S,P+48)}for(var _e=0;_e<W;++_e){var qe=_r(S,Le,ze),w=qe[0],x=qe[1],E=qe[2],O=qe[3],I=qe[4],pe=er(S,qe[5]);if(Le=I,w){if(w!=8)throw"unknown compression type "+w;M[O]=Gn(S.subarray(pe,pe+x),new ue(E))}else M[O]=v(S,pe,pe+x)}return M}return u.Unzip=Dn,u.unzip=Tr,u.unzipSync=tr,u})})(Il,Il.exports);var Qp=Il.exports;(function(Yt,Mn){const u=si,me=Qp;(function(){let ue,ve,A;class g extends u.Loader{constructor(v){super(v)}load(v,L,R,D){const N=this,re=N.path===""?u.LoaderUtils.extractUrlBase(v):N.path,ne=new u.FileLoader(this.manager);ne.setPath(N.path),ne.setResponseType("arraybuffer"),ne.setRequestHeader(N.requestHeader),ne.setWithCredentials(N.withCredentials),ne.load(v,function(ae){try{L(N.parse(ae,re))}catch(Me){D?D(Me):console.error(Me),N.manager.itemError(v)}},R,D)}parse(v,L){if(ie(v))ue=new Ie().parse(v);else{const D=Q(v);if(!le(D))throw new Error("THREE.FBXLoader: Unknown format.");if(Oe(D)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+Oe(D));ue=new q().parse(D)}const R=new u.TextureLoader(this.manager).setPath(this.resourcePath||L).setCrossOrigin(this.crossOrigin);return new G(R,this.manager).parse(ue)}}class G{constructor(v,L){this.textureLoader=v,this.manager=L}parse(){ve=this.parseConnections();const v=this.parseImages(),L=this.parseTextures(v),R=this.parseMaterials(L),D=this.parseDeformers(),N=new C().parse(D);return this.parseScene(D,N,R),A}parseConnections(){const v=new Map;return"Connections"in ue&&ue.Connections.connections.forEach(function(R){const D=R[0],N=R[1],re=R[2];v.has(D)||v.set(D,{parents:[],children:[]});const ne={ID:N,relationship:re};v.get(D).parents.push(ne),v.has(N)||v.set(N,{parents:[],children:[]});const ae={ID:D,relationship:re};v.get(N).children.push(ae)}),v}parseImages(){const v={},L={};if("Video"in ue.Objects){const R=ue.Objects.Video;for(const D in R){const N=R[D],re=parseInt(D);if(v[re]=N.RelativeFilename||N.Filename,"Content"in N){const ne=N.Content instanceof ArrayBuffer&&N.Content.byteLength>0,ae=typeof N.Content=="string"&&N.Content!=="";if(ne||ae){const Me=this.parseImage(R[D]);L[N.RelativeFilename||N.Filename]=Me}}}}for(const R in v){const D=v[R];L[D]!==void 0?v[R]=L[D]:v[R]=v[R].split("\\").pop()}return v}parseImage(v){const L=v.Content,R=v.RelativeFilename||v.Filename,D=R.slice(R.lastIndexOf(".")+1).toLowerCase();let N;switch(D){case"bmp":N="image/bmp";break;case"jpg":case"jpeg":N="image/jpeg";break;case"png":N="image/png";break;case"tif":N="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",R),N="image/tga";break;default:console.warn('FBXLoader: Image type "'+D+'" is not supported.');return}if(typeof L=="string")return"data:"+N+";base64,"+L;{const re=new Uint8Array(L);return window.URL.createObjectURL(new Blob([re],{type:N}))}}parseTextures(v){const L=new Map;if("Texture"in ue.Objects){const R=ue.Objects.Texture;for(const D in R){const N=this.parseTexture(R[D],v);L.set(parseInt(D),N)}}return L}parseTexture(v,L){const R=this.loadTexture(v,L);R.ID=v.id,R.name=v.attrName;const D=v.WrapModeU,N=v.WrapModeV,re=D!==void 0?D.value:0,ne=N!==void 0?N.value:0;if(R.wrapS=re===0?u.RepeatWrapping:u.ClampToEdgeWrapping,R.wrapT=ne===0?u.RepeatWrapping:u.ClampToEdgeWrapping,"Scaling"in v){const ae=v.Scaling.value;R.repeat.x=ae[0],R.repeat.y=ae[1]}return R}loadTexture(v,L){let R;const D=this.textureLoader.path,N=ve.get(v.id).children;N!==void 0&&N.length>0&&L[N[0].ID]!==void 0&&(R=L[N[0].ID],(R.indexOf("blob:")===0||R.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let re;const ne=v.FileName.slice(-3).toLowerCase();if(ne==="tga"){const ae=this.manager.getHandler(".tga");ae===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",v.RelativeFilename),re=new u.Texture):(ae.setPath(this.textureLoader.path),re=ae.load(R))}else ne==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",v.RelativeFilename),re=new u.Texture):re=this.textureLoader.load(R);return this.textureLoader.setPath(D),re}parseMaterials(v){const L=new Map;if("Material"in ue.Objects){const R=ue.Objects.Material;for(const D in R){const N=this.parseMaterial(R[D],v);N!==null&&L.set(parseInt(D),N)}}return L}parseMaterial(v,L){const R=v.id,D=v.attrName;let N=v.ShadingModel;if(typeof N=="object"&&(N=N.value),!ve.has(R))return null;const re=this.parseParameters(v,L,R);let ne;switch(N.toLowerCase()){case"phong":ne=new u.MeshPhongMaterial;break;case"lambert":ne=new u.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to THREE.MeshPhongMaterial.',N),ne=new u.MeshPhongMaterial;break}return ne.setValues(re),ne.name=D,ne}parseParameters(v,L,R){const D={};v.BumpFactor&&(D.bumpScale=v.BumpFactor.value),v.Diffuse?D.color=new u.Color().fromArray(v.Diffuse.value):v.DiffuseColor&&(v.DiffuseColor.type==="Color"||v.DiffuseColor.type==="ColorRGB")&&(D.color=new u.Color().fromArray(v.DiffuseColor.value)),v.DisplacementFactor&&(D.displacementScale=v.DisplacementFactor.value),v.Emissive?D.emissive=new u.Color().fromArray(v.Emissive.value):v.EmissiveColor&&(v.EmissiveColor.type==="Color"||v.EmissiveColor.type==="ColorRGB")&&(D.emissive=new u.Color().fromArray(v.EmissiveColor.value)),v.EmissiveFactor&&(D.emissiveIntensity=parseFloat(v.EmissiveFactor.value)),v.Opacity&&(D.opacity=parseFloat(v.Opacity.value)),D.opacity<1&&(D.transparent=!0),v.ReflectionFactor&&(D.reflectivity=v.ReflectionFactor.value),v.Shininess&&(D.shininess=v.Shininess.value),v.Specular?D.specular=new u.Color().fromArray(v.Specular.value):v.SpecularColor&&v.SpecularColor.type==="Color"&&(D.specular=new u.Color().fromArray(v.SpecularColor.value));const N=this;return ve.get(R).children.forEach(function(re){const ne=re.relationship;switch(ne){case"Bump":D.bumpMap=N.getTexture(L,re.ID);break;case"Maya|TEX_ao_map":D.aoMap=N.getTexture(L,re.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":D.map=N.getTexture(L,re.ID),D.map!==void 0&&(D.map.encoding=u.sRGBEncoding);break;case"DisplacementColor":D.displacementMap=N.getTexture(L,re.ID);break;case"EmissiveColor":D.emissiveMap=N.getTexture(L,re.ID),D.emissiveMap!==void 0&&(D.emissiveMap.encoding=u.sRGBEncoding);break;case"NormalMap":case"Maya|TEX_normal_map":D.normalMap=N.getTexture(L,re.ID);break;case"ReflectionColor":D.envMap=N.getTexture(L,re.ID),D.envMap!==void 0&&(D.envMap.mapping=u.EquirectangularReflectionMapping,D.envMap.encoding=u.sRGBEncoding);break;case"SpecularColor":D.specularMap=N.getTexture(L,re.ID),D.specularMap!==void 0&&(D.specularMap.encoding=u.sRGBEncoding);break;case"TransparentColor":case"TransparencyFactor":D.alphaMap=N.getTexture(L,re.ID),D.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",ne);break}}),D}getTexture(v,L){return"LayeredTexture"in ue.Objects&&L in ue.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),L=ve.get(L).children[0].ID),v.get(L)}parseDeformers(){const v={},L={};if("Deformer"in ue.Objects){const R=ue.Objects.Deformer;for(const D in R){const N=R[D],re=ve.get(parseInt(D));if(N.attrType==="Skin"){const ne=this.parseSkeleton(re,R);ne.ID=D,re.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),ne.geometryID=re.parents[0].ID,v[D]=ne}else if(N.attrType==="BlendShape"){const ne={id:D};ne.rawTargets=this.parseMorphTargets(re,R),ne.id=D,re.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),L[D]=ne}}}return{skeletons:v,morphTargets:L}}parseSkeleton(v,L){const R=[];return v.children.forEach(function(D){const N=L[D.ID];if(N.attrType!=="Cluster")return;const re={ID:D.ID,indices:[],weights:[],transformLink:new u.Matrix4().fromArray(N.TransformLink.a)};"Indexes"in N&&(re.indices=N.Indexes.a,re.weights=N.Weights.a),R.push(re)}),{rawBones:R,bones:[]}}parseMorphTargets(v,L){const R=[];for(let D=0;D<v.children.length;D++){const N=v.children[D],re=L[N.ID],ne={name:re.attrName,initialWeight:re.DeformPercent,id:re.id,fullWeights:re.FullWeights.a};if(re.attrType!=="BlendShapeChannel")return;ne.geoID=ve.get(parseInt(N.ID)).children.filter(function(ae){return ae.relationship===void 0})[0].ID,R.push(ne)}return R}parseScene(v,L,R){A=new u.Group;const D=this.parseModels(v.skeletons,L,R),N=ue.Objects.Model,re=this;D.forEach(function(ae){const Me=N[ae.ID];re.setLookAtProperties(ae,Me),ve.get(ae.ID).parents.forEach(function(be){const ot=D.get(be.ID);ot!==void 0&&ot.add(ae)}),ae.parent===null&&A.add(ae)}),this.bindSkeleton(v.skeletons,L,D),this.createAmbientLight(),A.traverse(function(ae){if(ae.userData.transformData){ae.parent&&(ae.userData.transformData.parentMatrix=ae.parent.matrix,ae.userData.transformData.parentMatrixWorld=ae.parent.matrixWorld);const Me=Ge(ae.userData.transformData);ae.applyMatrix4(Me),ae.updateWorldMatrix()}});const ne=new te().parse();A.children.length===1&&A.children[0].isGroup&&(A.children[0].animations=ne,A=A.children[0]),A.animations=ne}parseModels(v,L,R){const D=new Map,N=ue.Objects.Model;for(const re in N){const ne=parseInt(re),ae=N[re],Me=ve.get(ne);let oe=this.buildSkeleton(Me,v,ne,ae.attrName);if(!oe){switch(ae.attrType){case"Camera":oe=this.createCamera(Me);break;case"Light":oe=this.createLight(Me);break;case"Mesh":oe=this.createMesh(Me,L,R);break;case"NurbsCurve":oe=this.createCurve(Me,L);break;case"LimbNode":case"Root":oe=new u.Bone;break;case"Null":default:oe=new u.Group;break}oe.name=ae.attrName?u.PropertyBinding.sanitizeNodeName(ae.attrName):"",oe.ID=ne}this.getTransformData(oe,ae),D.set(ne,oe)}return D}buildSkeleton(v,L,R,D){let N=null;return v.parents.forEach(function(re){for(const ne in L){const ae=L[ne];ae.rawBones.forEach(function(Me,oe){if(Me.ID===re.ID){const be=N;N=new u.Bone,N.matrixWorld.copy(Me.transformLink),N.name=D?u.PropertyBinding.sanitizeNodeName(D):"",N.ID=R,ae.bones[oe]=N,be!==null&&N.add(be)}})}}),N}createCamera(v){let L,R;if(v.children.forEach(function(D){const N=ue.Objects.NodeAttribute[D.ID];N!==void 0&&(R=N)}),R===void 0)L=new u.Object3D;else{let D=0;R.CameraProjectionType!==void 0&&R.CameraProjectionType.value===1&&(D=1);let N=1;R.NearPlane!==void 0&&(N=R.NearPlane.value/1e3);let re=1e3;R.FarPlane!==void 0&&(re=R.FarPlane.value/1e3);let ne=window.innerWidth,ae=window.innerHeight;R.AspectWidth!==void 0&&R.AspectHeight!==void 0&&(ne=R.AspectWidth.value,ae=R.AspectHeight.value);const Me=ne/ae;let oe=45;R.FieldOfView!==void 0&&(oe=R.FieldOfView.value);const be=R.FocalLength?R.FocalLength.value:null;switch(D){case 0:L=new u.PerspectiveCamera(oe,Me,N,re),be!==null&&L.setFocalLength(be);break;case 1:L=new u.OrthographicCamera(-ne/2,ne/2,ae/2,-ae/2,N,re);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+D+"."),L=new u.Object3D;break}}return L}createLight(v){let L,R;if(v.children.forEach(function(D){const N=ue.Objects.NodeAttribute[D.ID];N!==void 0&&(R=N)}),R===void 0)L=new u.Object3D;else{let D;R.LightType===void 0?D=0:D=R.LightType.value;let N=16777215;R.Color!==void 0&&(N=new u.Color().fromArray(R.Color.value));let re=R.Intensity===void 0?1:R.Intensity.value/100;R.CastLightOnObject!==void 0&&R.CastLightOnObject.value===0&&(re=0);let ne=0;R.FarAttenuationEnd!==void 0&&(R.EnableFarAttenuation!==void 0&&R.EnableFarAttenuation.value===0?ne=0:ne=R.FarAttenuationEnd.value);const ae=1;switch(D){case 0:L=new u.PointLight(N,re,ne,ae);break;case 1:L=new u.DirectionalLight(N,re);break;case 2:let Me=Math.PI/3;R.InnerAngle!==void 0&&(Me=u.MathUtils.degToRad(R.InnerAngle.value));let oe=0;R.OuterAngle!==void 0&&(oe=u.MathUtils.degToRad(R.OuterAngle.value),oe=Math.max(oe,1)),L=new u.SpotLight(N,re,ne,Me,oe,ae);break;default:console.warn("THREE.FBXLoader: Unknown light type "+R.LightType.value+", defaulting to a THREE.PointLight."),L=new u.PointLight(N,re);break}R.CastShadows!==void 0&&R.CastShadows.value===1&&(L.castShadow=!0)}return L}createMesh(v,L,R){let D,N=null,re=null;const ne=[];return v.children.forEach(function(ae){L.has(ae.ID)&&(N=L.get(ae.ID)),R.has(ae.ID)&&ne.push(R.get(ae.ID))}),ne.length>1?re=ne:ne.length>0?re=ne[0]:(re=new u.MeshPhongMaterial({color:13421772}),ne.push(re)),"color"in N.attributes&&ne.forEach(function(ae){ae.vertexColors=!0}),N.FBX_Deformer?(D=new u.SkinnedMesh(N,re),D.normalizeSkinWeights()):D=new u.Mesh(N,re),D}createCurve(v,L){const R=v.children.reduce(function(N,re){return L.has(re.ID)&&(N=L.get(re.ID)),N},null),D=new u.LineBasicMaterial({color:3342591,linewidth:1});return new u.Line(R,D)}getTransformData(v,L){const R={};"InheritType"in L&&(R.inheritType=parseInt(L.InheritType.value)),"RotationOrder"in L?R.eulerOrder=gt(L.RotationOrder.value):R.eulerOrder="ZYX","Lcl_Translation"in L&&(R.translation=L.Lcl_Translation.value),"PreRotation"in L&&(R.preRotation=L.PreRotation.value),"Lcl_Rotation"in L&&(R.rotation=L.Lcl_Rotation.value),"PostRotation"in L&&(R.postRotation=L.PostRotation.value),"Lcl_Scaling"in L&&(R.scale=L.Lcl_Scaling.value),"ScalingOffset"in L&&(R.scalingOffset=L.ScalingOffset.value),"ScalingPivot"in L&&(R.scalingPivot=L.ScalingPivot.value),"RotationOffset"in L&&(R.rotationOffset=L.RotationOffset.value),"RotationPivot"in L&&(R.rotationPivot=L.RotationPivot.value),v.userData.transformData=R}setLookAtProperties(v,L){"LookAtProperty"in L&&ve.get(v.ID).children.forEach(function(D){if(D.relationship==="LookAtProperty"){const N=ue.Objects.Model[D.ID];if("Lcl_Translation"in N){const re=N.Lcl_Translation.value;v.target!==void 0?(v.target.position.fromArray(re),A.add(v.target)):v.lookAt(new u.Vector3().fromArray(re))}}})}bindSkeleton(v,L,R){const D=this.parsePoseNodes();for(const N in v){const re=v[N];ve.get(parseInt(re.ID)).parents.forEach(function(ae){if(L.has(ae.ID)){const Me=ae.ID;ve.get(Me).parents.forEach(function(be){R.has(be.ID)&&R.get(be.ID).bind(new u.Skeleton(re.bones),D[be.ID])})}})}}parsePoseNodes(){const v={};if("Pose"in ue.Objects){const L=ue.Objects.Pose;for(const R in L)if(L[R].attrType==="BindPose"){const D=L[R].PoseNode;Array.isArray(D)?D.forEach(function(N){v[N.Node]=new u.Matrix4().fromArray(N.Matrix.a)}):v[D.Node]=new u.Matrix4().fromArray(D.Matrix.a)}}return v}createAmbientLight(){if("GlobalSettings"in ue&&"AmbientColor"in ue.GlobalSettings){const v=ue.GlobalSettings.AmbientColor.value,L=v[0],R=v[1],D=v[2];if(L!==0||R!==0||D!==0){const N=new u.Color(L,R,D);A.add(new u.AmbientLight(N,1))}}}}class C{parse(v){const L=new Map;if("Geometry"in ue.Objects){const R=ue.Objects.Geometry;for(const D in R){const N=ve.get(parseInt(D)),re=this.parseGeometry(N,R[D],v);L.set(parseInt(D),re)}}return L}parseGeometry(v,L,R){switch(L.attrType){case"Mesh":return this.parseMeshGeometry(v,L,R);case"NurbsCurve":return this.parseNurbsGeometry(L)}}parseMeshGeometry(v,L,R){const D=R.skeletons,N=[],re=v.parents.map(function(be){return ue.Objects.Model[be.ID]});if(re.length===0)return;const ne=v.children.reduce(function(be,ot){return D[ot.ID]!==void 0&&(be=D[ot.ID]),be},null);v.children.forEach(function(be){R.morphTargets[be.ID]!==void 0&&N.push(R.morphTargets[be.ID])});const ae=re[0],Me={};"RotationOrder"in ae&&(Me.eulerOrder=gt(ae.RotationOrder.value)),"InheritType"in ae&&(Me.inheritType=parseInt(ae.InheritType.value)),"GeometricTranslation"in ae&&(Me.translation=ae.GeometricTranslation.value),"GeometricRotation"in ae&&(Me.rotation=ae.GeometricRotation.value),"GeometricScaling"in ae&&(Me.scale=ae.GeometricScaling.value);const oe=Ge(Me);return this.genGeometry(L,ne,N,oe)}genGeometry(v,L,R,D){const N=new u.BufferGeometry;v.attrName&&(N.name=v.attrName);const re=this.parseGeoNode(v,L),ne=this.genBuffers(re),ae=new u.Float32BufferAttribute(ne.vertex,3);if(ae.applyMatrix4(D),N.setAttribute("position",ae),ne.colors.length>0&&N.setAttribute("color",new u.Float32BufferAttribute(ne.colors,3)),L&&(N.setAttribute("skinIndex",new u.Uint16BufferAttribute(ne.weightsIndices,4)),N.setAttribute("skinWeight",new u.Float32BufferAttribute(ne.vertexWeights,4)),N.FBX_Deformer=L),ne.normal.length>0){const Me=new u.Matrix3().getNormalMatrix(D),oe=new u.Float32BufferAttribute(ne.normal,3);oe.applyNormalMatrix(Me),N.setAttribute("normal",oe)}if(ne.uvs.forEach(function(Me,oe){let be="uv"+(oe+1).toString();oe===0&&(be="uv"),N.setAttribute(be,new u.Float32BufferAttribute(ne.uvs[oe],2))}),re.material&&re.material.mappingType!=="AllSame"){let Me=ne.materialIndex[0],oe=0;if(ne.materialIndex.forEach(function(be,ot){be!==Me&&(N.addGroup(oe,ot-oe,Me),Me=be,oe=ot)}),N.groups.length>0){const be=N.groups[N.groups.length-1],ot=be.start+be.count;ot!==ne.materialIndex.length&&N.addGroup(ot,ne.materialIndex.length-ot,Me)}N.groups.length===0&&N.addGroup(0,ne.materialIndex.length,ne.materialIndex[0])}return this.addMorphTargets(N,v,R,D),N}parseGeoNode(v,L){const R={};if(R.vertexPositions=v.Vertices!==void 0?v.Vertices.a:[],R.vertexIndices=v.PolygonVertexIndex!==void 0?v.PolygonVertexIndex.a:[],v.LayerElementColor&&(R.color=this.parseVertexColors(v.LayerElementColor[0])),v.LayerElementMaterial&&(R.material=this.parseMaterialIndices(v.LayerElementMaterial[0])),v.LayerElementNormal&&(R.normal=this.parseNormals(v.LayerElementNormal[0])),v.LayerElementUV){R.uv=[];let D=0;for(;v.LayerElementUV[D];)v.LayerElementUV[D].UV&&R.uv.push(this.parseUVs(v.LayerElementUV[D])),D++}return R.weightTable={},L!==null&&(R.skeleton=L,L.rawBones.forEach(function(D,N){D.indices.forEach(function(re,ne){R.weightTable[re]===void 0&&(R.weightTable[re]=[]),R.weightTable[re].push({id:N,weight:D.weights[ne]})})})),R}genBuffers(v){const L={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let R=0,D=0,N=!1,re=[],ne=[],ae=[],Me=[],oe=[],be=[];const ot=this;return v.vertexIndices.forEach(function(ct,wt){let Jt,mn=!1;ct<0&&(ct=ct^-1,mn=!0);let on=[],yn=[];if(re.push(ct*3,ct*3+1,ct*3+2),v.color){const cn=bt(wt,R,ct,v.color);ae.push(cn[0],cn[1],cn[2])}if(v.skeleton){if(v.weightTable[ct]!==void 0&&v.weightTable[ct].forEach(function(cn){yn.push(cn.weight),on.push(cn.id)}),yn.length>4){N||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),N=!0);const cn=[0,0,0,0],gn=[0,0,0,0];yn.forEach(function(nt,z){let B=nt,$=on[z];gn.forEach(function(V,ee,se){if(B>V){se[ee]=B,B=V;const fe=cn[ee];cn[ee]=$,$=fe}})}),on=cn,yn=gn}for(;yn.length<4;)yn.push(0),on.push(0);for(let cn=0;cn<4;++cn)oe.push(yn[cn]),be.push(on[cn])}if(v.normal){const cn=bt(wt,R,ct,v.normal);ne.push(cn[0],cn[1],cn[2])}v.material&&v.material.mappingType!=="AllSame"&&(Jt=bt(wt,R,ct,v.material)[0]),v.uv&&v.uv.forEach(function(cn,gn){const nt=bt(wt,R,ct,cn);Me[gn]===void 0&&(Me[gn]=[]),Me[gn].push(nt[0]),Me[gn].push(nt[1])}),D++,mn&&(ot.genFace(L,v,re,Jt,ne,ae,Me,oe,be,D),R++,D=0,re=[],ne=[],ae=[],Me=[],oe=[],be=[])}),L}genFace(v,L,R,D,N,re,ne,ae,Me,oe){for(let be=2;be<oe;be++)v.vertex.push(L.vertexPositions[R[0]]),v.vertex.push(L.vertexPositions[R[1]]),v.vertex.push(L.vertexPositions[R[2]]),v.vertex.push(L.vertexPositions[R[(be-1)*3]]),v.vertex.push(L.vertexPositions[R[(be-1)*3+1]]),v.vertex.push(L.vertexPositions[R[(be-1)*3+2]]),v.vertex.push(L.vertexPositions[R[be*3]]),v.vertex.push(L.vertexPositions[R[be*3+1]]),v.vertex.push(L.vertexPositions[R[be*3+2]]),L.skeleton&&(v.vertexWeights.push(ae[0]),v.vertexWeights.push(ae[1]),v.vertexWeights.push(ae[2]),v.vertexWeights.push(ae[3]),v.vertexWeights.push(ae[(be-1)*4]),v.vertexWeights.push(ae[(be-1)*4+1]),v.vertexWeights.push(ae[(be-1)*4+2]),v.vertexWeights.push(ae[(be-1)*4+3]),v.vertexWeights.push(ae[be*4]),v.vertexWeights.push(ae[be*4+1]),v.vertexWeights.push(ae[be*4+2]),v.vertexWeights.push(ae[be*4+3]),v.weightsIndices.push(Me[0]),v.weightsIndices.push(Me[1]),v.weightsIndices.push(Me[2]),v.weightsIndices.push(Me[3]),v.weightsIndices.push(Me[(be-1)*4]),v.weightsIndices.push(Me[(be-1)*4+1]),v.weightsIndices.push(Me[(be-1)*4+2]),v.weightsIndices.push(Me[(be-1)*4+3]),v.weightsIndices.push(Me[be*4]),v.weightsIndices.push(Me[be*4+1]),v.weightsIndices.push(Me[be*4+2]),v.weightsIndices.push(Me[be*4+3])),L.color&&(v.colors.push(re[0]),v.colors.push(re[1]),v.colors.push(re[2]),v.colors.push(re[(be-1)*3]),v.colors.push(re[(be-1)*3+1]),v.colors.push(re[(be-1)*3+2]),v.colors.push(re[be*3]),v.colors.push(re[be*3+1]),v.colors.push(re[be*3+2])),L.material&&L.material.mappingType!=="AllSame"&&(v.materialIndex.push(D),v.materialIndex.push(D),v.materialIndex.push(D)),L.normal&&(v.normal.push(N[0]),v.normal.push(N[1]),v.normal.push(N[2]),v.normal.push(N[(be-1)*3]),v.normal.push(N[(be-1)*3+1]),v.normal.push(N[(be-1)*3+2]),v.normal.push(N[be*3]),v.normal.push(N[be*3+1]),v.normal.push(N[be*3+2])),L.uv&&L.uv.forEach(function(ot,ct){v.uvs[ct]===void 0&&(v.uvs[ct]=[]),v.uvs[ct].push(ne[ct][0]),v.uvs[ct].push(ne[ct][1]),v.uvs[ct].push(ne[ct][(be-1)*2]),v.uvs[ct].push(ne[ct][(be-1)*2+1]),v.uvs[ct].push(ne[ct][be*2]),v.uvs[ct].push(ne[ct][be*2+1])})}addMorphTargets(v,L,R,D){if(R.length===0)return;v.morphTargetsRelative=!0,v.morphAttributes.position=[];const N=this;R.forEach(function(re){re.rawTargets.forEach(function(ne){const ae=ue.Objects.Geometry[ne.geoID];ae!==void 0&&N.genMorphGeometry(v,L,ae,D,ne.name)})})}genMorphGeometry(v,L,R,D,N){const re=L.PolygonVertexIndex!==void 0?L.PolygonVertexIndex.a:[],ne=R.Vertices!==void 0?R.Vertices.a:[],ae=R.Indexes!==void 0?R.Indexes.a:[],Me=v.attributes.position.count*3,oe=new Float32Array(Me);for(let wt=0;wt<ae.length;wt++){const Jt=ae[wt]*3;oe[Jt]=ne[wt*3],oe[Jt+1]=ne[wt*3+1],oe[Jt+2]=ne[wt*3+2]}const be={vertexIndices:re,vertexPositions:oe},ot=this.genBuffers(be),ct=new u.Float32BufferAttribute(ot.vertex,3);ct.name=N||R.attrName,ct.applyMatrix4(D),v.morphAttributes.position.push(ct)}parseNormals(v){const L=v.MappingInformationType,R=v.ReferenceInformationType,D=v.Normals.a;let N=[];return R==="IndexToDirect"&&("NormalIndex"in v?N=v.NormalIndex.a:"NormalsIndex"in v&&(N=v.NormalsIndex.a)),{dataSize:3,buffer:D,indices:N,mappingType:L,referenceType:R}}parseUVs(v){const L=v.MappingInformationType,R=v.ReferenceInformationType,D=v.UV.a;let N=[];return R==="IndexToDirect"&&(N=v.UVIndex.a),{dataSize:2,buffer:D,indices:N,mappingType:L,referenceType:R}}parseVertexColors(v){const L=v.MappingInformationType,R=v.ReferenceInformationType,D=v.Colors.a;let N=[];return R==="IndexToDirect"&&(N=v.ColorIndex.a),{dataSize:4,buffer:D,indices:N,mappingType:L,referenceType:R}}parseMaterialIndices(v){const L=v.MappingInformationType,R=v.ReferenceInformationType;if(L==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:R};const D=v.Materials.a,N=[];for(let re=0;re<D.length;++re)N.push(re);return{dataSize:1,buffer:D,indices:N,mappingType:L,referenceType:R}}parseNurbsGeometry(v){if(u.NURBSCurve===void 0)return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new u.BufferGeometry;const L=parseInt(v.Order);if(isNaN(L))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",v.Order,v.id),new u.BufferGeometry;const R=L-1,D=v.KnotVector.a,N=[],re=v.Points.a;for(let be=0,ot=re.length;be<ot;be+=4)N.push(new u.Vector4().fromArray(re,be));let ne,ae;if(v.Form==="Closed")N.push(N[0]);else if(v.Form==="Periodic"){ne=R,ae=D.length-1-ne;for(let be=0;be<R;++be)N.push(N[be])}const oe=new u.NURBSCurve(R,D,N,ne,ae).getPoints(N.length*12);return new u.BufferGeometry().setFromPoints(oe)}}class te{parse(){const v=[],L=this.parseClips();if(L!==void 0)for(const R in L){const D=L[R],N=this.addClip(D);v.push(N)}return v}parseClips(){if(ue.Objects.AnimationCurve===void 0)return;const v=this.parseAnimationCurveNodes();this.parseAnimationCurves(v);const L=this.parseAnimationLayers(v);return this.parseAnimStacks(L)}parseAnimationCurveNodes(){const v=ue.Objects.AnimationCurveNode,L=new Map;for(const R in v){const D=v[R];if(D.attrName.match(/S|R|T|DeformPercent/)!==null){const N={id:D.id,attr:D.attrName,curves:{}};L.set(N.id,N)}}return L}parseAnimationCurves(v){const L=ue.Objects.AnimationCurve;for(const R in L){const D={id:L[R].id,times:L[R].KeyTime.a.map(xe),values:L[R].KeyValueFloat.a},N=ve.get(D.id);if(N!==void 0){const re=N.parents[0].ID,ne=N.parents[0].relationship;ne.match(/X/)?v.get(re).curves.x=D:ne.match(/Y/)?v.get(re).curves.y=D:ne.match(/Z/)?v.get(re).curves.z=D:ne.match(/d|DeformPercent/)&&v.has(re)&&(v.get(re).curves.morph=D)}}}parseAnimationLayers(v){const L=ue.Objects.AnimationLayer,R=new Map;for(const D in L){const N=[],re=ve.get(parseInt(D));re!==void 0&&(re.children.forEach(function(ae,Me){if(v.has(ae.ID)){const oe=v.get(ae.ID);if(oe.curves.x!==void 0||oe.curves.y!==void 0||oe.curves.z!==void 0){if(N[Me]===void 0){const be=ve.get(ae.ID).parents.filter(function(ot){return ot.relationship!==void 0})[0].ID;if(be!==void 0){const ot=ue.Objects.Model[be.toString()];if(ot===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",ae);return}const ct={modelName:ot.attrName?u.PropertyBinding.sanitizeNodeName(ot.attrName):"",ID:ot.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};A.traverse(function(wt){wt.ID===ot.id&&(ct.transform=wt.matrix,wt.userData.transformData&&(ct.eulerOrder=wt.userData.transformData.eulerOrder))}),ct.transform||(ct.transform=new u.Matrix4),"PreRotation"in ot&&(ct.preRotation=ot.PreRotation.value),"PostRotation"in ot&&(ct.postRotation=ot.PostRotation.value),N[Me]=ct}}N[Me]&&(N[Me][oe.attr]=oe)}else if(oe.curves.morph!==void 0){if(N[Me]===void 0){const be=ve.get(ae.ID).parents.filter(function(on){return on.relationship!==void 0})[0].ID,ot=ve.get(be).parents[0].ID,ct=ve.get(ot).parents[0].ID,wt=ve.get(ct).parents[0].ID,Jt=ue.Objects.Model[wt],mn={modelName:Jt.attrName?u.PropertyBinding.sanitizeNodeName(Jt.attrName):"",morphName:ue.Objects.Deformer[be].attrName};N[Me]=mn}N[Me][oe.attr]=oe}}}),R.set(parseInt(D),N))}return R}parseAnimStacks(v){const L=ue.Objects.AnimationStack,R={};for(const D in L){const N=ve.get(parseInt(D)).children;N.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const re=v.get(N[0].ID);R[D]={name:L[D].attrName,layer:re}}return R}addClip(v){let L=[];const R=this;return v.layer.forEach(function(D){L=L.concat(R.generateTracks(D))}),new u.AnimationClip(v.name,-1,L)}generateTracks(v){const L=[];let R=new u.Vector3,D=new u.Quaternion,N=new u.Vector3;if(v.transform&&v.transform.decompose(R,D,N),R=R.toArray(),D=new u.Euler().setFromQuaternion(D,v.eulerOrder).toArray(),N=N.toArray(),v.T!==void 0&&Object.keys(v.T.curves).length>0){const re=this.generateVectorTrack(v.modelName,v.T.curves,R,"position");re!==void 0&&L.push(re)}if(v.R!==void 0&&Object.keys(v.R.curves).length>0){const re=this.generateRotationTrack(v.modelName,v.R.curves,D,v.preRotation,v.postRotation,v.eulerOrder);re!==void 0&&L.push(re)}if(v.S!==void 0&&Object.keys(v.S.curves).length>0){const re=this.generateVectorTrack(v.modelName,v.S.curves,N,"scale");re!==void 0&&L.push(re)}if(v.DeformPercent!==void 0){const re=this.generateMorphTrack(v);re!==void 0&&L.push(re)}return L}generateVectorTrack(v,L,R,D){const N=this.getTimesForAllAxes(L),re=this.getKeyframeTrackValues(N,L,R);return new u.VectorKeyframeTrack(v+"."+D,N,re)}generateRotationTrack(v,L,R,D,N,re){L.x!==void 0&&(this.interpolateRotations(L.x),L.x.values=L.x.values.map(u.MathUtils.degToRad)),L.y!==void 0&&(this.interpolateRotations(L.y),L.y.values=L.y.values.map(u.MathUtils.degToRad)),L.z!==void 0&&(this.interpolateRotations(L.z),L.z.values=L.z.values.map(u.MathUtils.degToRad));const ne=this.getTimesForAllAxes(L),ae=this.getKeyframeTrackValues(ne,L,R);D!==void 0&&(D=D.map(u.MathUtils.degToRad),D.push(re),D=new u.Euler().fromArray(D),D=new u.Quaternion().setFromEuler(D)),N!==void 0&&(N=N.map(u.MathUtils.degToRad),N.push(re),N=new u.Euler().fromArray(N),N=new u.Quaternion().setFromEuler(N).invert());const Me=new u.Quaternion,oe=new u.Euler,be=[];for(let ot=0;ot<ae.length;ot+=3)oe.set(ae[ot],ae[ot+1],ae[ot+2],re),Me.setFromEuler(oe),D!==void 0&&Me.premultiply(D),N!==void 0&&Me.multiply(N),Me.toArray(be,ot/3*4);return new u.QuaternionKeyframeTrack(v+".quaternion",ne,be)}generateMorphTrack(v){const L=v.DeformPercent.curves.morph,R=L.values.map(function(N){return N/100}),D=A.getObjectByName(v.modelName).morphTargetDictionary[v.morphName];return new u.NumberKeyframeTrack(v.modelName+".morphTargetInfluences["+D+"]",L.times,R)}getTimesForAllAxes(v){let L=[];if(v.x!==void 0&&(L=L.concat(v.x.times)),v.y!==void 0&&(L=L.concat(v.y.times)),v.z!==void 0&&(L=L.concat(v.z.times)),L=L.sort(function(R,D){return R-D}),L.length>1){let R=1,D=L[0];for(let N=1;N<L.length;N++){const re=L[N];re!==D&&(L[R]=re,D=re,R++)}L=L.slice(0,R)}return L}getKeyframeTrackValues(v,L,R){const D=R,N=[];let re=-1,ne=-1,ae=-1;return v.forEach(function(Me){if(L.x&&(re=L.x.times.indexOf(Me)),L.y&&(ne=L.y.times.indexOf(Me)),L.z&&(ae=L.z.times.indexOf(Me)),re!==-1){const oe=L.x.values[re];N.push(oe),D[0]=oe}else N.push(D[0]);if(ne!==-1){const oe=L.y.values[ne];N.push(oe),D[1]=oe}else N.push(D[1]);if(ae!==-1){const oe=L.z.values[ae];N.push(oe),D[2]=oe}else N.push(D[2])}),N}interpolateRotations(v){for(let L=1;L<v.values.length;L++){const R=v.values[L-1],D=v.values[L]-R,N=Math.abs(D);if(N>=180){const re=N/180,ne=D/re;let ae=R+ne;const Me=v.times[L-1],be=(v.times[L]-Me)/re;let ot=Me+be;const ct=[],wt=[];for(;ot<v.times[L];)ct.push(ot),ot+=be,wt.push(ae),ae+=ne;v.times=yt(v.times,L,ct),v.values=yt(v.values,L,wt)}}}}class q{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(v){this.nodeStack.push(v),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(v,L){this.currentProp=v,this.currentPropName=L}parse(v){this.currentIndent=0,this.allNodes=new et,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const L=this,R=v.split(/[\r\n]+/);return R.forEach(function(D,N){const re=D.match(/^[\s\t]*;/),ne=D.match(/^[\s\t]*$/);if(re||ne)return;const ae=D.match("^\\t{"+L.currentIndent+"}(\\w+):(.*){",""),Me=D.match("^\\t{"+L.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),oe=D.match("^\\t{"+(L.currentIndent-1)+"}}");ae?L.parseNodeBegin(D,ae):Me?L.parseNodeProperty(D,Me,R[++N]):oe?L.popStack():D.match(/^[^\s\t}]/)&&L.parseNodePropertyContinued(D)}),this.allNodes}parseNodeBegin(v,L){const R=L[1].trim().replace(/^"/,"").replace(/"$/,""),D=L[2].split(",").map(function(ae){return ae.trim().replace(/^"/,"").replace(/"$/,"")}),N={name:R},re=this.parseNodeAttr(D),ne=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(R,N):R in ne?(R==="PoseNode"?ne.PoseNode.push(N):ne[R].id!==void 0&&(ne[R]={},ne[R][ne[R].id]=ne[R]),re.id!==""&&(ne[R][re.id]=N)):typeof re.id=="number"?(ne[R]={},ne[R][re.id]=N):R!=="Properties70"&&(R==="PoseNode"?ne[R]=[N]:ne[R]=N),typeof re.id=="number"&&(N.id=re.id),re.name!==""&&(N.attrName=re.name),re.type!==""&&(N.attrType=re.type),this.pushStack(N)}parseNodeAttr(v){let L=v[0];v[0]!==""&&(L=parseInt(v[0]),isNaN(L)&&(L=v[0]));let R="",D="";return v.length>1&&(R=v[1].replace(/^(\w+)::/,""),D=v[2]),{id:L,name:R,type:D}}parseNodeProperty(v,L,R){let D=L[1].replace(/^"/,"").replace(/"$/,"").trim(),N=L[2].replace(/^"/,"").replace(/"$/,"").trim();D==="Content"&&N===","&&(N=R.replace(/"/g,"").replace(/,$/,"").trim());const re=this.getCurrentNode();if(re.name==="Properties70"){this.parseNodeSpecialProperty(v,D,N);return}if(D==="C"){const ae=N.split(",").slice(1),Me=parseInt(ae[0]),oe=parseInt(ae[1]);let be=N.split(",").slice(3);be=be.map(function(ot){return ot.trim().replace(/^"/,"")}),D="connections",N=[Me,oe],Y(N,be),re[D]===void 0&&(re[D]=[])}D==="Node"&&(re.id=N),D in re&&Array.isArray(re[D])?re[D].push(N):D!=="a"?re[D]=N:re.a=N,this.setCurrentProp(re,D),D==="a"&&N.slice(-1)!==","&&(re.a=dt(N))}parseNodePropertyContinued(v){const L=this.getCurrentNode();L.a+=v,v.slice(-1)!==","&&(L.a=dt(L.a))}parseNodeSpecialProperty(v,L,R){const D=R.split('",').map(function(oe){return oe.trim().replace(/^\"/,"").replace(/\s/,"_")}),N=D[0],re=D[1],ne=D[2],ae=D[3];let Me=D[4];switch(re){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":Me=parseFloat(Me);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":Me=dt(Me);break}this.getPrevNode()[N]={type:re,type2:ne,flag:ae,value:Me},this.setCurrentProp(this.getPrevNode(),N)}}class Ie{parse(v){const L=new De(v);L.skip(23);const R=L.getUint32();if(R<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+R);const D=new et;for(;!this.endOfContent(L);){const N=this.parseNode(L,R);N!==null&&D.add(N.name,N)}return D}endOfContent(v){return v.size()%16===0?(v.getOffset()+160+16&-16)>=v.size():v.getOffset()+160+16>=v.size()}parseNode(v,L){const R={},D=L>=7500?v.getUint64():v.getUint32(),N=L>=7500?v.getUint64():v.getUint32();L>=7500?v.getUint64():v.getUint32();const re=v.getUint8(),ne=v.getString(re);if(D===0)return null;const ae=[];for(let ot=0;ot<N;ot++)ae.push(this.parseProperty(v));const Me=ae.length>0?ae[0]:"",oe=ae.length>1?ae[1]:"",be=ae.length>2?ae[2]:"";for(R.singleProperty=N===1&&v.getOffset()===D;D>v.getOffset();){const ot=this.parseNode(v,L);ot!==null&&this.parseSubNode(ne,R,ot)}return R.propertyList=ae,typeof Me=="number"&&(R.id=Me),oe!==""&&(R.attrName=oe),be!==""&&(R.attrType=be),ne!==""&&(R.name=ne),R}parseSubNode(v,L,R){if(R.singleProperty===!0){const D=R.propertyList[0];Array.isArray(D)?(L[R.name]=R,R.a=D):L[R.name]=D}else if(v==="Connections"&&R.name==="C"){const D=[];R.propertyList.forEach(function(N,re){re!==0&&D.push(N)}),L.connections===void 0&&(L.connections=[]),L.connections.push(D)}else if(R.name==="Properties70")Object.keys(R).forEach(function(N){L[N]=R[N]});else if(v==="Properties70"&&R.name==="P"){let D=R.propertyList[0],N=R.propertyList[1];const re=R.propertyList[2],ne=R.propertyList[3];let ae;D.indexOf("Lcl ")===0&&(D=D.replace("Lcl ","Lcl_")),N.indexOf("Lcl ")===0&&(N=N.replace("Lcl ","Lcl_")),N==="Color"||N==="ColorRGB"||N==="Vector"||N==="Vector3D"||N.indexOf("Lcl_")===0?ae=[R.propertyList[4],R.propertyList[5],R.propertyList[6]]:ae=R.propertyList[4],L[D]={type:N,type2:re,flag:ne,value:ae}}else L[R.name]===void 0?typeof R.id=="number"?(L[R.name]={},L[R.name][R.id]=R):L[R.name]=R:R.name==="PoseNode"?(Array.isArray(L[R.name])||(L[R.name]=[L[R.name]]),L[R.name].push(R)):L[R.name][R.id]===void 0&&(L[R.name][R.id]=R)}parseProperty(v){const L=v.getString(1);let R;switch(L){case"C":return v.getBoolean();case"D":return v.getFloat64();case"F":return v.getFloat32();case"I":return v.getInt32();case"L":return v.getInt64();case"R":return R=v.getUint32(),v.getArrayBuffer(R);case"S":return R=v.getUint32(),v.getString(R);case"Y":return v.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const D=v.getUint32(),N=v.getUint32(),re=v.getUint32();if(N===0)switch(L){case"b":case"c":return v.getBooleanArray(D);case"d":return v.getFloat64Array(D);case"f":return v.getFloat32Array(D);case"i":return v.getInt32Array(D);case"l":return v.getInt64Array(D)}typeof me>"u"&&console.error("THREE.FBXLoader: External library fflate.min.js required.");const ne=me.unzlibSync(new Uint8Array(v.getArrayBuffer(re))),ae=new De(ne.buffer);switch(L){case"b":case"c":return ae.getBooleanArray(D);case"d":return ae.getFloat64Array(D);case"f":return ae.getFloat32Array(D);case"i":return ae.getInt32Array(D);case"l":return ae.getInt64Array(D)}default:throw new Error("THREE.FBXLoader: Unknown property type "+L)}}}class De{constructor(v,L){this.dv=new DataView(v),this.offset=0,this.littleEndian=L!==void 0?L:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(v){this.offset+=v}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(v){const L=[];for(let R=0;R<v;R++)L.push(this.getBoolean());return L}getUint8(){const v=this.dv.getUint8(this.offset);return this.offset+=1,v}getInt16(){const v=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,v}getInt32(){const v=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,v}getInt32Array(v){const L=[];for(let R=0;R<v;R++)L.push(this.getInt32());return L}getUint32(){const v=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,v}getInt64(){let v,L;return this.littleEndian?(v=this.getUint32(),L=this.getUint32()):(L=this.getUint32(),v=this.getUint32()),L&2147483648?(L=~L&4294967295,v=~v&4294967295,v===4294967295&&(L=L+1&4294967295),v=v+1&4294967295,-(L*4294967296+v)):L*4294967296+v}getInt64Array(v){const L=[];for(let R=0;R<v;R++)L.push(this.getInt64());return L}getUint64(){let v,L;return this.littleEndian?(v=this.getUint32(),L=this.getUint32()):(L=this.getUint32(),v=this.getUint32()),L*4294967296+v}getFloat32(){const v=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,v}getFloat32Array(v){const L=[];for(let R=0;R<v;R++)L.push(this.getFloat32());return L}getFloat64(){const v=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,v}getFloat64Array(v){const L=[];for(let R=0;R<v;R++)L.push(this.getFloat64());return L}getArrayBuffer(v){const L=this.dv.buffer.slice(this.offset,this.offset+v);return this.offset+=v,L}getString(v){let L=[];for(let D=0;D<v;D++)L[D]=this.getUint8();const R=L.indexOf(0);return R>=0&&(L=L.slice(0,R)),u.LoaderUtils.decodeText(new Uint8Array(L))}}class et{add(v,L){this[v]=L}}function ie(He){const v="Kaydara FBX Binary  \0";return He.byteLength>=v.length&&v===Q(He,0,v.length)}function le(He){const v=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let L=0;function R(D){const N=He[D-1];return He=He.slice(L+D),L++,N}for(let D=0;D<v.length;++D)if(R(1)===v[D])return!1;return!0}function Oe(He){const v=/FBXVersion: (\d+)/,L=He.match(v);if(L)return parseInt(L[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function xe(He){return He/46186158e3}const tt=[];function bt(He,v,L,R){let D;switch(R.mappingType){case"ByPolygonVertex":D=He;break;case"ByPolygon":D=v;break;case"ByVertice":D=L;break;case"AllSame":D=R.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+R.mappingType)}R.referenceType==="IndexToDirect"&&(D=R.indices[D]);const N=D*R.dataSize,re=N+R.dataSize;return Be(tt,R.buffer,N,re)}const de=new u.Euler,ge=new u.Vector3;function Ge(He){const v=new u.Matrix4,L=new u.Matrix4,R=new u.Matrix4,D=new u.Matrix4,N=new u.Matrix4,re=new u.Matrix4,ne=new u.Matrix4,ae=new u.Matrix4,Me=new u.Matrix4,oe=new u.Matrix4,be=new u.Matrix4,ot=new u.Matrix4,ct=He.inheritType?He.inheritType:0;if(He.translation&&v.setPosition(ge.fromArray(He.translation)),He.preRotation){const ee=He.preRotation.map(u.MathUtils.degToRad);ee.push(He.eulerOrder),L.makeRotationFromEuler(de.fromArray(ee))}if(He.rotation){const ee=He.rotation.map(u.MathUtils.degToRad);ee.push(He.eulerOrder),R.makeRotationFromEuler(de.fromArray(ee))}if(He.postRotation){const ee=He.postRotation.map(u.MathUtils.degToRad);ee.push(He.eulerOrder),D.makeRotationFromEuler(de.fromArray(ee)),D.invert()}He.scale&&N.scale(ge.fromArray(He.scale)),He.scalingOffset&&ne.setPosition(ge.fromArray(He.scalingOffset)),He.scalingPivot&&re.setPosition(ge.fromArray(He.scalingPivot)),He.rotationOffset&&ae.setPosition(ge.fromArray(He.rotationOffset)),He.rotationPivot&&Me.setPosition(ge.fromArray(He.rotationPivot)),He.parentMatrixWorld&&(be.copy(He.parentMatrix),oe.copy(He.parentMatrixWorld));const wt=L.clone().multiply(R).multiply(D),Jt=new u.Matrix4;Jt.extractRotation(oe);const mn=new u.Matrix4;mn.copyPosition(oe);const on=mn.clone().invert().multiply(oe),yn=Jt.clone().invert().multiply(on),cn=N,gn=new u.Matrix4;if(ct===0)gn.copy(Jt).multiply(wt).multiply(yn).multiply(cn);else if(ct===1)gn.copy(Jt).multiply(yn).multiply(wt).multiply(cn);else{const se=new u.Matrix4().scale(new u.Vector3().setFromMatrixScale(be)).clone().invert(),fe=yn.clone().multiply(se);gn.copy(Jt).multiply(wt).multiply(fe).multiply(cn)}const nt=Me.clone().invert(),z=re.clone().invert();let B=v.clone().multiply(ae).multiply(Me).multiply(L).multiply(R).multiply(D).multiply(nt).multiply(ne).multiply(re).multiply(N).multiply(z);const $=new u.Matrix4().copyPosition(B),V=oe.clone().multiply($);return ot.copyPosition(V),B=ot.clone().multiply(gn),B.premultiply(oe.invert()),B}function gt(He){He=He||0;const v=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return He===6?(console.warn("THREE.FBXLoader: unsupported THREE.Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),v[0]):v[He]}function dt(He){return He.split(",").map(function(L){return parseFloat(L)})}function Q(He,v,L){return v===void 0&&(v=0),L===void 0&&(L=He.byteLength),u.LoaderUtils.decodeText(new Uint8Array(He,v,L))}function Y(He,v){for(let L=0,R=He.length,D=v.length;L<D;L++,R++)He[R]=v[L]}function Be(He,v,L,R){for(let D=L,N=0;D<R;D++,N++)He[N]=v[D];return He}function yt(He,v,L){return He.slice(0,v).concat(L).concat(He.slice(v))}u.FBXLoader=g})(),Yt.exports=u.FBXLoader})(Th);var $p=Th.exports,Eh={exports:{}};(function(Yt,Mn){const u=si;(function(){class me extends u.Loader{constructor(z){super(z),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(B){return new G(B)}),this.register(function(B){return new De(B)}),this.register(function(B){return new et(B)}),this.register(function(B){return new C(B)}),this.register(function(B){return new te(B)}),this.register(function(B){return new q(B)}),this.register(function(B){return new Ie(B)}),this.register(function(B){return new A(B)}),this.register(function(B){return new ie(B)})}load(z,B,$,V){const ee=this;let se;this.resourcePath!==""?se=this.resourcePath:this.path!==""?se=this.path:se=u.LoaderUtils.extractUrlBase(z),this.manager.itemStart(z);const fe=function(Re){V?V(Re):console.error(Re),ee.manager.itemError(z),ee.manager.itemEnd(z)},he=new u.FileLoader(this.manager);he.setPath(this.path),he.setResponseType("arraybuffer"),he.setRequestHeader(this.requestHeader),he.setWithCredentials(this.withCredentials),he.load(z,function(Re){try{ee.parse(Re,se,function(it){B(it),ee.manager.itemEnd(z)},fe)}catch(it){fe(it)}},$,fe)}setDRACOLoader(z){return this.dracoLoader=z,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(z){return this.ktx2Loader=z,this}setMeshoptDecoder(z){return this.meshoptDecoder=z,this}register(z){return this.pluginCallbacks.indexOf(z)===-1&&this.pluginCallbacks.push(z),this}unregister(z){return this.pluginCallbacks.indexOf(z)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(z),1),this}parse(z,B,$,V){let ee;const se={},fe={};if(typeof z=="string")ee=z;else if(u.LoaderUtils.decodeText(new Uint8Array(z,0,4))===le){try{se[ve.KHR_BINARY_GLTF]=new tt(z)}catch(st){V&&V(st);return}ee=se[ve.KHR_BINARY_GLTF].content}else ee=u.LoaderUtils.decodeText(new Uint8Array(z));const he=JSON.parse(ee);if(he.asset===void 0||he.asset.version[0]<2){V&&V(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const Re=new mn(he,{path:B||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});Re.fileLoader.setRequestHeader(this.requestHeader);for(let it=0;it<this.pluginCallbacks.length;it++){const st=this.pluginCallbacks[it](Re);fe[st.name]=st,se[st.name]=!0}if(he.extensionsUsed)for(let it=0;it<he.extensionsUsed.length;++it){const st=he.extensionsUsed[it],It=he.extensionsRequired||[];switch(st){case ve.KHR_MATERIALS_UNLIT:se[st]=new g;break;case ve.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:se[st]=new Ge;break;case ve.KHR_DRACO_MESH_COMPRESSION:se[st]=new bt(he,this.dracoLoader);break;case ve.KHR_TEXTURE_TRANSFORM:se[st]=new de;break;case ve.KHR_MESH_QUANTIZATION:se[st]=new gt;break;default:It.indexOf(st)>=0&&fe[st]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+st+'".')}}Re.setExtensions(se),Re.setPlugins(fe),Re.parse($,V)}}function ue(){let nt={};return{get:function(z){return nt[z]},add:function(z,B){nt[z]=B},remove:function(z){delete nt[z]},removeAll:function(){nt={}}}}const ve={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class A{constructor(z){this.parser=z,this.name=ve.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const z=this.parser,B=this.parser.json.nodes||[];for(let $=0,V=B.length;$<V;$++){const ee=B[$];ee.extensions&&ee.extensions[this.name]&&ee.extensions[this.name].light!==void 0&&z._addNodeRef(this.cache,ee.extensions[this.name].light)}}_loadLight(z){const B=this.parser,$="light:"+z;let V=B.cache.get($);if(V)return V;const ee=B.json,he=((ee.extensions&&ee.extensions[this.name]||{}).lights||[])[z];let Re;const it=new u.Color(16777215);he.color!==void 0&&it.fromArray(he.color);const st=he.range!==void 0?he.range:0;switch(he.type){case"directional":Re=new u.DirectionalLight(it),Re.target.position.set(0,0,-1),Re.add(Re.target);break;case"point":Re=new u.PointLight(it),Re.distance=st;break;case"spot":Re=new u.SpotLight(it),Re.distance=st,he.spot=he.spot||{},he.spot.innerConeAngle=he.spot.innerConeAngle!==void 0?he.spot.innerConeAngle:0,he.spot.outerConeAngle=he.spot.outerConeAngle!==void 0?he.spot.outerConeAngle:Math.PI/4,Re.angle=he.spot.outerConeAngle,Re.penumbra=1-he.spot.innerConeAngle/he.spot.outerConeAngle,Re.target.position.set(0,0,-1),Re.add(Re.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+he.type)}return Re.position.set(0,0,0),Re.decay=2,he.intensity!==void 0&&(Re.intensity=he.intensity),Re.name=B.createUniqueName(he.name||"light_"+z),V=Promise.resolve(Re),B.cache.add($,V),V}createNodeAttachment(z){const B=this,$=this.parser,ee=$.json.nodes[z],fe=(ee.extensions&&ee.extensions[this.name]||{}).light;return fe===void 0?null:this._loadLight(fe).then(function(he){return $._getNodeRef(B.cache,fe,he)})}}class g{constructor(){this.name=ve.KHR_MATERIALS_UNLIT}getMaterialType(){return u.MeshBasicMaterial}extendParams(z,B,$){const V=[];z.color=new u.Color(1,1,1),z.opacity=1;const ee=B.pbrMetallicRoughness;if(ee){if(Array.isArray(ee.baseColorFactor)){const se=ee.baseColorFactor;z.color.fromArray(se),z.opacity=se[3]}ee.baseColorTexture!==void 0&&V.push($.assignTexture(z,"map",ee.baseColorTexture))}return Promise.all(V)}}class G{constructor(z){this.parser=z,this.name=ve.KHR_MATERIALS_CLEARCOAT}getMaterialType(z){const $=this.parser.json.materials[z];return!$.extensions||!$.extensions[this.name]?null:u.MeshPhysicalMaterial}extendMaterialParams(z,B){const $=this.parser,V=$.json.materials[z];if(!V.extensions||!V.extensions[this.name])return Promise.resolve();const ee=[],se=V.extensions[this.name];if(se.clearcoatFactor!==void 0&&(B.clearcoat=se.clearcoatFactor),se.clearcoatTexture!==void 0&&ee.push($.assignTexture(B,"clearcoatMap",se.clearcoatTexture)),se.clearcoatRoughnessFactor!==void 0&&(B.clearcoatRoughness=se.clearcoatRoughnessFactor),se.clearcoatRoughnessTexture!==void 0&&ee.push($.assignTexture(B,"clearcoatRoughnessMap",se.clearcoatRoughnessTexture)),se.clearcoatNormalTexture!==void 0&&(ee.push($.assignTexture(B,"clearcoatNormalMap",se.clearcoatNormalTexture)),se.clearcoatNormalTexture.scale!==void 0)){const fe=se.clearcoatNormalTexture.scale;B.clearcoatNormalScale=new u.Vector2(fe,-fe)}return Promise.all(ee)}}class C{constructor(z){this.parser=z,this.name=ve.KHR_MATERIALS_TRANSMISSION}getMaterialType(z){const $=this.parser.json.materials[z];return!$.extensions||!$.extensions[this.name]?null:u.MeshPhysicalMaterial}extendMaterialParams(z,B){const $=this.parser,V=$.json.materials[z];if(!V.extensions||!V.extensions[this.name])return Promise.resolve();const ee=[],se=V.extensions[this.name];return se.transmissionFactor!==void 0&&(B.transmission=se.transmissionFactor),se.transmissionTexture!==void 0&&ee.push($.assignTexture(B,"transmissionMap",se.transmissionTexture)),Promise.all(ee)}}class te{constructor(z){this.parser=z,this.name=ve.KHR_MATERIALS_VOLUME}getMaterialType(z){const $=this.parser.json.materials[z];return!$.extensions||!$.extensions[this.name]?null:u.MeshPhysicalMaterial}extendMaterialParams(z,B){const $=this.parser,V=$.json.materials[z];if(!V.extensions||!V.extensions[this.name])return Promise.resolve();const ee=[],se=V.extensions[this.name];B.thickness=se.thicknessFactor!==void 0?se.thicknessFactor:0,se.thicknessTexture!==void 0&&ee.push($.assignTexture(B,"thicknessMap",se.thicknessTexture)),B.attenuationDistance=se.attenuationDistance||0;const fe=se.attenuationColor||[1,1,1];return B.attenuationTint=new u.Color(fe[0],fe[1],fe[2]),Promise.all(ee)}}class q{constructor(z){this.parser=z,this.name=ve.KHR_MATERIALS_IOR}getMaterialType(z){const $=this.parser.json.materials[z];return!$.extensions||!$.extensions[this.name]?null:u.MeshPhysicalMaterial}extendMaterialParams(z,B){const V=this.parser.json.materials[z];if(!V.extensions||!V.extensions[this.name])return Promise.resolve();const ee=V.extensions[this.name];return B.ior=ee.ior!==void 0?ee.ior:1.5,Promise.resolve()}}class Ie{constructor(z){this.parser=z,this.name=ve.KHR_MATERIALS_SPECULAR}getMaterialType(z){const $=this.parser.json.materials[z];return!$.extensions||!$.extensions[this.name]?null:u.MeshPhysicalMaterial}extendMaterialParams(z,B){const $=this.parser,V=$.json.materials[z];if(!V.extensions||!V.extensions[this.name])return Promise.resolve();const ee=[],se=V.extensions[this.name];B.specularIntensity=se.specularFactor!==void 0?se.specularFactor:1,se.specularTexture!==void 0&&ee.push($.assignTexture(B,"specularIntensityMap",se.specularTexture));const fe=se.specularColorFactor||[1,1,1];return B.specularTint=new u.Color(fe[0],fe[1],fe[2]),se.specularColorTexture!==void 0&&ee.push($.assignTexture(B,"specularTintMap",se.specularColorTexture).then(function(he){he.encoding=u.sRGBEncoding})),Promise.all(ee)}}class De{constructor(z){this.parser=z,this.name=ve.KHR_TEXTURE_BASISU}loadTexture(z){const B=this.parser,$=B.json,V=$.textures[z];if(!V.extensions||!V.extensions[this.name])return null;const ee=V.extensions[this.name],se=$.images[ee.source],fe=B.options.ktx2Loader;if(!fe){if($.extensionsRequired&&$.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return B.loadTextureImage(z,se,fe)}}class et{constructor(z){this.parser=z,this.name=ve.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(z){const B=this.name,$=this.parser,V=$.json,ee=V.textures[z];if(!ee.extensions||!ee.extensions[B])return null;const se=ee.extensions[B],fe=V.images[se.source];let he=$.textureLoader;if(fe.uri){const Re=$.options.manager.getHandler(fe.uri);Re!==null&&(he=Re)}return this.detectSupport().then(function(Re){if(Re)return $.loadTextureImage(z,fe,he);if(V.extensionsRequired&&V.extensionsRequired.indexOf(B)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return $.loadTexture(z)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(z){const B=new Image;B.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",B.onload=B.onerror=function(){z(B.height===1)}})),this.isSupported}}class ie{constructor(z){this.name=ve.EXT_MESHOPT_COMPRESSION,this.parser=z}loadBufferView(z){const B=this.parser.json,$=B.bufferViews[z];if($.extensions&&$.extensions[this.name]){const V=$.extensions[this.name],ee=this.parser.getDependency("buffer",V.buffer),se=this.parser.options.meshoptDecoder;if(!se||!se.supported){if(B.extensionsRequired&&B.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([ee,se.ready]).then(function(fe){const he=V.byteOffset||0,Re=V.byteLength||0,it=V.count,st=V.byteStride,It=new ArrayBuffer(it*st),Nt=new Uint8Array(fe[0],he,Re);return se.decodeGltfBuffer(new Uint8Array(It),it,st,Nt,V.mode,V.filter),It})}else return null}}const le="glTF",Oe=12,xe={JSON:1313821514,BIN:5130562};class tt{constructor(z){this.name=ve.KHR_BINARY_GLTF,this.content=null,this.body=null;const B=new DataView(z,0,Oe);if(this.header={magic:u.LoaderUtils.decodeText(new Uint8Array(z.slice(0,4))),version:B.getUint32(4,!0),length:B.getUint32(8,!0)},this.header.magic!==le)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const $=this.header.length-Oe,V=new DataView(z,Oe);let ee=0;for(;ee<$;){const se=V.getUint32(ee,!0);ee+=4;const fe=V.getUint32(ee,!0);if(ee+=4,fe===xe.JSON){const he=new Uint8Array(z,Oe+ee,se);this.content=u.LoaderUtils.decodeText(he)}else if(fe===xe.BIN){const he=Oe+ee;this.body=z.slice(he,he+se)}ee+=se}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class bt{constructor(z,B){if(!B)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ve.KHR_DRACO_MESH_COMPRESSION,this.json=z,this.dracoLoader=B,this.dracoLoader.preload()}decodePrimitive(z,B){const $=this.json,V=this.dracoLoader,ee=z.extensions[this.name].bufferView,se=z.extensions[this.name].attributes,fe={},he={},Re={};for(const it in se){const st=R[it]||it.toLowerCase();fe[st]=se[it]}for(const it in z.attributes){const st=R[it]||it.toLowerCase();if(se[it]!==void 0){const It=$.accessors[z.attributes[it]],Nt=yt[It.componentType];Re[st]=Nt,he[st]=It.normalized===!0}}return B.getDependency("bufferView",ee).then(function(it){return new Promise(function(st){V.decodeDracoFile(it,function(It){for(const Nt in It.attributes){const Ut=It.attributes[Nt],Bt=he[Nt];Bt!==void 0&&(Ut.normalized=Bt)}st(It)},fe,Re)})})}}class de{constructor(){this.name=ve.KHR_TEXTURE_TRANSFORM}extendTexture(z,B){return B.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),B.offset===void 0&&B.rotation===void 0&&B.scale===void 0||(z=z.clone(),B.offset!==void 0&&z.offset.fromArray(B.offset),B.rotation!==void 0&&(z.rotation=B.rotation),B.scale!==void 0&&z.repeat.fromArray(B.scale),z.needsUpdate=!0),z}}class ge extends u.MeshStandardMaterial{constructor(z){super(),this.isGLTFSpecularGlossinessMaterial=!0;const B=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),$=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),V=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	texelSpecular = sRGBToLinear( texelSpecular );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),ee=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),se=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),fe={specular:{value:new u.Color().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=fe,this.onBeforeCompile=function(he){for(const Re in fe)he.uniforms[Re]=fe[Re];he.fragmentShader=he.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",B).replace("#include <metalnessmap_pars_fragment>",$).replace("#include <roughnessmap_fragment>",V).replace("#include <metalnessmap_fragment>",ee).replace("#include <lights_physical_fragment>",se)},Object.defineProperties(this,{specular:{get:function(){return fe.specular.value},set:function(he){fe.specular.value=he}},specularMap:{get:function(){return fe.specularMap.value},set:function(he){fe.specularMap.value=he,he?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return fe.glossiness.value},set:function(he){fe.glossiness.value=he}},glossinessMap:{get:function(){return fe.glossinessMap.value},set:function(he){fe.glossinessMap.value=he,he?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(z)}copy(z){return super.copy(z),this.specularMap=z.specularMap,this.specular.copy(z.specular),this.glossinessMap=z.glossinessMap,this.glossiness=z.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class Ge{constructor(){this.name=ve.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return ge}extendParams(z,B,$){const V=B.extensions[this.name];z.color=new u.Color(1,1,1),z.opacity=1;const ee=[];if(Array.isArray(V.diffuseFactor)){const se=V.diffuseFactor;z.color.fromArray(se),z.opacity=se[3]}if(V.diffuseTexture!==void 0&&ee.push($.assignTexture(z,"map",V.diffuseTexture)),z.emissive=new u.Color(0,0,0),z.glossiness=V.glossinessFactor!==void 0?V.glossinessFactor:1,z.specular=new u.Color(1,1,1),Array.isArray(V.specularFactor)&&z.specular.fromArray(V.specularFactor),V.specularGlossinessTexture!==void 0){const se=V.specularGlossinessTexture;ee.push($.assignTexture(z,"glossinessMap",se)),ee.push($.assignTexture(z,"specularMap",se))}return Promise.all(ee)}createMaterial(z){const B=new ge(z);return B.fog=!0,B.color=z.color,B.map=z.map===void 0?null:z.map,B.lightMap=null,B.lightMapIntensity=1,B.aoMap=z.aoMap===void 0?null:z.aoMap,B.aoMapIntensity=1,B.emissive=z.emissive,B.emissiveIntensity=1,B.emissiveMap=z.emissiveMap===void 0?null:z.emissiveMap,B.bumpMap=z.bumpMap===void 0?null:z.bumpMap,B.bumpScale=1,B.normalMap=z.normalMap===void 0?null:z.normalMap,B.normalMapType=u.TangentSpaceNormalMap,z.normalScale&&(B.normalScale=z.normalScale),B.displacementMap=null,B.displacementScale=1,B.displacementBias=0,B.specularMap=z.specularMap===void 0?null:z.specularMap,B.specular=z.specular,B.glossinessMap=z.glossinessMap===void 0?null:z.glossinessMap,B.glossiness=z.glossiness,B.alphaMap=null,B.envMap=z.envMap===void 0?null:z.envMap,B.envMapIntensity=1,B.refractionRatio=.98,B}}class gt{constructor(){this.name=ve.KHR_MESH_QUANTIZATION}}class dt extends u.Interpolant{constructor(z,B,$,V){super(z,B,$,V)}copySampleValue_(z){const B=this.resultBuffer,$=this.sampleValues,V=this.valueSize,ee=z*V*3+V;for(let se=0;se!==V;se++)B[se]=$[ee+se];return B}}dt.prototype.beforeStart_=dt.prototype.copySampleValue_,dt.prototype.afterEnd_=dt.prototype.copySampleValue_,dt.prototype.interpolate_=function(nt,z,B,$){const V=this.resultBuffer,ee=this.sampleValues,se=this.valueSize,fe=se*2,he=se*3,Re=$-z,it=(B-z)/Re,st=it*it,It=st*it,Nt=nt*he,Ut=Nt-he,Bt=-2*It+3*st,At=It-st,Vt=1-Bt,Tn=At-st+it;for(let bn=0;bn!==se;bn++){const ti=ee[Ut+bn+se],ni=ee[Ut+bn+fe]*Re,at=ee[Nt+bn+se],hn=ee[Nt+bn]*Re;V[bn]=Vt*ti+Tn*ni+Bt*at+At*hn}return V};const Q=new u.Quaternion;class Y extends dt{interpolate_(z,B,$,V){const ee=super.interpolate_(z,B,$,V);return Q.fromArray(ee).normalize().toArray(ee),ee}}const Be={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},yt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},He={9728:u.NearestFilter,9729:u.LinearFilter,9984:u.NearestMipmapNearestFilter,9985:u.LinearMipmapNearestFilter,9986:u.NearestMipmapLinearFilter,9987:u.LinearMipmapLinearFilter},v={33071:u.ClampToEdgeWrapping,33648:u.MirroredRepeatWrapping,10497:u.RepeatWrapping},L={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},R={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},D={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},N={CUBICSPLINE:void 0,LINEAR:u.InterpolateLinear,STEP:u.InterpolateDiscrete},re={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function ne(nt,z){return typeof nt!="string"||nt===""?"":(/^https?:\/\//i.test(z)&&/^\//.test(nt)&&(z=z.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(nt)||/^data:.*,.*$/i.test(nt)||/^blob:.*$/i.test(nt)?nt:z+nt)}function ae(nt){return nt.DefaultMaterial===void 0&&(nt.DefaultMaterial=new u.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:u.FrontSide})),nt.DefaultMaterial}function Me(nt,z,B){for(const $ in B.extensions)nt[$]===void 0&&(z.userData.gltfExtensions=z.userData.gltfExtensions||{},z.userData.gltfExtensions[$]=B.extensions[$])}function oe(nt,z){z.extras!==void 0&&(typeof z.extras=="object"?Object.assign(nt.userData,z.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+z.extras))}function be(nt,z,B){let $=!1,V=!1;for(let fe=0,he=z.length;fe<he;fe++){const Re=z[fe];if(Re.POSITION!==void 0&&($=!0),Re.NORMAL!==void 0&&(V=!0),$&&V)break}if(!$&&!V)return Promise.resolve(nt);const ee=[],se=[];for(let fe=0,he=z.length;fe<he;fe++){const Re=z[fe];if($){const it=Re.POSITION!==void 0?B.getDependency("accessor",Re.POSITION):nt.attributes.position;ee.push(it)}if(V){const it=Re.NORMAL!==void 0?B.getDependency("accessor",Re.NORMAL):nt.attributes.normal;se.push(it)}}return Promise.all([Promise.all(ee),Promise.all(se)]).then(function(fe){const he=fe[0],Re=fe[1];return $&&(nt.morphAttributes.position=he),V&&(nt.morphAttributes.normal=Re),nt.morphTargetsRelative=!0,nt})}function ot(nt,z){if(nt.updateMorphTargets(),z.weights!==void 0)for(let B=0,$=z.weights.length;B<$;B++)nt.morphTargetInfluences[B]=z.weights[B];if(z.extras&&Array.isArray(z.extras.targetNames)){const B=z.extras.targetNames;if(nt.morphTargetInfluences.length===B.length){nt.morphTargetDictionary={};for(let $=0,V=B.length;$<V;$++)nt.morphTargetDictionary[B[$]]=$}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function ct(nt){const z=nt.extensions&&nt.extensions[ve.KHR_DRACO_MESH_COMPRESSION];let B;return z?B="draco:"+z.bufferView+":"+z.indices+":"+wt(z.attributes):B=nt.indices+":"+wt(nt.attributes)+":"+nt.mode,B}function wt(nt){let z="";const B=Object.keys(nt).sort();for(let $=0,V=B.length;$<V;$++)z+=B[$]+":"+nt[B[$]]+";";return z}function Jt(nt){switch(nt){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class mn{constructor(z={},B={}){this.json=z,this.extensions={},this.plugins={},this.options=B,this.cache=new ue,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.textureCache={},this.nodeNamesUsed={},typeof createImageBitmap<"u"&&/Firefox/.test(navigator.userAgent)===!1?this.textureLoader=new u.ImageBitmapLoader(this.options.manager):this.textureLoader=new u.TextureLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new u.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(z){this.extensions=z}setPlugins(z){this.plugins=z}parse(z,B){const $=this,V=this.json,ee=this.extensions;this.cache.removeAll(),this._invokeAll(function(se){return se._markDefs&&se._markDefs()}),Promise.all(this._invokeAll(function(se){return se.beforeRoot&&se.beforeRoot()})).then(function(){return Promise.all([$.getDependencies("scene"),$.getDependencies("animation"),$.getDependencies("camera")])}).then(function(se){const fe={scene:se[0][V.scene||0],scenes:se[0],animations:se[1],cameras:se[2],asset:V.asset,parser:$,userData:{}};Me(ee,fe,V),oe(fe,V),Promise.all($._invokeAll(function(he){return he.afterRoot&&he.afterRoot(fe)})).then(function(){z(fe)})}).catch(B)}_markDefs(){const z=this.json.nodes||[],B=this.json.skins||[],$=this.json.meshes||[];for(let V=0,ee=B.length;V<ee;V++){const se=B[V].joints;for(let fe=0,he=se.length;fe<he;fe++)z[se[fe]].isBone=!0}for(let V=0,ee=z.length;V<ee;V++){const se=z[V];se.mesh!==void 0&&(this._addNodeRef(this.meshCache,se.mesh),se.skin!==void 0&&($[se.mesh].isSkinnedMesh=!0)),se.camera!==void 0&&this._addNodeRef(this.cameraCache,se.camera)}}_addNodeRef(z,B){B!==void 0&&(z.refs[B]===void 0&&(z.refs[B]=z.uses[B]=0),z.refs[B]++)}_getNodeRef(z,B,$){if(z.refs[B]<=1)return $;const V=$.clone();return V.name+="_instance_"+z.uses[B]++,V}_invokeOne(z){const B=Object.values(this.plugins);B.push(this);for(let $=0;$<B.length;$++){const V=z(B[$]);if(V)return V}return null}_invokeAll(z){const B=Object.values(this.plugins);B.unshift(this);const $=[];for(let V=0;V<B.length;V++){const ee=z(B[V]);ee&&$.push(ee)}return $}getDependency(z,B){const $=z+":"+B;let V=this.cache.get($);if(!V){switch(z){case"scene":V=this.loadScene(B);break;case"node":V=this.loadNode(B);break;case"mesh":V=this._invokeOne(function(ee){return ee.loadMesh&&ee.loadMesh(B)});break;case"accessor":V=this.loadAccessor(B);break;case"bufferView":V=this._invokeOne(function(ee){return ee.loadBufferView&&ee.loadBufferView(B)});break;case"buffer":V=this.loadBuffer(B);break;case"material":V=this._invokeOne(function(ee){return ee.loadMaterial&&ee.loadMaterial(B)});break;case"texture":V=this._invokeOne(function(ee){return ee.loadTexture&&ee.loadTexture(B)});break;case"skin":V=this.loadSkin(B);break;case"animation":V=this.loadAnimation(B);break;case"camera":V=this.loadCamera(B);break;default:throw new Error("Unknown type: "+z)}this.cache.add($,V)}return V}getDependencies(z){let B=this.cache.get(z);if(!B){const $=this,V=this.json[z+(z==="mesh"?"es":"s")]||[];B=Promise.all(V.map(function(ee,se){return $.getDependency(z,se)})),this.cache.add(z,B)}return B}loadBuffer(z){const B=this.json.buffers[z],$=this.fileLoader;if(B.type&&B.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+B.type+" buffer type is not supported.");if(B.uri===void 0&&z===0)return Promise.resolve(this.extensions[ve.KHR_BINARY_GLTF].body);const V=this.options;return new Promise(function(ee,se){$.load(ne(B.uri,V.path),ee,void 0,function(){se(new Error('THREE.GLTFLoader: Failed to load buffer "'+B.uri+'".'))})})}loadBufferView(z){const B=this.json.bufferViews[z];return this.getDependency("buffer",B.buffer).then(function($){const V=B.byteLength||0,ee=B.byteOffset||0;return $.slice(ee,ee+V)})}loadAccessor(z){const B=this,$=this.json,V=this.json.accessors[z];if(V.bufferView===void 0&&V.sparse===void 0)return Promise.resolve(null);const ee=[];return V.bufferView!==void 0?ee.push(this.getDependency("bufferView",V.bufferView)):ee.push(null),V.sparse!==void 0&&(ee.push(this.getDependency("bufferView",V.sparse.indices.bufferView)),ee.push(this.getDependency("bufferView",V.sparse.values.bufferView))),Promise.all(ee).then(function(se){const fe=se[0],he=L[V.type],Re=yt[V.componentType],it=Re.BYTES_PER_ELEMENT,st=it*he,It=V.byteOffset||0,Nt=V.bufferView!==void 0?$.bufferViews[V.bufferView].byteStride:void 0,Ut=V.normalized===!0;let Bt,At;if(Nt&&Nt!==st){const Vt=Math.floor(It/Nt),Tn="InterleavedBuffer:"+V.bufferView+":"+V.componentType+":"+Vt+":"+V.count;let bn=B.cache.get(Tn);bn||(Bt=new Re(fe,Vt*Nt,V.count*Nt/it),bn=new u.InterleavedBuffer(Bt,Nt/it),B.cache.add(Tn,bn)),At=new u.InterleavedBufferAttribute(bn,he,It%Nt/it,Ut)}else fe===null?Bt=new Re(V.count*he):Bt=new Re(fe,It,V.count*he),At=new u.BufferAttribute(Bt,he,Ut);if(V.sparse!==void 0){const Vt=L.SCALAR,Tn=yt[V.sparse.indices.componentType],bn=V.sparse.indices.byteOffset||0,ti=V.sparse.values.byteOffset||0,ni=new Tn(se[1],bn,V.sparse.count*Vt),at=new Re(se[2],ti,V.sparse.count*he);fe!==null&&(At=new u.BufferAttribute(At.array.slice(),At.itemSize,At.normalized));for(let hn=0,Rn=ni.length;hn<Rn;hn++){const Wn=ni[hn];if(At.setX(Wn,at[hn*he]),he>=2&&At.setY(Wn,at[hn*he+1]),he>=3&&At.setZ(Wn,at[hn*he+2]),he>=4&&At.setW(Wn,at[hn*he+3]),he>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.")}}return At})}loadTexture(z){const B=this.json,$=this.options,V=B.textures[z],ee=B.images[V.source];let se=this.textureLoader;if(ee.uri){const fe=$.manager.getHandler(ee.uri);fe!==null&&(se=fe)}return this.loadTextureImage(z,ee,se)}loadTextureImage(z,B,$){const V=this,ee=this.json,se=this.options,fe=ee.textures[z],he=(B.uri||B.bufferView)+":"+fe.sampler;if(this.textureCache[he])return this.textureCache[he];const Re=self.URL||self.webkitURL;let it=B.uri||"",st=!1,It=!0;const Nt=it.search(/\.jpe?g($|\?)/i)>0||it.search(/^data\:image\/jpeg/)===0;if((B.mimeType==="image/jpeg"||Nt)&&(It=!1),B.bufferView!==void 0)it=V.getDependency("bufferView",B.bufferView).then(function(Bt){if(B.mimeType==="image/png"){const Vt=new DataView(Bt,25,1).getUint8(0,!1);It=Vt===6||Vt===4||Vt===3}st=!0;const At=new Blob([Bt],{type:B.mimeType});return it=Re.createObjectURL(At),it});else if(B.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+z+" is missing URI and bufferView");const Ut=Promise.resolve(it).then(function(Bt){return new Promise(function(At,Vt){let Tn=At;$.isImageBitmapLoader===!0&&(Tn=function(bn){const ti=new u.Texture(bn);ti.needsUpdate=!0,At(ti)}),$.load(ne(Bt,se.path),Tn,void 0,Vt)})}).then(function(Bt){st===!0&&Re.revokeObjectURL(it),Bt.flipY=!1,fe.name&&(Bt.name=fe.name),It||(Bt.format=u.RGBFormat);const Vt=(ee.samplers||{})[fe.sampler]||{};return Bt.magFilter=He[Vt.magFilter]||u.LinearFilter,Bt.minFilter=He[Vt.minFilter]||u.LinearMipmapLinearFilter,Bt.wrapS=v[Vt.wrapS]||u.RepeatWrapping,Bt.wrapT=v[Vt.wrapT]||u.RepeatWrapping,V.associations.set(Bt,{type:"textures",index:z}),Bt}).catch(function(){return console.error("THREE.GLTFLoader: Couldn't load texture",it),null});return this.textureCache[he]=Ut,Ut}assignTexture(z,B,$){const V=this;return this.getDependency("texture",$.index).then(function(ee){if($.texCoord!==void 0&&$.texCoord!=0&&!(B==="aoMap"&&$.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+$.texCoord+" for texture "+B+" not yet supported."),V.extensions[ve.KHR_TEXTURE_TRANSFORM]){const se=$.extensions!==void 0?$.extensions[ve.KHR_TEXTURE_TRANSFORM]:void 0;if(se){const fe=V.associations.get(ee);ee=V.extensions[ve.KHR_TEXTURE_TRANSFORM].extendTexture(ee,se),V.associations.set(ee,fe)}}return z[B]=ee,ee})}assignFinalMaterial(z){const B=z.geometry;let $=z.material;const V=B.attributes.tangent!==void 0,ee=B.attributes.color!==void 0,se=B.attributes.normal===void 0;if(z.isPoints){const fe="PointsMaterial:"+$.uuid;let he=this.cache.get(fe);he||(he=new u.PointsMaterial,u.Material.prototype.copy.call(he,$),he.color.copy($.color),he.map=$.map,he.sizeAttenuation=!1,this.cache.add(fe,he)),$=he}else if(z.isLine){const fe="LineBasicMaterial:"+$.uuid;let he=this.cache.get(fe);he||(he=new u.LineBasicMaterial,u.Material.prototype.copy.call(he,$),he.color.copy($.color),this.cache.add(fe,he)),$=he}if(V||ee||se){let fe="ClonedMaterial:"+$.uuid+":";$.isGLTFSpecularGlossinessMaterial&&(fe+="specular-glossiness:"),V&&(fe+="vertex-tangents:"),ee&&(fe+="vertex-colors:"),se&&(fe+="flat-shading:");let he=this.cache.get(fe);he||(he=$.clone(),ee&&(he.vertexColors=!0),se&&(he.flatShading=!0),V&&(he.normalScale&&(he.normalScale.y*=-1),he.clearcoatNormalScale&&(he.clearcoatNormalScale.y*=-1)),this.cache.add(fe,he),this.associations.set(he,this.associations.get($))),$=he}$.aoMap&&B.attributes.uv2===void 0&&B.attributes.uv!==void 0&&B.setAttribute("uv2",B.attributes.uv),z.material=$}getMaterialType(){return u.MeshStandardMaterial}loadMaterial(z){const B=this,$=this.json,V=this.extensions,ee=$.materials[z];let se;const fe={},he=ee.extensions||{},Re=[];if(he[ve.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const st=V[ve.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];se=st.getMaterialType(),Re.push(st.extendParams(fe,ee,B))}else if(he[ve.KHR_MATERIALS_UNLIT]){const st=V[ve.KHR_MATERIALS_UNLIT];se=st.getMaterialType(),Re.push(st.extendParams(fe,ee,B))}else{const st=ee.pbrMetallicRoughness||{};if(fe.color=new u.Color(1,1,1),fe.opacity=1,Array.isArray(st.baseColorFactor)){const It=st.baseColorFactor;fe.color.fromArray(It),fe.opacity=It[3]}st.baseColorTexture!==void 0&&Re.push(B.assignTexture(fe,"map",st.baseColorTexture)),fe.metalness=st.metallicFactor!==void 0?st.metallicFactor:1,fe.roughness=st.roughnessFactor!==void 0?st.roughnessFactor:1,st.metallicRoughnessTexture!==void 0&&(Re.push(B.assignTexture(fe,"metalnessMap",st.metallicRoughnessTexture)),Re.push(B.assignTexture(fe,"roughnessMap",st.metallicRoughnessTexture))),se=this._invokeOne(function(It){return It.getMaterialType&&It.getMaterialType(z)}),Re.push(Promise.all(this._invokeAll(function(It){return It.extendMaterialParams&&It.extendMaterialParams(z,fe)})))}ee.doubleSided===!0&&(fe.side=u.DoubleSide);const it=ee.alphaMode||re.OPAQUE;return it===re.BLEND?(fe.transparent=!0,fe.depthWrite=!1):(fe.format=u.RGBFormat,fe.transparent=!1,it===re.MASK&&(fe.alphaTest=ee.alphaCutoff!==void 0?ee.alphaCutoff:.5)),ee.normalTexture!==void 0&&se!==u.MeshBasicMaterial&&(Re.push(B.assignTexture(fe,"normalMap",ee.normalTexture)),fe.normalScale=new u.Vector2(1,-1),ee.normalTexture.scale!==void 0&&fe.normalScale.set(ee.normalTexture.scale,-ee.normalTexture.scale)),ee.occlusionTexture!==void 0&&se!==u.MeshBasicMaterial&&(Re.push(B.assignTexture(fe,"aoMap",ee.occlusionTexture)),ee.occlusionTexture.strength!==void 0&&(fe.aoMapIntensity=ee.occlusionTexture.strength)),ee.emissiveFactor!==void 0&&se!==u.MeshBasicMaterial&&(fe.emissive=new u.Color().fromArray(ee.emissiveFactor)),ee.emissiveTexture!==void 0&&se!==u.MeshBasicMaterial&&Re.push(B.assignTexture(fe,"emissiveMap",ee.emissiveTexture)),Promise.all(Re).then(function(){let st;return se===ge?st=V[ve.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(fe):st=new se(fe),ee.name&&(st.name=ee.name),st.map&&(st.map.encoding=u.sRGBEncoding),st.emissiveMap&&(st.emissiveMap.encoding=u.sRGBEncoding),oe(st,ee),B.associations.set(st,{type:"materials",index:z}),ee.extensions&&Me(V,st,ee),st})}createUniqueName(z){const B=u.PropertyBinding.sanitizeNodeName(z||"");let $=B;for(let V=1;this.nodeNamesUsed[$];++V)$=B+"_"+V;return this.nodeNamesUsed[$]=!0,$}loadGeometries(z){const B=this,$=this.extensions,V=this.primitiveCache;function ee(fe){return $[ve.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(fe,B).then(function(he){return cn(he,fe,B)})}const se=[];for(let fe=0,he=z.length;fe<he;fe++){const Re=z[fe],it=ct(Re),st=V[it];if(st)se.push(st.promise);else{let It;Re.extensions&&Re.extensions[ve.KHR_DRACO_MESH_COMPRESSION]?It=ee(Re):It=cn(new u.BufferGeometry,Re,B),V[it]={primitive:Re,promise:It},se.push(It)}}return Promise.all(se)}loadMesh(z){const B=this,$=this.json,V=this.extensions,ee=$.meshes[z],se=ee.primitives,fe=[];for(let he=0,Re=se.length;he<Re;he++){const it=se[he].material===void 0?ae(this.cache):this.getDependency("material",se[he].material);fe.push(it)}return fe.push(B.loadGeometries(se)),Promise.all(fe).then(function(he){const Re=he.slice(0,he.length-1),it=he[he.length-1],st=[];for(let Nt=0,Ut=it.length;Nt<Ut;Nt++){const Bt=it[Nt],At=se[Nt];let Vt;const Tn=Re[Nt];if(At.mode===Be.TRIANGLES||At.mode===Be.TRIANGLE_STRIP||At.mode===Be.TRIANGLE_FAN||At.mode===void 0)Vt=ee.isSkinnedMesh===!0?new u.SkinnedMesh(Bt,Tn):new u.Mesh(Bt,Tn),Vt.isSkinnedMesh===!0&&!Vt.geometry.attributes.skinWeight.normalized&&Vt.normalizeSkinWeights(),At.mode===Be.TRIANGLE_STRIP?Vt.geometry=gn(Vt.geometry,u.TriangleStripDrawMode):At.mode===Be.TRIANGLE_FAN&&(Vt.geometry=gn(Vt.geometry,u.TriangleFanDrawMode));else if(At.mode===Be.LINES)Vt=new u.LineSegments(Bt,Tn);else if(At.mode===Be.LINE_STRIP)Vt=new u.Line(Bt,Tn);else if(At.mode===Be.LINE_LOOP)Vt=new u.LineLoop(Bt,Tn);else if(At.mode===Be.POINTS)Vt=new u.Points(Bt,Tn);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+At.mode);Object.keys(Vt.geometry.morphAttributes).length>0&&ot(Vt,ee),Vt.name=B.createUniqueName(ee.name||"mesh_"+z),oe(Vt,ee),At.extensions&&Me(V,Vt,At),B.assignFinalMaterial(Vt),st.push(Vt)}if(st.length===1)return st[0];const It=new u.Group;for(let Nt=0,Ut=st.length;Nt<Ut;Nt++)It.add(st[Nt]);return It})}loadCamera(z){let B;const $=this.json.cameras[z],V=$[$.type];if(!V){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return $.type==="perspective"?B=new u.PerspectiveCamera(u.MathUtils.radToDeg(V.yfov),V.aspectRatio||1,V.znear||1,V.zfar||2e6):$.type==="orthographic"&&(B=new u.OrthographicCamera(-V.xmag,V.xmag,V.ymag,-V.ymag,V.znear,V.zfar)),$.name&&(B.name=this.createUniqueName($.name)),oe(B,$),Promise.resolve(B)}loadSkin(z){const B=this.json.skins[z],$={joints:B.joints};return B.inverseBindMatrices===void 0?Promise.resolve($):this.getDependency("accessor",B.inverseBindMatrices).then(function(V){return $.inverseBindMatrices=V,$})}loadAnimation(z){const $=this.json.animations[z],V=[],ee=[],se=[],fe=[],he=[];for(let Re=0,it=$.channels.length;Re<it;Re++){const st=$.channels[Re],It=$.samplers[st.sampler],Nt=st.target,Ut=Nt.node!==void 0?Nt.node:Nt.id,Bt=$.parameters!==void 0?$.parameters[It.input]:It.input,At=$.parameters!==void 0?$.parameters[It.output]:It.output;V.push(this.getDependency("node",Ut)),ee.push(this.getDependency("accessor",Bt)),se.push(this.getDependency("accessor",At)),fe.push(It),he.push(Nt)}return Promise.all([Promise.all(V),Promise.all(ee),Promise.all(se),Promise.all(fe),Promise.all(he)]).then(function(Re){const it=Re[0],st=Re[1],It=Re[2],Nt=Re[3],Ut=Re[4],Bt=[];for(let Vt=0,Tn=it.length;Vt<Tn;Vt++){const bn=it[Vt],ti=st[Vt],ni=It[Vt],at=Nt[Vt],hn=Ut[Vt];if(bn===void 0)continue;bn.updateMatrix(),bn.matrixAutoUpdate=!0;let Rn;switch(D[hn.path]){case D.weights:Rn=u.NumberKeyframeTrack;break;case D.rotation:Rn=u.QuaternionKeyframeTrack;break;case D.position:case D.scale:default:Rn=u.VectorKeyframeTrack;break}const Wn=bn.name?bn.name:bn.uuid,lr=at.interpolation!==void 0?N[at.interpolation]:u.InterpolateLinear,wn=[];D[hn.path]===D.weights?bn.traverse(function(en){en.isMesh===!0&&en.morphTargetInfluences&&wn.push(en.name?en.name:en.uuid)}):wn.push(Wn);let Ln=ni.array;if(ni.normalized){const en=Jt(Ln.constructor),Nn=new Float32Array(Ln.length);for(let Gn=0,wi=Ln.length;Gn<wi;Gn++)Nn[Gn]=Ln[Gn]*en;Ln=Nn}for(let en=0,Nn=wn.length;en<Nn;en++){const Gn=new Rn(wn[en]+"."+D[hn.path],ti.array,Ln,lr);at.interpolation==="CUBICSPLINE"&&(Gn.createInterpolant=function(In){const H=this instanceof u.QuaternionKeyframeTrack?Y:dt;return new H(this.times,this.values,this.getValueSize()/3,In)},Gn.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),Bt.push(Gn)}}const At=$.name?$.name:"animation_"+z;return new u.AnimationClip(At,void 0,Bt)})}createNodeMesh(z){const B=this.json,$=this,V=B.nodes[z];return V.mesh===void 0?null:$.getDependency("mesh",V.mesh).then(function(ee){const se=$._getNodeRef($.meshCache,V.mesh,ee);return V.weights!==void 0&&se.traverse(function(fe){if(fe.isMesh)for(let he=0,Re=V.weights.length;he<Re;he++)fe.morphTargetInfluences[he]=V.weights[he]}),se})}loadNode(z){const B=this.json,$=this.extensions,V=this,ee=B.nodes[z],se=ee.name?V.createUniqueName(ee.name):"";return function(){const fe=[],he=V._invokeOne(function(Re){return Re.createNodeMesh&&Re.createNodeMesh(z)});return he&&fe.push(he),ee.camera!==void 0&&fe.push(V.getDependency("camera",ee.camera).then(function(Re){return V._getNodeRef(V.cameraCache,ee.camera,Re)})),V._invokeAll(function(Re){return Re.createNodeAttachment&&Re.createNodeAttachment(z)}).forEach(function(Re){fe.push(Re)}),Promise.all(fe)}().then(function(fe){let he;if(ee.isBone===!0?he=new u.Bone:fe.length>1?he=new u.Group:fe.length===1?he=fe[0]:he=new u.Object3D,he!==fe[0])for(let Re=0,it=fe.length;Re<it;Re++)he.add(fe[Re]);if(ee.name&&(he.userData.name=ee.name,he.name=se),oe(he,ee),ee.extensions&&Me($,he,ee),ee.matrix!==void 0){const Re=new u.Matrix4;Re.fromArray(ee.matrix),he.applyMatrix4(Re)}else ee.translation!==void 0&&he.position.fromArray(ee.translation),ee.rotation!==void 0&&he.quaternion.fromArray(ee.rotation),ee.scale!==void 0&&he.scale.fromArray(ee.scale);return V.associations.set(he,{type:"nodes",index:z}),he})}loadScene(z){const B=this.json,$=this.extensions,V=this.json.scenes[z],ee=this,se=new u.Group;V.name&&(se.name=ee.createUniqueName(V.name)),oe(se,V),V.extensions&&Me($,se,V);const fe=V.nodes||[],he=[];for(let Re=0,it=fe.length;Re<it;Re++)he.push(on(fe[Re],se,B,ee));return Promise.all(he).then(function(){return se})}}function on(nt,z,B,$){const V=B.nodes[nt];return $.getDependency("node",nt).then(function(ee){if(V.skin===void 0)return ee;let se;return $.getDependency("skin",V.skin).then(function(fe){se=fe;const he=[];for(let Re=0,it=se.joints.length;Re<it;Re++)he.push($.getDependency("node",se.joints[Re]));return Promise.all(he)}).then(function(fe){return ee.traverse(function(he){if(!he.isMesh)return;const Re=[],it=[];for(let st=0,It=fe.length;st<It;st++){const Nt=fe[st];if(Nt){Re.push(Nt);const Ut=new u.Matrix4;se.inverseBindMatrices!==void 0&&Ut.fromArray(se.inverseBindMatrices.array,st*16),it.push(Ut)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',se.joints[st])}he.bind(new u.Skeleton(Re,it),he.matrixWorld)}),ee})}).then(function(ee){z.add(ee);const se=[];if(V.children){const fe=V.children;for(let he=0,Re=fe.length;he<Re;he++){const it=fe[he];se.push(on(it,ee,B,$))}}return Promise.all(se)})}function yn(nt,z,B){const $=z.attributes,V=new u.Box3;if($.POSITION!==void 0){const fe=B.json.accessors[$.POSITION],he=fe.min,Re=fe.max;if(he!==void 0&&Re!==void 0){if(V.set(new u.Vector3(he[0],he[1],he[2]),new u.Vector3(Re[0],Re[1],Re[2])),fe.normalized){const it=Jt(yt[fe.componentType]);V.min.multiplyScalar(it),V.max.multiplyScalar(it)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const ee=z.targets;if(ee!==void 0){const fe=new u.Vector3,he=new u.Vector3;for(let Re=0,it=ee.length;Re<it;Re++){const st=ee[Re];if(st.POSITION!==void 0){const It=B.json.accessors[st.POSITION],Nt=It.min,Ut=It.max;if(Nt!==void 0&&Ut!==void 0){if(he.setX(Math.max(Math.abs(Nt[0]),Math.abs(Ut[0]))),he.setY(Math.max(Math.abs(Nt[1]),Math.abs(Ut[1]))),he.setZ(Math.max(Math.abs(Nt[2]),Math.abs(Ut[2]))),It.normalized){const Bt=Jt(yt[It.componentType]);he.multiplyScalar(Bt)}fe.max(he)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}V.expandByVector(fe)}nt.boundingBox=V;const se=new u.Sphere;V.getCenter(se.center),se.radius=V.min.distanceTo(V.max)/2,nt.boundingSphere=se}function cn(nt,z,B){const $=z.attributes,V=[];function ee(se,fe){return B.getDependency("accessor",se).then(function(he){nt.setAttribute(fe,he)})}for(const se in $){const fe=R[se]||se.toLowerCase();fe in nt.attributes||V.push(ee($[se],fe))}if(z.indices!==void 0&&!nt.index){const se=B.getDependency("accessor",z.indices).then(function(fe){nt.setIndex(fe)});V.push(se)}return oe(nt,z),yn(nt,z,B),Promise.all(V).then(function(){return z.targets!==void 0?be(nt,z.targets,B):nt})}function gn(nt,z){let B=nt.getIndex();if(B===null){const se=[],fe=nt.getAttribute("position");if(fe!==void 0){for(let he=0;he<fe.count;he++)se.push(he);nt.setIndex(se),B=nt.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),nt}const $=B.count-2,V=[];if(z===u.TriangleFanDrawMode)for(let se=1;se<=$;se++)V.push(B.getX(0)),V.push(B.getX(se)),V.push(B.getX(se+1));else for(let se=0;se<$;se++)se%2===0?(V.push(B.getX(se)),V.push(B.getX(se+1)),V.push(B.getX(se+2))):(V.push(B.getX(se+2)),V.push(B.getX(se+1)),V.push(B.getX(se)));V.length/3!==$&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const ee=nt.clone();return ee.setIndex(V),ee}u.GLTFLoader=me})(),Yt.exports=u.GLTFLoader})(Eh);var ef=Eh.exports,Ah={exports:{}};(function(Yt,Mn){const u=si;(function(){class me extends u.Loader{constructor(ve){super(ve)}load(ve,A,g,G){const C=this,te=C.path===""?u.LoaderUtils.extractUrlBase(ve):C.path,q=new u.FileLoader(C.manager);q.setPath(C.path),q.setRequestHeader(C.requestHeader),q.setWithCredentials(C.withCredentials),q.load(ve,function(Ie){try{A(C.parse(Ie,te))}catch(De){G?G(De):console.error(De),C.manager.itemError(ve)}},g,G)}parse(ve,A){function g(w,x){const E=[],O=w.childNodes;for(let I=0,pe=O.length;I<pe;I++){const Se=O[I];Se.nodeName===x&&E.push(Se)}return E}function G(w){if(w.length===0)return[];const x=w.trim().split(/\s+/),E=new Array(x.length);for(let O=0,I=x.length;O<I;O++)E[O]=x[O];return E}function C(w){if(w.length===0)return[];const x=w.trim().split(/\s+/),E=new Array(x.length);for(let O=0,I=x.length;O<I;O++)E[O]=parseFloat(x[O]);return E}function te(w){if(w.length===0)return[];const x=w.trim().split(/\s+/),E=new Array(x.length);for(let O=0,I=x.length;O<I;O++)E[O]=parseInt(x[O]);return E}function q(w){return w.substring(1)}function Ie(){return"three_default_"+ze++}function De(w){return Object.keys(w).length===0}function et(w){return{unit:ie(g(w,"unit")[0]),upAxis:le(g(w,"up_axis")[0])}}function ie(w){return w!==void 0&&w.hasAttribute("meter")===!0?parseFloat(w.getAttribute("meter")):1}function le(w){return w!==void 0?w.textContent:"Y_UP"}function Oe(w,x,E,O){const I=g(w,x)[0];if(I!==void 0){const pe=g(I,E);for(let Se=0;Se<pe.length;Se++)O(pe[Se])}}function xe(w,x){for(const E in w){const O=w[E];O.build=x(w[E])}}function tt(w,x){return w.build!==void 0||(w.build=x(w)),w.build}function bt(w){const x={sources:{},samplers:{},channels:{}};let E=!1;for(let O=0,I=w.childNodes.length;O<I;O++){const pe=w.childNodes[O];if(pe.nodeType!==1)continue;let Se;switch(pe.nodeName){case"source":Se=pe.getAttribute("id"),x.sources[Se]=en(pe);break;case"sampler":Se=pe.getAttribute("id"),x.samplers[Se]=de(pe);break;case"channel":Se=pe.getAttribute("target"),x.channels[Se]=ge(pe);break;case"animation":bt(pe),E=!0;break;default:console.log(pe)}}E===!1&&(_e.animations[w.getAttribute("id")||u.MathUtils.generateUUID()]=x)}function de(w){const x={inputs:{}};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"input":const pe=q(I.getAttribute("source")),Se=I.getAttribute("semantic");x.inputs[Se]=pe;break}}return x}function ge(w){const x={};let O=w.getAttribute("target").split("/");const I=O.shift();let pe=O.shift();const Se=pe.indexOf("(")!==-1,Ve=pe.indexOf(".")!==-1;if(Ve)O=pe.split("."),pe=O.shift(),x.member=O.shift();else if(Se){const lt=pe.split("(");pe=lt.shift();for(let xt=0;xt<lt.length;xt++)lt[xt]=parseInt(lt[xt].replace(/\)/,""));x.indices=lt}return x.id=I,x.sid=pe,x.arraySyntax=Se,x.memberSyntax=Ve,x.sampler=q(w.getAttribute("source")),x}function Ge(w){const x=[],E=w.channels,O=w.samplers,I=w.sources;for(const pe in E)if(E.hasOwnProperty(pe)){const Se=E[pe],Ve=O[Se.sampler],lt=Ve.inputs.INPUT,xt=Ve.inputs.OUTPUT,Ye=I[lt],ke=I[xt],Et=dt(Se,Ye,ke);He(Et,x)}return x}function gt(w){return tt(_e.animations[w],Ge)}function dt(w,x,E){const O=_e.nodes[w.id],I=vi(O.id),pe=O.transforms[w.sid],Se=O.matrix.clone().transpose();let Ve,lt,xt,Ye,ke,Et;const Ke={};switch(pe){case"matrix":for(xt=0,Ye=x.array.length;xt<Ye;xt++)if(Ve=x.array[xt],lt=xt*E.stride,Ke[Ve]===void 0&&(Ke[Ve]={}),w.arraySyntax===!0){const Rt=E.array[lt],zt=w.indices[0]+4*w.indices[1];Ke[Ve][zt]=Rt}else for(ke=0,Et=E.stride;ke<Et;ke++)Ke[Ve][ke]=E.array[lt+ke];break;case"translate":console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',pe);break;case"rotate":console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',pe);break;case"scale":console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',pe);break}const Tt=Q(Ke,Se);return{name:I.uuid,keyframes:Tt}}function Q(w,x){const E=[];for(const I in w)E.push({time:parseFloat(I),value:w[I]});E.sort(O);for(let I=0;I<16;I++)v(E,I,x.elements[I]);return E;function O(I,pe){return I.time-pe.time}}const Y=new u.Vector3,Be=new u.Vector3,yt=new u.Quaternion;function He(w,x){const E=w.keyframes,O=w.name,I=[],pe=[],Se=[],Ve=[];for(let lt=0,xt=E.length;lt<xt;lt++){const Ye=E[lt],ke=Ye.time,Et=Ye.value;Cn.fromArray(Et).transpose(),Cn.decompose(Y,yt,Be),I.push(ke),pe.push(Y.x,Y.y,Y.z),Se.push(yt.x,yt.y,yt.z,yt.w),Ve.push(Be.x,Be.y,Be.z)}return pe.length>0&&x.push(new u.VectorKeyframeTrack(O+".position",I,pe)),Se.length>0&&x.push(new u.QuaternionKeyframeTrack(O+".quaternion",I,Se)),Ve.length>0&&x.push(new u.VectorKeyframeTrack(O+".scale",I,Ve)),x}function v(w,x,E){let O,I=!0,pe,Se;for(pe=0,Se=w.length;pe<Se;pe++)O=w[pe],O.value[x]===void 0?O.value[x]=null:I=!1;if(I===!0)for(pe=0,Se=w.length;pe<Se;pe++)O=w[pe],O.value[x]=E;else L(w,x)}function L(w,x){let E,O;for(let I=0,pe=w.length;I<pe;I++){const Se=w[I];if(Se.value[x]===null){if(E=R(w,I,x),O=D(w,I,x),E===null){Se.value[x]=O.value[x];continue}if(O===null){Se.value[x]=E.value[x];continue}N(Se,E,O,x)}}}function R(w,x,E){for(;x>=0;){const O=w[x];if(O.value[E]!==null)return O;x--}return null}function D(w,x,E){for(;x<w.length;){const O=w[x];if(O.value[E]!==null)return O;x++}return null}function N(w,x,E,O){if(E.time-x.time===0){w.value[O]=x.value[O];return}w.value[O]=(w.time-x.time)*(E.value[O]-x.value[O])/(E.time-x.time)+x.value[O]}function re(w){const x={name:w.getAttribute("id")||"default",start:parseFloat(w.getAttribute("start")||0),end:parseFloat(w.getAttribute("end")||0),animations:[]};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"instance_animation":x.animations.push(q(I.getAttribute("url")));break}}_e.clips[w.getAttribute("id")]=x}function ne(w){const x=[],E=w.name,O=w.end-w.start||-1,I=w.animations;for(let pe=0,Se=I.length;pe<Se;pe++){const Ve=gt(I[pe]);for(let lt=0,xt=Ve.length;lt<xt;lt++)x.push(Ve[lt])}return new u.AnimationClip(E,O,x)}function ae(w){return tt(_e.clips[w],ne)}function Me(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"skin":x.id=q(I.getAttribute("source")),x.skin=oe(I);break;case"morph":x.id=q(I.getAttribute("source")),console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");break}}_e.controllers[w.getAttribute("id")]=x}function oe(w){const x={sources:{}};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"bind_shape_matrix":x.bindShapeMatrix=C(I.textContent);break;case"source":const pe=I.getAttribute("id");x.sources[pe]=en(I);break;case"joints":x.joints=be(I);break;case"vertex_weights":x.vertexWeights=ot(I);break}}return x}function be(w){const x={inputs:{}};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"input":const pe=I.getAttribute("semantic"),Se=q(I.getAttribute("source"));x.inputs[pe]=Se;break}}return x}function ot(w){const x={inputs:{}};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"input":const pe=I.getAttribute("semantic"),Se=q(I.getAttribute("source")),Ve=parseInt(I.getAttribute("offset"));x.inputs[pe]={id:Se,offset:Ve};break;case"vcount":x.vcount=te(I.textContent);break;case"v":x.v=te(I.textContent);break}}return x}function ct(w){const x={id:w.id},E=_e.geometries[x.id];return w.skin!==void 0&&(x.skin=wt(w.skin),E.sources.skinIndices=x.skin.indices,E.sources.skinWeights=x.skin.weights),x}function wt(w){const E={joints:[],indices:{array:[],stride:4},weights:{array:[],stride:4}},O=w.sources,I=w.vertexWeights,pe=I.vcount,Se=I.v,Ve=I.inputs.JOINT.offset,lt=I.inputs.WEIGHT.offset,xt=w.sources[w.joints.inputs.JOINT],Ye=w.sources[w.joints.inputs.INV_BIND_MATRIX],ke=O[I.inputs.WEIGHT.id].array;let Et=0,Ke,Tt,We;for(Ke=0,We=pe.length;Ke<We;Ke++){const zt=pe[Ke],jt=[];for(Tt=0;Tt<zt;Tt++){const qt=Se[Et+Ve],un=Se[Et+lt],rn=ke[un];jt.push({index:qt,weight:rn}),Et+=2}for(jt.sort(Rt),Tt=0;Tt<4;Tt++){const qt=jt[Tt];qt!==void 0?(E.indices.array.push(qt.index),E.weights.array.push(qt.weight)):(E.indices.array.push(0),E.weights.array.push(0))}}for(w.bindShapeMatrix?E.bindMatrix=new u.Matrix4().fromArray(w.bindShapeMatrix).transpose():E.bindMatrix=new u.Matrix4().identity(),Ke=0,We=xt.array.length;Ke<We;Ke++){const zt=xt.array[Ke],jt=new u.Matrix4().fromArray(Ye.array,Ke*Ye.stride).transpose();E.joints.push({name:zt,boneInverse:jt})}return E;function Rt(zt,jt){return jt.weight-zt.weight}}function Jt(w){return tt(_e.controllers[w],ct)}function mn(w){const x={init_from:g(w,"init_from")[0].textContent};_e.images[w.getAttribute("id")]=x}function on(w){return w.build!==void 0?w.build:w.init_from}function yn(w){const x=_e.images[w];return x!==void 0?tt(x,on):(console.warn("THREE.ColladaLoader: Couldn't find image with ID:",w),null)}function cn(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"profile_COMMON":x.profile=gn(I);break}}_e.effects[w.getAttribute("id")]=x}function gn(w){const x={surfaces:{},samplers:{}};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"newparam":nt(I,x);break;case"technique":x.technique=$(I);break;case"extra":x.extra=Re(I);break}}return x}function nt(w,x){const E=w.getAttribute("sid");for(let O=0,I=w.childNodes.length;O<I;O++){const pe=w.childNodes[O];if(pe.nodeType===1)switch(pe.nodeName){case"surface":x.surfaces[E]=z(pe);break;case"sampler2D":x.samplers[E]=B(pe);break}}}function z(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"init_from":x.init_from=I.textContent;break}}return x}function B(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"source":x.source=I.textContent;break}}return x}function $(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"constant":case"lambert":case"blinn":case"phong":x.type=I.nodeName,x.parameters=V(I);break}}return x}function V(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"emission":case"diffuse":case"specular":case"bump":case"ambient":case"shininess":case"transparency":x[I.nodeName]=ee(I);break;case"transparent":x[I.nodeName]={opaque:I.getAttribute("opaque"),data:ee(I)};break}}return x}function ee(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"color":x[I.nodeName]=C(I.textContent);break;case"float":x[I.nodeName]=parseFloat(I.textContent);break;case"texture":x[I.nodeName]={id:I.getAttribute("texture"),extra:se(I)};break}}return x}function se(w){const x={technique:{}};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"extra":fe(I,x);break}}return x}function fe(w,x){for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"technique":he(I,x);break}}}function he(w,x){for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"repeatU":case"repeatV":case"offsetU":case"offsetV":x.technique[I.nodeName]=parseFloat(I.textContent);break;case"wrapU":case"wrapV":I.textContent.toUpperCase()==="TRUE"?x.technique[I.nodeName]=1:I.textContent.toUpperCase()==="FALSE"?x.technique[I.nodeName]=0:x.technique[I.nodeName]=parseInt(I.textContent);break}}}function Re(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"technique":x.technique=it(I);break}}return x}function it(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"double_sided":x[I.nodeName]=parseInt(I.textContent);break}}return x}function st(w){return w}function It(w){return tt(_e.effects[w],st)}function Nt(w){const x={name:w.getAttribute("name")};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"instance_effect":x.url=q(I.getAttribute("url"));break}}_e.materials[w.getAttribute("id")]=x}function Ut(w){let x,E=w.slice((w.lastIndexOf(".")-1>>>0)+2);switch(E=E.toLowerCase(),E){case"tga":x=P;break;default:x=M}return x}function Bt(w){const x=It(w.url),E=x.profile.technique,O=x.profile.extra;let I;switch(E.type){case"phong":case"blinn":I=new u.MeshPhongMaterial;break;case"lambert":I=new u.MeshLambertMaterial;break;default:I=new u.MeshBasicMaterial;break}I.name=w.name||"";function pe(xt){const Ye=x.profile.samplers[xt.id];let ke=null;if(Ye!==void 0){const Et=x.profile.surfaces[Ye.source];ke=yn(Et.init_from)}else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."),ke=yn(xt.id);if(ke!==null){const Et=Ut(ke);if(Et!==void 0){const Ke=Et.load(ke),Tt=xt.extra;if(Tt!==void 0&&Tt.technique!==void 0&&De(Tt.technique)===!1){const We=Tt.technique;Ke.wrapS=We.wrapU?u.RepeatWrapping:u.ClampToEdgeWrapping,Ke.wrapT=We.wrapV?u.RepeatWrapping:u.ClampToEdgeWrapping,Ke.offset.set(We.offsetU||0,We.offsetV||0),Ke.repeat.set(We.repeatU||1,We.repeatV||1)}else Ke.wrapS=u.RepeatWrapping,Ke.wrapT=u.RepeatWrapping;return Ke}else return console.warn("THREE.ColladaLoader: THREE.Loader for texture %s not found.",ke),null}else return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:",xt.id),null}const Se=E.parameters;for(const xt in Se){const Ye=Se[xt];switch(xt){case"diffuse":Ye.color&&I.color.fromArray(Ye.color),Ye.texture&&(I.map=pe(Ye.texture));break;case"specular":Ye.color&&I.specular&&I.specular.fromArray(Ye.color),Ye.texture&&(I.specularMap=pe(Ye.texture));break;case"bump":Ye.texture&&(I.normalMap=pe(Ye.texture));break;case"ambient":Ye.texture&&(I.lightMap=pe(Ye.texture));break;case"shininess":Ye.float&&I.shininess&&(I.shininess=Ye.float);break;case"emission":Ye.color&&I.emissive&&I.emissive.fromArray(Ye.color),Ye.texture&&(I.emissiveMap=pe(Ye.texture));break}}let Ve=Se.transparent,lt=Se.transparency;if(lt===void 0&&Ve&&(lt={float:1}),Ve===void 0&&lt&&(Ve={opaque:"A_ONE",data:{color:[1,1,1,1]}}),Ve&&lt)if(Ve.data.texture)I.transparent=!0;else{const xt=Ve.data.color;switch(Ve.opaque){case"A_ONE":I.opacity=xt[3]*lt.float;break;case"RGB_ZERO":I.opacity=1-xt[0]*lt.float;break;case"A_ZERO":I.opacity=1-xt[3]*lt.float;break;case"RGB_ONE":I.opacity=xt[0]*lt.float;break;default:console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.',Ve.opaque)}I.opacity<1&&(I.transparent=!0)}return O!==void 0&&O.technique!==void 0&&O.technique.double_sided===1&&(I.side=u.DoubleSide),I}function At(w){return tt(_e.materials[w],Bt)}function Vt(w){const x={name:w.getAttribute("name")};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"optics":x.optics=Tn(I);break}}_e.cameras[w.getAttribute("id")]=x}function Tn(w){for(let x=0;x<w.childNodes.length;x++){const E=w.childNodes[x];switch(E.nodeName){case"technique_common":return bn(E)}}return{}}function bn(w){const x={};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];switch(O.nodeName){case"perspective":case"orthographic":x.technique=O.nodeName,x.parameters=ti(O);break}}return x}function ti(w){const x={};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];switch(O.nodeName){case"xfov":case"yfov":case"xmag":case"ymag":case"znear":case"zfar":case"aspect_ratio":x[O.nodeName]=parseFloat(O.textContent);break}}return x}function ni(w){let x;switch(w.optics.technique){case"perspective":x=new u.PerspectiveCamera(w.optics.parameters.yfov,w.optics.parameters.aspect_ratio,w.optics.parameters.znear,w.optics.parameters.zfar);break;case"orthographic":let E=w.optics.parameters.ymag,O=w.optics.parameters.xmag;const I=w.optics.parameters.aspect_ratio;O=O===void 0?E*I:O,E=E===void 0?O/I:E,O*=.5,E*=.5,x=new u.OrthographicCamera(-O,O,E,-E,w.optics.parameters.znear,w.optics.parameters.zfar);break;default:x=new u.PerspectiveCamera;break}return x.name=w.name||"",x}function at(w){const x=_e.cameras[w];return x!==void 0?tt(x,ni):(console.warn("THREE.ColladaLoader: Couldn't find camera with ID:",w),null)}function hn(w){let x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"technique_common":x=Rn(I);break}}_e.lights[w.getAttribute("id")]=x}function Rn(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"directional":case"point":case"spot":case"ambient":x.technique=I.nodeName,x.parameters=Wn(I)}}return x}function Wn(w){const x={};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"color":const pe=C(I.textContent);x.color=new u.Color().fromArray(pe);break;case"falloff_angle":x.falloffAngle=parseFloat(I.textContent);break;case"quadratic_attenuation":const Se=parseFloat(I.textContent);x.distance=Se?Math.sqrt(1/Se):0;break}}return x}function lr(w){let x;switch(w.technique){case"directional":x=new u.DirectionalLight;break;case"point":x=new u.PointLight;break;case"spot":x=new u.SpotLight;break;case"ambient":x=new u.AmbientLight;break}return w.parameters.color&&x.color.copy(w.parameters.color),w.parameters.distance&&(x.distance=w.parameters.distance),x}function wn(w){const x=_e.lights[w];return x!==void 0?tt(x,lr):(console.warn("THREE.ColladaLoader: Couldn't find light with ID:",w),null)}function Ln(w){const x={name:w.getAttribute("name"),sources:{},vertices:{},primitives:[]},E=g(w,"mesh")[0];if(E!==void 0){for(let O=0;O<E.childNodes.length;O++){const I=E.childNodes[O];if(I.nodeType!==1)continue;const pe=I.getAttribute("id");switch(I.nodeName){case"source":x.sources[pe]=en(I);break;case"vertices":x.vertices=Nn(I);break;case"polygons":console.warn("THREE.ColladaLoader: Unsupported primitive type: ",I.nodeName);break;case"lines":case"linestrips":case"polylist":case"triangles":x.primitives.push(Gn(I));break;default:console.log(I)}}_e.geometries[w.getAttribute("id")]=x}}function en(w){const x={array:[],stride:3};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"float_array":x.array=C(O.textContent);break;case"Name_array":x.array=G(O.textContent);break;case"technique_common":const I=g(O,"accessor")[0];I!==void 0&&(x.stride=parseInt(I.getAttribute("stride")));break}}return x}function Nn(w){const x={};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];O.nodeType===1&&(x[O.getAttribute("semantic")]=q(O.getAttribute("source")))}return x}function Gn(w){const x={type:w.nodeName,material:w.getAttribute("material"),count:parseInt(w.getAttribute("count")),inputs:{},stride:0,hasUV:!1};for(let E=0,O=w.childNodes.length;E<O;E++){const I=w.childNodes[E];if(I.nodeType===1)switch(I.nodeName){case"input":const pe=q(I.getAttribute("source")),Se=I.getAttribute("semantic"),Ve=parseInt(I.getAttribute("offset")),lt=parseInt(I.getAttribute("set")),xt=lt>0?Se+lt:Se;x.inputs[xt]={id:pe,offset:Ve},x.stride=Math.max(x.stride,Ve+1),Se==="TEXCOORD"&&(x.hasUV=!0);break;case"vcount":x.vcount=te(I.textContent);break;case"p":x.p=te(I.textContent);break}}return x}function wi(w){const x={};for(let E=0;E<w.length;E++){const O=w[E];x[O.type]===void 0&&(x[O.type]=[]),x[O.type].push(O)}return x}function In(w){let x=0;for(let E=0,O=w.length;E<O;E++)w[E].hasUV===!0&&x++;x>0&&x<w.length&&(w.uvsNeedsFix=!0)}function H(w){const x={},E=w.sources,O=w.vertices,I=w.primitives;if(I.length===0)return{};const pe=wi(I);for(const Se in pe){const Ve=pe[Se];In(Ve),x[Se]=Ki(Ve,E,O)}return x}function Ki(w,x,E){const O={},I={array:[],stride:0},pe={array:[],stride:0},Se={array:[],stride:0},Ve={array:[],stride:0},lt={array:[],stride:0},xt={array:[],stride:4},Ye={array:[],stride:4},ke=new u.BufferGeometry,Et=[];let Ke=0;for(let Tt=0;Tt<w.length;Tt++){const We=w[Tt],Rt=We.inputs;let zt=0;switch(We.type){case"lines":case"linestrips":zt=We.count*2;break;case"triangles":zt=We.count*3;break;case"polylist":for(let jt=0;jt<We.count;jt++){const qt=We.vcount[jt];switch(qt){case 3:zt+=3;break;case 4:zt+=6;break;default:zt+=(qt-2)*3;break}}break;default:console.warn("THREE.ColladaLoader: Unknow primitive type:",We.type)}ke.addGroup(Ke,zt,Tt),Ke+=zt,We.material&&Et.push(We.material);for(const jt in Rt){const qt=Rt[jt];switch(jt){case"VERTEX":for(const un in E){const rn=E[un];switch(un){case"POSITION":const ut=I.array.length;if(jn(We,x[rn],qt.offset,I.array),I.stride=x[rn].stride,x.skinWeights&&x.skinIndices&&(jn(We,x.skinIndices,qt.offset,xt.array),jn(We,x.skinWeights,qt.offset,Ye.array)),We.hasUV===!1&&w.uvsNeedsFix===!0){const _n=(I.array.length-ut)/I.stride;for(let Kt=0;Kt<_n;Kt++)Se.array.push(0,0)}break;case"NORMAL":jn(We,x[rn],qt.offset,pe.array),pe.stride=x[rn].stride;break;case"COLOR":jn(We,x[rn],qt.offset,lt.array),lt.stride=x[rn].stride;break;case"TEXCOORD":jn(We,x[rn],qt.offset,Se.array),Se.stride=x[rn].stride;break;case"TEXCOORD1":jn(We,x[rn],qt.offset,Ve.array),Se.stride=x[rn].stride;break;default:console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',un)}}break;case"NORMAL":jn(We,x[qt.id],qt.offset,pe.array),pe.stride=x[qt.id].stride;break;case"COLOR":jn(We,x[qt.id],qt.offset,lt.array),lt.stride=x[qt.id].stride;break;case"TEXCOORD":jn(We,x[qt.id],qt.offset,Se.array),Se.stride=x[qt.id].stride;break;case"TEXCOORD1":jn(We,x[qt.id],qt.offset,Ve.array),Ve.stride=x[qt.id].stride;break}}}return I.array.length>0&&ke.setAttribute("position",new u.Float32BufferAttribute(I.array,I.stride)),pe.array.length>0&&ke.setAttribute("normal",new u.Float32BufferAttribute(pe.array,pe.stride)),lt.array.length>0&&ke.setAttribute("color",new u.Float32BufferAttribute(lt.array,lt.stride)),Se.array.length>0&&ke.setAttribute("uv",new u.Float32BufferAttribute(Se.array,Se.stride)),Ve.array.length>0&&ke.setAttribute("uv2",new u.Float32BufferAttribute(Ve.array,Ve.stride)),xt.array.length>0&&ke.setAttribute("skinIndex",new u.Float32BufferAttribute(xt.array,xt.stride)),Ye.array.length>0&&ke.setAttribute("skinWeight",new u.Float32BufferAttribute(Ye.array,Ye.stride)),O.data=ke,O.type=w[0].type,O.materialKeys=Et,O}function jn(w,x,E,O){const I=w.p,pe=w.stride,Se=w.vcount;function Ve(Ye){let ke=I[Ye+E]*xt;const Et=ke+xt;for(;ke<Et;ke++)O.push(lt[ke])}const lt=x.array,xt=x.stride;if(w.vcount!==void 0){let Ye=0;for(let ke=0,Et=Se.length;ke<Et;ke++){const Ke=Se[ke];if(Ke===4){const Tt=Ye+pe*0,We=Ye+pe*1,Rt=Ye+pe*2,zt=Ye+pe*3;Ve(Tt),Ve(We),Ve(zt),Ve(We),Ve(Rt),Ve(zt)}else if(Ke===3){const Tt=Ye+pe*0,We=Ye+pe*1,Rt=Ye+pe*2;Ve(Tt),Ve(We),Ve(Rt)}else if(Ke>4)for(let Tt=1,We=Ke-2;Tt<=We;Tt++){const Rt=Ye+pe*0,zt=Ye+pe*Tt,jt=Ye+pe*(Tt+1);Ve(Rt),Ve(zt),Ve(jt)}Ye+=pe*Ke}}else for(let Ye=0,ke=I.length;Ye<ke;Ye+=pe)Ve(Ye)}function qn(w){return tt(_e.geometries[w],H)}function yi(w){const x={name:w.getAttribute("name")||"",joints:{},links:[]};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"technique_common":Qi(O,x);break}}_e.kinematicsModels[w.getAttribute("id")]=x}function Di(w){return w.build!==void 0?w.build:w}function cr(w){return tt(_e.kinematicsModels[w],Di)}function Qi(w,x){for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"joint":x.joints[O.getAttribute("sid")]=$i(O);break;case"link":x.links.push(ai(O));break}}}function $i(w){let x;for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"prismatic":case"revolute":x=Oi(O);break}}return x}function Oi(w){const x={sid:w.getAttribute("sid"),name:w.getAttribute("name")||"",axis:new u.Vector3,limits:{min:0,max:0},type:w.nodeName,static:!1,zeroPosition:0,middlePosition:0};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"axis":const I=C(O.textContent);x.axis.fromArray(I);break;case"limits":const pe=O.getElementsByTagName("max")[0],Se=O.getElementsByTagName("min")[0];x.limits.max=parseFloat(pe.textContent),x.limits.min=parseFloat(Se.textContent);break}}return x.limits.min>=x.limits.max&&(x.static=!0),x.middlePosition=(x.limits.min+x.limits.max)/2,x}function ai(w){const x={sid:w.getAttribute("sid"),name:w.getAttribute("name")||"",attachments:[],transforms:[]};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"attachment_full":x.attachments.push(_i(O));break;case"matrix":case"translate":case"rotate":x.transforms.push(Mi(O));break}}return x}function _i(w){const x={joint:w.getAttribute("joint").split("/").pop(),transforms:[],links:[]};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"link":x.links.push(ai(O));break;case"matrix":case"translate":case"rotate":x.transforms.push(Mi(O));break}}return x}function Mi(w){const x={type:w.nodeName},E=C(w.textContent);switch(x.type){case"matrix":x.obj=new u.Matrix4,x.obj.fromArray(E).transpose();break;case"translate":x.obj=new u.Vector3,x.obj.fromArray(E);break;case"rotate":x.obj=new u.Vector3,x.obj.fromArray(E),x.angle=u.MathUtils.degToRad(E[3]);break}return x}function Fi(w){const x={name:w.getAttribute("name")||"",rigidBodies:{}};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"rigid_body":x.rigidBodies[O.getAttribute("name")]={},ur(O,x.rigidBodies[O.getAttribute("name")]);break}}_e.physicsModels[w.getAttribute("id")]=x}function ur(w,x){for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"technique_common":xr(O,x);break}}}function xr(w,x){for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"inertia":x.inertia=C(O.textContent);break;case"mass":x.mass=C(O.textContent)[0];break}}}function Ui(w){const x={bindJointAxis:[]};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"bind_joint_axis":x.bindJointAxis.push(Br(O));break}}_e.kinematicsScenes[q(w.getAttribute("url"))]=x}function Br(w){const x={target:w.getAttribute("target").split("/").pop()};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType===1)switch(O.nodeName){case"axis":const I=O.getElementsByTagName("param")[0];x.axis=I.textContent;const pe=x.axis.split("inst_").pop().split("axis")[0];x.jointIndex=pe.substr(0,pe.length-1);break}}return x}function zr(w){return w.build!==void 0?w.build:w}function kr(w){return tt(_e.kinematicsScenes[w],zr)}function hr(){const w=Object.keys(_e.kinematicsModels)[0],x=Object.keys(_e.kinematicsScenes)[0],E=Object.keys(_e.visualScenes)[0];if(w===void 0||x===void 0)return;const O=cr(w),I=kr(x),pe=Zn(E),Se=I.bindJointAxis,Ve={};for(let Ye=0,ke=Se.length;Ye<ke;Ye++){const Et=Se[Ye],Ke=Dn.querySelector('[sid="'+Et.target+'"]');if(Ke){const Tt=Ke.parentElement;lt(Et.jointIndex,Tt)}}function lt(Ye,ke){const Et=ke.getAttribute("name"),Ke=O.joints[Ye];pe.traverse(function(Tt){Tt.name===Et&&(Ve[Ye]={object:Tt,transforms:br(ke),joint:Ke,position:Ke.zeroPosition})})}const xt=new u.Matrix4;Le={joints:O&&O.joints,getJointValue:function(Ye){const ke=Ve[Ye];if(ke)return ke.position;console.warn("THREE.ColladaLoader: Joint "+Ye+" doesn't exist.")},setJointValue:function(Ye,ke){const Et=Ve[Ye];if(Et){const Ke=Et.joint;if(ke>Ke.limits.max||ke<Ke.limits.min)console.warn("THREE.ColladaLoader: Joint "+Ye+" value "+ke+" outside of limits (min: "+Ke.limits.min+", max: "+Ke.limits.max+").");else if(Ke.static)console.warn("THREE.ColladaLoader: Joint "+Ye+" is static.");else{const Tt=Et.object,We=Ke.axis,Rt=Et.transforms;Cn.identity();for(let zt=0;zt<Rt.length;zt++){const jt=Rt[zt];if(jt.sid&&jt.sid.indexOf(Ye)!==-1)switch(Ke.type){case"revolute":Cn.multiply(xt.makeRotationAxis(We,u.MathUtils.degToRad(ke)));break;case"prismatic":Cn.multiply(xt.makeTranslation(We.x*ke,We.y*ke,We.z*ke));break;default:console.warn("THREE.ColladaLoader: Unknown joint type: "+Ke.type);break}else switch(jt.type){case"matrix":Cn.multiply(jt.obj);break;case"translate":Cn.multiply(xt.makeTranslation(jt.obj.x,jt.obj.y,jt.obj.z));break;case"scale":Cn.scale(jt.obj);break;case"rotate":Cn.multiply(xt.makeRotationAxis(jt.obj,jt.angle));break}}Tt.matrix.copy(Cn),Tt.matrix.decompose(Tt.position,Tt.quaternion,Tt.scale),Ve[Ye].position=ke}}else console.log("THREE.ColladaLoader: "+Ye+" does not exist.")}}}function br(w){const x=[],E=Dn.querySelector('[id="'+w.id+'"]');for(let O=0;O<E.childNodes.length;O++){const I=E.childNodes[O];if(I.nodeType!==1)continue;let pe,Se;switch(I.nodeName){case"matrix":pe=C(I.textContent);const Ve=new u.Matrix4().fromArray(pe).transpose();x.push({sid:I.getAttribute("sid"),type:I.nodeName,obj:Ve});break;case"translate":case"scale":pe=C(I.textContent),Se=new u.Vector3().fromArray(pe),x.push({sid:I.getAttribute("sid"),type:I.nodeName,obj:Se});break;case"rotate":pe=C(I.textContent),Se=new u.Vector3().fromArray(pe);const lt=u.MathUtils.degToRad(pe[3]);x.push({sid:I.getAttribute("sid"),type:I.nodeName,obj:Se,angle:lt});break}}return x}function Si(w){const x=w.getElementsByTagName("node");for(let E=0;E<x.length;E++){const O=x[E];O.hasAttribute("id")===!1&&O.setAttribute("id",Ie())}}const Cn=new u.Matrix4,Ni=new u.Vector3;function ii(w){const x={name:w.getAttribute("name")||"",type:w.getAttribute("type"),id:w.getAttribute("id"),sid:w.getAttribute("sid"),matrix:new u.Matrix4,nodes:[],instanceCameras:[],instanceControllers:[],instanceLights:[],instanceGeometries:[],instanceNodes:[],transforms:{}};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];if(O.nodeType!==1)continue;let I;switch(O.nodeName){case"node":x.nodes.push(O.getAttribute("id")),ii(O);break;case"instance_camera":x.instanceCameras.push(q(O.getAttribute("url")));break;case"instance_controller":x.instanceControllers.push(pi(O));break;case"instance_light":x.instanceLights.push(q(O.getAttribute("url")));break;case"instance_geometry":x.instanceGeometries.push(pi(O));break;case"instance_node":x.instanceNodes.push(q(O.getAttribute("url")));break;case"matrix":I=C(O.textContent),x.matrix.multiply(Cn.fromArray(I).transpose()),x.transforms[O.getAttribute("sid")]=O.nodeName;break;case"translate":I=C(O.textContent),Ni.fromArray(I),x.matrix.multiply(Cn.makeTranslation(Ni.x,Ni.y,Ni.z)),x.transforms[O.getAttribute("sid")]=O.nodeName;break;case"rotate":I=C(O.textContent);const pe=u.MathUtils.degToRad(I[3]);x.matrix.multiply(Cn.makeRotationAxis(Ni.fromArray(I),pe)),x.transforms[O.getAttribute("sid")]=O.nodeName;break;case"scale":I=C(O.textContent),x.matrix.scale(Ni.fromArray(I)),x.transforms[O.getAttribute("sid")]=O.nodeName;break;case"extra":break;default:console.log(O)}}return Xn(x.id)?console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.",x.id):_e.nodes[x.id]=x,x}function pi(w){const x={id:q(w.getAttribute("url")),materials:{},skeletons:[]};for(let E=0;E<w.childNodes.length;E++){const O=w.childNodes[E];switch(O.nodeName){case"bind_material":const I=O.getElementsByTagName("instance_material");for(let pe=0;pe<I.length;pe++){const Se=I[pe],Ve=Se.getAttribute("symbol"),lt=Se.getAttribute("target");x.materials[Ve]=q(lt)}break;case"skeleton":x.skeletons.push(q(O.textContent));break}}return x}function wr(w,x){const E=[],O=[];let I,pe,Se;for(I=0;I<w.length;I++){const xt=w[I];let Ye;if(Xn(xt))Ye=vi(xt),er(Ye,x,E);else if(Mr(xt)){const Et=_e.visualScenes[xt].children;for(let Ke=0;Ke<Et.length;Ke++){const Tt=Et[Ke];if(Tt.type==="JOINT"){const We=vi(Tt.id);er(We,x,E)}}}else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:",xt)}for(I=0;I<x.length;I++)for(pe=0;pe<E.length;pe++)if(Se=E[pe],Se.bone.name===x[I].name){O[I]=Se,Se.processed=!0;break}for(I=0;I<E.length;I++)Se=E[I],Se.processed===!1&&(O.push(Se),Se.processed=!0);const Ve=[],lt=[];for(I=0;I<O.length;I++)Se=O[I],Ve.push(Se.bone),lt.push(Se.boneInverse);return new u.Skeleton(Ve,lt)}function er(w,x,E){w.traverse(function(O){if(O.isBone===!0){let I;for(let pe=0;pe<x.length;pe++){const Se=x[pe];if(Se.name===O.name){I=Se.boneInverse;break}}I===void 0&&(I=new u.Matrix4),E.push({bone:O,boneInverse:I,processed:!1})}})}function _r(w){const x=[],E=w.matrix,O=w.nodes,I=w.type,pe=w.instanceCameras,Se=w.instanceControllers,Ve=w.instanceLights,lt=w.instanceGeometries,xt=w.instanceNodes;for(let ke=0,Et=O.length;ke<Et;ke++)x.push(vi(O[ke]));for(let ke=0,Et=pe.length;ke<Et;ke++){const Ke=at(pe[ke]);Ke!==null&&x.push(Ke.clone())}for(let ke=0,Et=Se.length;ke<Et;ke++){const Ke=Se[ke],Tt=Jt(Ke.id),We=qn(Tt.id),Rt=oi(We,Ke.materials),zt=Ke.skeletons,jt=Tt.skin.joints,qt=wr(zt,jt);for(let un=0,rn=Rt.length;un<rn;un++){const ut=Rt[un];ut.isSkinnedMesh&&(ut.bind(qt,Tt.skin.bindMatrix),ut.normalizeSkinWeights()),x.push(ut)}}for(let ke=0,Et=Ve.length;ke<Et;ke++){const Ke=wn(Ve[ke]);Ke!==null&&x.push(Ke.clone())}for(let ke=0,Et=lt.length;ke<Et;ke++){const Ke=lt[ke],Tt=qn(Ke.id),We=oi(Tt,Ke.materials);for(let Rt=0,zt=We.length;Rt<zt;Rt++)x.push(We[Rt])}for(let ke=0,Et=xt.length;ke<Et;ke++)x.push(vi(xt[ke]).clone());let Ye;if(O.length===0&&x.length===1)Ye=x[0];else{Ye=I==="JOINT"?new u.Bone:new u.Group;for(let ke=0;ke<x.length;ke++)Ye.add(x[ke])}return Ye.name=I==="JOINT"?w.sid:w.name,Ye.matrix.copy(E),Ye.matrix.decompose(Ye.position,Ye.quaternion,Ye.scale),Ye}const Ti=new u.MeshBasicMaterial({color:16711935});function Dt(w,x){const E=[];for(let O=0,I=w.length;O<I;O++){const pe=x[w[O]];pe===void 0?(console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.",w[O]),E.push(Ti)):E.push(At(pe))}return E}function oi(w,x){const E=[];for(const O in w){const I=w[O],pe=Dt(I.materialKeys,x);pe.length===0&&(O==="lines"||O==="linestrips"?pe.push(new u.LineBasicMaterial):pe.push(new u.MeshPhongMaterial));const Se=I.data.attributes.skinIndex!==void 0,Ve=pe.length===1?pe[0]:pe;let lt;switch(O){case"lines":lt=new u.LineSegments(I.data,Ve);break;case"linestrips":lt=new u.Line(I.data,Ve);break;case"triangles":case"polylist":Se?lt=new u.SkinnedMesh(I.data,Ve):lt=new u.Mesh(I.data,Ve);break}E.push(lt)}return E}function Xn(w){return _e.nodes[w]!==void 0}function vi(w){return tt(_e.nodes[w],_r)}function ks(w){const x={name:w.getAttribute("name"),children:[]};Si(w);const E=g(w,"node");for(let O=0;O<E.length;O++)x.children.push(ii(E[O]));_e.visualScenes[w.getAttribute("id")]=x}function Ei(w){const x=new u.Group;x.name=w.name;const E=w.children;for(let O=0;O<E.length;O++){const I=E[O];x.add(vi(I.id))}return x}function Mr(w){return _e.visualScenes[w]!==void 0}function Zn(w){return tt(_e.visualScenes[w],Ei)}function hs(w){const x=g(w,"instance_visual_scene")[0];return Zn(q(x.getAttribute("url")))}function Ur(){const w=_e.clips;if(De(w)===!0){if(De(_e.animations)===!1){const x=[];for(const E in _e.animations){const O=gt(E);for(let I=0,pe=O.length;I<pe;I++)x.push(O[I])}W.push(new u.AnimationClip("default",-1,x))}}else for(const x in w)W.push(ae(x))}function Hi(w){let x="";const E=[w];for(;E.length;){const O=E.shift();O.nodeType===Node.TEXT_NODE?x+=O.textContent:(x+=`
`,E.push.apply(E,O.childNodes))}return x.trim()}if(ve.length===0)return{scene:new u.Scene};const Sr=new DOMParser().parseFromString(ve,"application/xml"),Dn=g(Sr,"COLLADA")[0],Tr=Sr.getElementsByTagName("parsererror")[0];if(Tr!==void 0){const w=g(Tr,"div")[0];let x;return w?x=w.textContent:x=Hi(Tr),console.error(`THREE.ColladaLoader: Failed to parse collada file.
`,x),null}const tr=Dn.getAttribute("version");console.log("THREE.ColladaLoader: File version",tr);const S=et(g(Dn,"asset")[0]),M=new u.TextureLoader(this.manager);M.setPath(this.resourcePath||A).setCrossOrigin(this.crossOrigin);let P;u.TGALoader&&(P=new u.TGALoader(this.manager),P.setPath(this.resourcePath||A));const W=[];let Le={},ze=0;const _e={animations:{},clips:{},controllers:{},images:{},effects:{},materials:{},cameras:{},lights:{},geometries:{},nodes:{},visualScenes:{},kinematicsModels:{},physicsModels:{},kinematicsScenes:{}};Oe(Dn,"library_animations","animation",bt),Oe(Dn,"library_animation_clips","animation_clip",re),Oe(Dn,"library_controllers","controller",Me),Oe(Dn,"library_images","image",mn),Oe(Dn,"library_effects","effect",cn),Oe(Dn,"library_materials","material",Nt),Oe(Dn,"library_cameras","camera",Vt),Oe(Dn,"library_lights","light",hn),Oe(Dn,"library_geometries","geometry",Ln),Oe(Dn,"library_nodes","node",ii),Oe(Dn,"library_visual_scenes","visual_scene",ks),Oe(Dn,"library_kinematics_models","kinematics_model",yi),Oe(Dn,"library_physics_models","physics_model",Fi),Oe(Dn,"scene","instance_kinematics_scene",Ui),xe(_e.animations,Ge),xe(_e.clips,ne),xe(_e.controllers,ct),xe(_e.images,on),xe(_e.effects,st),xe(_e.materials,Bt),xe(_e.cameras,ni),xe(_e.lights,lr),xe(_e.geometries,H),xe(_e.visualScenes,Ei),Ur(),hr();const qe=hs(g(Dn,"scene")[0]);return qe.animations=W,S.upAxis==="Z_UP"&&qe.quaternion.setFromEuler(new u.Euler(-Math.PI/2,0,0)),qe.scale.multiplyScalar(S.unit),{get animations(){return console.warn("THREE.ColladaLoader: Please access animations over scene.animations now."),W},kinematics:Le,library:_e,scene:qe}}}u.ColladaLoader=me})(),Yt.exports=u.ColladaLoader})(Ah);var tf=Ah.exports;(function(Yt,Mn){const u=Ii,me=vr,ue=Jp,ve=Kp,A=$p,g=ef,G=tf,C=new ue,te=new ve,q=new g,Ie=new A,De=new G;function et(ie,le,Oe){if(ie===void 0)return console.error("Invalid options provided to loadObj()");ie=u._validate(ie,me.prototype._defaults.loadObj);let xe;switch(ie.type||(ie.type="mtl"),ie.type){case"mtl":xe=C;break;case"gltf":case"glb":xe=q;break;case"fbx":xe=Ie;break;case"dae":xe=De;break}te.load(ie.mtl,tt,()=>null,de=>{console.warn("No material file found "+de.stack)});function tt(de){de&&ie.type=="mtl"&&(de.preload(),xe.setMaterials(de)),xe.load(ie.obj,ge=>{let Ge=[];switch(ie.type){case"mtl":ge=ge.children[0];break;case"gltf":case"glb":case"dae":Ge=ge.animations,ge=ge.scene;break;case"fbx":Ge=ge.animations;break}ge.animations=Ge;const gt=u.types.rotation(ie.rotation,[0,0,0]),dt=u.types.scale(ie.scale,[1,1,1]);ge.rotation.set(gt[0],gt[1],gt[2]),ge.scale.set(dt[0],dt[1],dt[2]),ie.normalize&&bt(ge),ge.name="model";let Q=me.prototype._makeGroup(ge,ie);me.prototype._addMethods(Q),Q.setAnchor(ie.anchor),Q.setCenter(ie.adjustment),Q.raycasted=ie.raycasted,Oe(Q),le(Q),Q.setFixedZoom(ie.mapScale),Q.idle()},()=>null,ge=>{console.error("Could not load model file: "+ie.obj+` 
 `+ge.stack),Oe("Error loading the model")})}function bt(de){de.traverse(function(ge){if(ge.isMesh){let Ge;ge.material.type=="MeshStandardMaterial"?(ge.material.metalness&&(ge.material.metalness*=.1),ge.material.glossiness&&(ge.material.glossiness*=.25),Ge=new THREE.Color(12,12,12)):ge.material.type=="MeshPhongMaterial"&&(ge.material.shininess=.1,Ge=new THREE.Color(20,20,20)),ge.material.specular&&ge.material.specular.isColor&&(ge.material.specular=Ge)}})}}Yt.exports=et})(_h);var nf=_h.exports,Lh={exports:{}};(function(Yt,Mn){const u=si,me=Ii,ue=vr;function ve(A){A=me._validate(A,ue.prototype._defaults.line);var g=me.lnglatsToWorld(A.geometry),G=me.normalizeVertices(g),C=me.flattenVectors(G.vertices),te=new u.LineGeometry;te.setPositions(C);let q=new u.LineMaterial({color:A.color,linewidth:A.width,dashed:!1,opacity:A.opacity});return q.resolution.set(window.innerWidth,window.innerHeight),q.isMaterial=!0,q.transparent=!0,q.depthWrite=!1,ve=new u.Line2(te,q),ve.position.copy(G.position),ve.computeLineDistances(),ve}Yt.exports=ve,function(){const A=new u.Box3,g=new u.Vector3;class G extends u.InstancedBufferGeometry{constructor(){super(),this.type="LineSegmentsGeometry";const te=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],q=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],Ie=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(Ie),this.setAttribute("position",new u.Float32BufferAttribute(te,3)),this.setAttribute("uv",new u.Float32BufferAttribute(q,2))}applyMatrix4(te){const q=this.attributes.instanceStart,Ie=this.attributes.instanceEnd;return q!==void 0&&(q.applyMatrix4(te),Ie.applyMatrix4(te),q.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(te){let q;te instanceof Float32Array?q=te:Array.isArray(te)&&(q=new Float32Array(te));const Ie=new u.InstancedInterleavedBuffer(q,6,1);return this.setAttribute("instanceStart",new u.InterleavedBufferAttribute(Ie,3,0)),this.setAttribute("instanceEnd",new u.InterleavedBufferAttribute(Ie,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(te){let q;te instanceof Float32Array?q=te:Array.isArray(te)&&(q=new Float32Array(te));const Ie=new u.InstancedInterleavedBuffer(q,6,1);return this.setAttribute("instanceColorStart",new u.InterleavedBufferAttribute(Ie,3,0)),this.setAttribute("instanceColorEnd",new u.InterleavedBufferAttribute(Ie,3,3)),this}fromWireframeGeometry(te){return this.setPositions(te.attributes.position.array),this}fromEdgesGeometry(te){return this.setPositions(te.attributes.position.array),this}fromMesh(te){return this.fromWireframeGeometry(new u.WireframeGeometry(te.geometry)),this}fromLineSegments(te){const q=te.geometry;if(q.isGeometry){console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");return}else q.isBufferGeometry&&this.setPositions(q.attributes.position.array);return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new u.Box3);const te=this.attributes.instanceStart,q=this.attributes.instanceEnd;te!==void 0&&q!==void 0&&(this.boundingBox.setFromBufferAttribute(te),A.setFromBufferAttribute(q),this.boundingBox.union(A))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new u.Sphere),this.boundingBox===null&&this.computeBoundingBox();const te=this.attributes.instanceStart,q=this.attributes.instanceEnd;if(te!==void 0&&q!==void 0){const Ie=this.boundingSphere.center;this.boundingBox.getCenter(Ie);let De=0;for(let et=0,ie=te.count;et<ie;et++)g.fromBufferAttribute(te,et),De=Math.max(De,Ie.distanceToSquared(g)),g.fromBufferAttribute(q,et),De=Math.max(De,Ie.distanceToSquared(g));this.boundingSphere.radius=Math.sqrt(De),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(te){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(te)}}G.prototype.isLineSegmentsGeometry=!0,u.LineSegmentsGeometry=G}(),function(){class A extends u.LineSegmentsGeometry{constructor(){super(),this.type="LineGeometry"}setPositions(G){for(var C=G.length-3,te=new Float32Array(2*C),q=0;q<C;q+=3)te[2*q]=G[q],te[2*q+1]=G[q+1],te[2*q+2]=G[q+2],te[2*q+3]=G[q+3],te[2*q+4]=G[q+4],te[2*q+5]=G[q+5];return super.setPositions(te),this}setColors(G){for(var C=G.length-3,te=new Float32Array(2*C),q=0;q<C;q+=3)te[2*q]=G[q],te[2*q+1]=G[q+1],te[2*q+2]=G[q+2],te[2*q+3]=G[q+3],te[2*q+4]=G[q+4],te[2*q+5]=G[q+5];return super.setColors(te),this}fromLine(G){var C=G.geometry;if(C.isGeometry){console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");return}else C.isBufferGeometry&&this.setPositions(C.attributes.position.array);return this}}A.prototype.isLineGeometry=!0,u.LineGeometry=A}(),function(){class A extends u.LineSegmentsGeometry{constructor(G){super(),this.type="WireframeGeometry2",this.fromWireframeGeometry(new u.WireframeGeometry(G))}}A.prototype.isWireframeGeometry2=!0,u.WireframeGeometry2=A}(),function(){u.UniformsLib.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new u.Vector2(1,1)},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},u.ShaderLib.line={uniforms:u.UniformsUtils.merge([u.UniformsLib.common,u.UniformsLib.fog,u.UniformsLib.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			worldStart = start.xyz;
			worldEnd = end.xyz;

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class A extends u.ShaderMaterial{constructor(G){super({type:"LineMaterial",uniforms:u.UniformsUtils.clone(u.ShaderLib.line.uniforms),vertexShader:u.ShaderLib.line.vertexShader,fragmentShader:u.ShaderLib.line.fragmentShader,clipping:!0}),Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(C){this.uniforms.diffuse.value=C}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(C){C===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(C){this.uniforms.linewidth.value=C}},dashed:{enumerable:!0,get:function(){return"USE_DASH"in this.defines},set(C){!!C!="USE_DASH"in this.defines&&(this.needsUpdate=!0),C===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(C){this.uniforms.dashScale.value=C}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(C){this.uniforms.dashSize.value=C}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(C){this.uniforms.dashOffset.value=C}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(C){this.uniforms.gapSize.value=C}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(C){this.uniforms.opacity.value=C}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(C){this.uniforms.resolution.value.copy(C)}},alphaToCoverage:{enumerable:!0,get:function(){return"ALPHA_TO_COVERAGE"in this.defines},set:function(C){!!C!="ALPHA_TO_COVERAGE"in this.defines&&(this.needsUpdate=!0),C===!0?(this.defines.ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(G)}}A.prototype.isLineMaterial=!0,u.LineMaterial=A}(),function(){const A=new u.Vector3,g=new u.Vector3,G=new u.Vector4,C=new u.Vector4,te=new u.Vector4,q=new u.Vector3,Ie=new u.Matrix4,De=new u.Line3,et=new u.Vector3,ie=new u.Box3,le=new u.Sphere,Oe=new u.Vector4;class xe extends u.Mesh{constructor(bt=new u.LineSegmentsGeometry,de=new u.LineMaterial({color:Math.random()*16777215})){super(bt,de),this.type="LineSegments2"}computeLineDistances(){const bt=this.geometry,de=bt.attributes.instanceStart,ge=bt.attributes.instanceEnd,Ge=new Float32Array(2*de.count);for(let dt=0,Q=0,Y=de.count;dt<Y;dt++,Q+=2)A.fromBufferAttribute(de,dt),g.fromBufferAttribute(ge,dt),Ge[Q]=Q===0?0:Ge[Q-1],Ge[Q+1]=Ge[Q]+A.distanceTo(g);const gt=new u.InstancedInterleavedBuffer(Ge,2,1);return bt.setAttribute("instanceDistanceStart",new u.InterleavedBufferAttribute(gt,1,0)),bt.setAttribute("instanceDistanceEnd",new u.InterleavedBufferAttribute(gt,1,1)),this}raycast(bt,de){bt.camera===null&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');const ge=bt.params.Line2!==void 0&&bt.params.Line2.threshold||0,Ge=bt.ray,gt=bt.camera,dt=gt.projectionMatrix,Q=this.matrixWorld,Y=this.geometry,Be=this.material,yt=Be.resolution,He=Be.linewidth+ge,v=Y.attributes.instanceStart,L=Y.attributes.instanceEnd,R=-gt.near,D=2*Math.max(He/yt.width,He/yt.height);Y.boundingSphere===null&&Y.computeBoundingSphere(),le.copy(Y.boundingSphere).applyMatrix4(Q);const N=Math.max(gt.near,le.distanceToPoint(Ge.origin));Oe.set(0,0,-N,1).applyMatrix4(gt.projectionMatrix),Oe.multiplyScalar(1/Oe.w),Oe.applyMatrix4(gt.projectionMatrixInverse);const re=Math.abs(D/Oe.w)*.5;if(le.radius+=re,bt.ray.intersectsSphere(le)===!1)return;Y.boundingBox===null&&Y.computeBoundingBox(),ie.copy(Y.boundingBox).applyMatrix4(Q);const ne=Math.max(gt.near,ie.distanceToPoint(Ge.origin));Oe.set(0,0,-ne,1).applyMatrix4(gt.projectionMatrix),Oe.multiplyScalar(1/Oe.w),Oe.applyMatrix4(gt.projectionMatrixInverse);const ae=Math.abs(D/Oe.w)*.5;if(ie.max.x+=ae,ie.max.y+=ae,ie.max.z+=ae,ie.min.x-=ae,ie.min.y-=ae,ie.min.z-=ae,bt.ray.intersectsBox(ie)!==!1){Ge.at(1,te),te.w=1,te.applyMatrix4(gt.matrixWorldInverse),te.applyMatrix4(dt),te.multiplyScalar(1/te.w),te.x*=yt.x/2,te.y*=yt.y/2,te.z=0,q.copy(te),Ie.multiplyMatrices(gt.matrixWorldInverse,Q);for(let oe=0,be=v.count;oe<be;oe++){G.fromBufferAttribute(v,oe),C.fromBufferAttribute(L,oe),G.w=1,C.w=1,G.applyMatrix4(Ie),C.applyMatrix4(Ie);var Me=G.z>R&&C.z>R;if(Me)continue;if(G.z>R){const mn=G.z-C.z,on=(G.z-R)/mn;G.lerp(C,on)}else if(C.z>R){const mn=C.z-G.z,on=(C.z-R)/mn;C.lerp(G,on)}G.applyMatrix4(dt),C.applyMatrix4(dt),G.multiplyScalar(1/G.w),C.multiplyScalar(1/C.w),G.x*=yt.x/2,G.y*=yt.y/2,C.x*=yt.x/2,C.y*=yt.y/2,De.start.copy(G),De.start.z=0,De.end.copy(C),De.end.z=0;const ot=De.closestPointToPointParameter(q,!0);De.at(ot,et);const ct=u.MathUtils.lerp(G.z,C.z,ot),wt=ct>=-1&&ct<=1,Jt=q.distanceTo(et)<He*.5;if(wt&&Jt){De.start.fromBufferAttribute(v,oe),De.end.fromBufferAttribute(L,oe),De.start.applyMatrix4(Q),De.end.applyMatrix4(Q);const mn=new u.Vector3,on=new u.Vector3;Ge.distanceSqToSegment(De.start,De.end,on,mn),de.push({point:on,pointOnLine:mn,distance:Ge.origin.distanceTo(on),object:this,face:null,faceIndex:oe,uv:null,uv2:null})}}}}}xe.prototype.LineSegments2=!0,u.LineSegments2=xe}(),function(){class A extends u.LineSegments2{constructor(G=new u.LineGeometry,C=new u.LineMaterial({color:Math.random()*16777215})){super(G,C),this.type="Line2"}}A.prototype.isLine2=!0,u.Line2=A}(),function(){const A=new u.Vector3,g=new u.Vector3;class G extends u.Mesh{constructor(te=new u.LineSegmentsGeometry,q=new u.LineMaterial({color:Math.random()*16777215})){super(te,q),this.type="Wireframe"}computeLineDistances(){const te=this.geometry,q=te.attributes.instanceStart,Ie=te.attributes.instanceEnd,De=new Float32Array(2*q.count);for(let ie=0,le=0,Oe=q.count;ie<Oe;ie++,le+=2)A.fromBufferAttribute(q,ie),g.fromBufferAttribute(Ie,ie),De[le]=le===0?0:De[le-1],De[le+1]=De[le]+A.distanceTo(g);const et=new u.InstancedInterleavedBuffer(De,2,1);return te.setAttribute("instanceDistanceStart",new u.InterleavedBufferAttribute(et,1,0)),te.setAttribute("instanceDistanceEnd",new u.InterleavedBufferAttribute(et,1,1)),this}}G.prototype.isWireframe=!0,u.Wireframe=G}()})(Lh);var rf=Lh.exports,Rh={exports:{}};(function(Yt,Mn){const u=Ii,me=Ol,ue=vr,ve=si,A=yo;function g(G,C){G=u._validate(G,ue.prototype._defaults.tube);let te=[];G.geometry.forEach(ie=>{te.push(new ve.Vector3(ie[0],ie[1],ie[2]))});const q=new ve.CatmullRomCurve3(te);let Ie=new ve.TubeGeometry(q,te.length,G.radius,G.sides,!1),De=me(G),et=new ve.Mesh(Ie,De);return new A({obj:et,units:G.units,anchor:G.anchor,adjustment:G.adjustment,bbox:G.bbox,tooltip:G.tooltip,raycasted:G.raycasted})}Yt.exports=g})(Rh);var sf=Rh.exports,Ch={exports:{}};(function(Yt,Mn){const u=go;function me(ue){this.map=ue,this.renderer=new u.CSS2DRenderer,this.renderer.setSize(this.map.getCanvas().clientWidth,this.map.getCanvas().clientHeight),this.renderer.domElement.style.position="absolute",this.renderer.domElement.id="labelCanvas",this.renderer.domElement.style.top=0,this.renderer.domElement.style.zIndex="0",this.map.getCanvasContainer().appendChild(this.renderer.domElement),this.scene,this.camera,this.dispose=function(){this.map.getCanvasContainer().removeChild(this.renderer.domElement),this.renderer.domElement.remove(),this.renderer={}},this.setSize=function(ve,A){this.renderer.setSize(ve,A)},this.map.on("resize",(function(){this.renderer.setSize(this.map.getCanvas().clientWidth,this.map.getCanvas().clientHeight)}).bind(this)),this.state={reset:function(){}},this.render=async function(ve,A){return this.scene=ve,this.camera=A,new Promise(g=>{g(this.renderer.render(ve,A))})},this.toggleLabels=async function(ve,A){return new Promise(g=>{g(this.setVisibility(ve,A,this.scene,this.camera,this.renderer))})},this.setVisibility=function(ve,A,g,G,C){var te=this.renderer.cacheList;te.forEach(function(q){q.visible!=A&&q.layer===ve&&(A&&q.alwaysVisible||!A)&&(q.visible=A,C.renderObject(q,g,G))})}}Yt.exports=me})(Ch);var af=Ch.exports,Ph={exports:{}};(function(Yt,Mn){class u{constructor(ue,ve){this.id=ue.layerId,this.type="custom",this.renderingMode="3d",this.opacity=.5,this.buildingsLayerId=ue.buildingsLayerId,this.minAltitude=ue.minAltitude||.1,this.tb=ve}onAdd(ue,ve){this.map=ue;const A=`
			uniform mat4 u_matrix;
			uniform float u_height_factor;
			uniform float u_altitude;
			uniform float u_azimuth;
			attribute vec2 a_pos;
			attribute vec4 a_normal_ed;
			attribute lowp vec2 a_base;
			attribute lowp vec2 a_height;
			void main() {
				float base = max(0.0, a_base.x);
				float height = max(0.0, a_height.x);
				float t = mod(a_normal_ed.x, 2.0);
				vec4 pos = vec4(a_pos, t > 0.0 ? height : base, 1);
				float len = pos.z * u_height_factor / tan(u_altitude);
				pos.x += cos(u_azimuth) * len;
				pos.y += sin(u_azimuth) * len;
				pos.z = 0.0;
				gl_Position = u_matrix * pos;
			}
			`,g=`
			void main() {
				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.7);
			}
			`,G=ve.createShader(ve.VERTEX_SHADER);ve.shaderSource(G,A),ve.compileShader(G);const C=ve.createShader(ve.FRAGMENT_SHADER);ve.shaderSource(C,g),ve.compileShader(C),this.program=ve.createProgram(),ve.attachShader(this.program,G),ve.attachShader(this.program,C),ve.linkProgram(this.program),ve.validateProgram(this.program),this.uMatrix=ve.getUniformLocation(this.program,"u_matrix"),this.uHeightFactor=ve.getUniformLocation(this.program,"u_height_factor"),this.uAltitude=ve.getUniformLocation(this.program,"u_altitude"),this.uAzimuth=ve.getUniformLocation(this.program,"u_azimuth"),this.aPos=ve.getAttribLocation(this.program,"a_pos"),this.aNormal=ve.getAttribLocation(this.program,"a_normal_ed"),this.aBase=ve.getAttribLocation(this.program,"a_base"),this.aHeight=ve.getAttribLocation(this.program,"a_height")}render(ue,ve){ue.useProgram(this.program);const A=this.map.style.sourceCaches.composite,g=A.getVisibleCoordinates().reverse(),G=this.map.getLayer(this.buildingsLayerId),C=this.map.painter.context,{lng:te,lat:q}=this.map.getCenter(),Ie=this.tb.getSunPosition(this.tb.lightDateTime,[te,q]);ue.uniform1f(this.uAltitude,Ie.altitude>this.minAltitude?Ie.altitude:0),ue.uniform1f(this.uAzimuth,Ie.azimuth+3*Math.PI/2),ue.enable(ue.BLEND),ue.blendFunc(ue.SRC_ALPHA,ue.ONE_MINUS_SRC_ALPHA),ue.getExtension("EXT_blend_minmax"),ue.disable(ue.DEPTH_TEST);for(const De of g){const et=A.getTile(De),ie=et.getBucket(G);if(!ie)continue;const[le,Oe]=ie.programConfigurations.programConfigurations[this.buildingsLayerId]._buffers;ue.uniformMatrix4fv(this.uMatrix,!1,De.posMatrix),ue.uniform1f(this.uHeightFactor,Math.pow(2,De.overscaledZ)/et.tileSize/8);for(const xe of ie.segments.get()){const tt=C.currentNumAttributes||0,bt=2;for(let ge=bt;ge<tt;ge++)ue.disableVertexAttribArray(ge);const de=xe.vertexOffset||0;ue.enableVertexAttribArray(this.aPos),ue.enableVertexAttribArray(this.aNormal),ue.enableVertexAttribArray(this.aHeight),ue.enableVertexAttribArray(this.aBase),ie.layoutVertexBuffer.bind(),ue.vertexAttribPointer(this.aPos,2,ue.SHORT,!1,12,12*de),ue.vertexAttribPointer(this.aNormal,4,ue.SHORT,!1,12,4+12*de),le.bind(),ue.vertexAttribPointer(this.aHeight,1,ue.FLOAT,!1,4,4*de),Oe.bind(),ue.vertexAttribPointer(this.aBase,1,ue.FLOAT,!1,4,4*de),ie.indexBuffer.bind(),C.currentNumAttributes=bt,ue.drawElements(ue.TRIANGLES,xe.primitiveLength*3,ue.UNSIGNED_SHORT,xe.primitiveOffset*3*2)}}}}Yt.exports=u})(Ph);var of=Ph.exports;(function(Yt,Mn){const u=si,me=Vp,ue=Ii,ve=Wp,A=Dl,g=vr,G=Ol,C=qp,te=Xp,q=Zp,Ie=Yp,De=nf,et=yo,ie=rf,le=sf,Oe=af,xe=of;function tt(de,ge,Ge){this.init(de,ge,Ge)}tt.prototype={repaint:function(){this.map.repaint=!0},init:function(de,ge,Ge){this.options=ue._validate(Ge||{},bt),this.map=de,this.map.tb=this,this.objects=new g,this.mapboxVersion=parseFloat(this.map.version),this.renderer=new u.WebGLRenderer({alpha:!0,antialias:!0,preserveDrawingBuffer:Ge.preserveDrawingBuffer,canvas:de.getCanvas(),context:ge}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.map.getCanvas().clientWidth,this.map.getCanvas().clientHeight),this.renderer.outputEncoding=u.sRGBEncoding,this.renderer.autoClear=!1,this.labelRenderer=new Oe(this.map),this.scene=new u.Scene,this.world=new u.Group,this.world.name="world",this.scene.add(this.world),this.objectsCache=new Map,this.zoomLayers=[],this.fov=this.options.fov,this.orthographic=this.options.orthographic||!1,this.raycaster=new u.Raycaster,this.raycaster.layers.set(0),this.mapCenter=this.map.getCenter(),this.mapCenterUnits=ue.projectToWorld([this.mapCenter.lng,this.mapCenter.lat]),this.lightDateTime=new Date,this.lightLng=this.mapCenter.lng,this.lightLat=this.mapCenter.lat,this.sunPosition,this.rotationStep=5,this.gridStep=6,this.altitudeStep=.1,this.defaultCursor="default",this.lights=this.initLights,this.options.defaultLights&&this.defaultLights(),this.options.realSunlight&&this.realSunlight(this.options.realSunlightHelper),this.skyLayerName="sky-layer",this.terrainSourceName="mapbox-dem",this.terrainExaggeration=1,this.terrainLayerName="",this.enableSelectingFeatures=this.options.enableSelectingFeatures||!1,this.enableSelectingObjects=this.options.enableSelectingObjects||!1,this.enableDraggingObjects=this.options.enableDraggingObjects||!1,this.enableRotatingObjects=this.options.enableRotatingObjects||!1,this.enableTooltips=this.options.enableTooltips||!1,this.multiLayer=this.options.multiLayer||!1,this.enableHelpTooltips=this.options.enableHelpTooltips||!1,this.map.on("style.load",function(){this.tb.zoomLayers=[],this.tb.options.multiLayer&&this.addLayer({id:"threebox_layer",type:"custom",renderingMode:"3d",map:this,onAdd:function(dt,Q){},render:function(dt,Q){this.map.tb.update()}}),this.once("idle",()=>{this.tb.setObjectsScale()}),this.tb.options.sky&&(this.tb.sky=!0),this.tb.options.terrain&&(this.tb.terrain=!0),["satellite","mapbox-mapbox-satellite","satelliteLayer"].forEach(dt=>{this.getLayer(dt)&&(this.tb.terrainLayerName=dt)})}),this.map.on("load",function(){this.selectedObject,this.selectedFeature,this.draggedObject;let gt;this.overedObject,this.overedFeature;let dt=this.getCanvasContainer();this.getCanvasContainer().style.cursor=this.tb.defaultCursor;let Q,Y=[],Be,yt,He,v;function L(oe){var be=dt.getBoundingClientRect();return{x:oe.originalEvent.clientX-be.left-dt.clientLeft,y:oe.originalEvent.clientY-be.top-dt.clientTop}}this.unselectObject=function(){this.selectedObject.selected=!1,this.selectedObject=null},this.outObject=function(){this.overedObject.over=!1,this.overedObject=null},this.unselectFeature=function(oe){typeof oe.id>"u"||(this.setFeatureState({source:oe.source,sourceLayer:oe.sourceLayer,id:oe.id},{select:!1}),this.removeTooltip(oe),oe=this.queryRenderedFeatures({layers:[oe.layer.id],filter:["==",["id"],oe.id]})[0],oe&&this.fire("SelectedFeatureChange",{detail:oe}),this.selectedFeature=null)},this.selectFeature=function(oe){this.selectedFeature=oe,this.setFeatureState({source:this.selectedFeature.source,sourceLayer:this.selectedFeature.sourceLayer,id:this.selectedFeature.id},{select:!0}),this.selectedFeature=this.queryRenderedFeatures({layers:[this.selectedFeature.layer.id],filter:["==",["id"],this.selectedFeature.id]})[0],this.addTooltip(this.selectedFeature),this.fire("SelectedFeatureChange",{detail:this.selectedFeature})},this.outFeature=function(oe){this.overedFeature&&typeof this.overedFeature<"u"&&this.overedFeature.id!=oe&&(de.setFeatureState({source:this.overedFeature.source,sourceLayer:this.overedFeature.sourceLayer,id:this.overedFeature.id},{hover:!1}),this.removeTooltip(this.overedFeature),this.overedFeature=null)},this.addTooltip=function(oe){if(!this.tb.enableTooltips)return;let be=this.tb.getFeatureCenter(oe),ot=this.tb.tooltip({text:oe.properties.name||oe.id||oe.type,mapboxStyle:!0,feature:oe});ot.setCoords(be),this.tb.add(ot,oe.layer.id),oe.tooltip=ot,oe.tooltip.tooltip.visible=!0},this.removeTooltip=function(oe){oe.tooltip&&(oe.tooltip.visibility=!1,this.tb.remove(oe.tooltip),oe.tooltip=null)},de.onContextMenu=function(oe){alert("contextMenu")},this.onClick=function(oe){let be,ot=[];if(de.tb.enableSelectingObjects&&(ot=this.tb.queryRenderedFeatures(oe.point)),be=typeof ot[0]=="object",be){let ct=tt.prototype.findParent3DObject(ot[0]);if(ct){if(this.selectedFeature&&this.unselectFeature(this.selectedFeature),!this.selectedObject)this.selectedObject=ct,this.selectedObject.selected=!0;else if(this.selectedObject.uuid!=ct.uuid)this.selectedObject.selected=!1,ct.selected=!0,this.selectedObject=ct;else if(this.selectedObject.uuid==ct.uuid){this.unselectObject();return}this.selectedObject.dispatchEvent({type:"Wireframed",detail:this.selectedObject}),this.selectedObject.dispatchEvent({type:"IsPlayingChanged",detail:this.selectedObject}),this.repaint=!0,oe.preventDefault()}}else{let ct=[];if(de.tb.enableSelectingFeatures&&(ct=this.queryRenderedFeatures(oe.point)),ct.length>0&&ct[0].layer.type=="fill-extrusion"&&typeof ct[0].id<"u"){if(this.selectedObject&&this.unselectObject(),!this.selectedFeature)this.selectFeature(ct[0]);else if(this.selectedFeature.id!=ct[0].id)this.unselectFeature(this.selectedFeature),this.selectFeature(ct[0]);else if(this.selectedFeature.id==ct[0].id){this.unselectFeature(this.selectedFeature);return}}}},this.onMouseMove=function(oe){let be=L(oe);if(this.getCanvasContainer().style.cursor=this.tb.defaultCursor,oe.originalEvent.altKey&&this.draggedObject){if(!de.tb.enableRotatingObjects)return;gt="rotate",this.getCanvasContainer().style.cursor="move",Math.min(Q.x,be.x),Math.max(Q.x,be.x),Math.min(Q.y,be.y),Math.max(Q.y,be.y);let wt={x:0,y:0,z:Math.round(v[2]+~~((be.x-Q.x)/this.tb.rotationStep)%360*this.tb.rotationStep%360)};this.draggedObject.setRotation(wt),de.tb.enableHelpTooltips&&this.draggedObject.addHelp("rot: "+wt.z+"&#176;");return}if(oe.originalEvent.shiftKey&&this.draggedObject){if(!de.tb.enableDraggingObjects)return;gt="translate",this.getCanvasContainer().style.cursor="move";let wt=oe.lngLat,Jt=[Number((wt.lng+Be).toFixed(this.tb.gridStep)),Number((wt.lat+yt).toFixed(this.tb.gridStep)),this.draggedObject.modelHeight];this.draggedObject.setCoords(Jt),de.tb.enableHelpTooltips&&this.draggedObject.addHelp("lng: "+Jt[0]+"&#176;, lat: "+Jt[1]+"&#176;");return}if(oe.originalEvent.ctrlKey&&this.draggedObject){if(!de.tb.enableDraggingObjects)return;gt="altitude",this.getCanvasContainer().style.cursor="move";let wt=oe.point.y*this.tb.altitudeStep,Jt=[this.draggedObject.coordinates[0],this.draggedObject.coordinates[1],Number((-wt-He).toFixed(this.tb.gridStep))];this.draggedObject.setCoords(Jt),de.tb.enableHelpTooltips&&this.draggedObject.addHelp("alt: "+Jt[2]+"m");return}let ot,ct=[];if(de.tb.enableSelectingObjects&&(ct=this.tb.queryRenderedFeatures(oe.point)),ot=typeof ct[0]=="object",ot){let wt=tt.prototype.findParent3DObject(ct[0]);wt&&(this.outFeature(this.overedFeature),this.getCanvasContainer().style.cursor="pointer",!this.selectedObject||wt.uuid!=this.selectedObject.uuid?(this.overedObject&&this.overedObject.uuid!=wt.uuid&&this.outObject(),wt.over=!0,this.overedObject=wt):this.selectedObject&&wt.uuid==this.selectedObject.uuid&&(wt.over=!0,this.overedObject=wt),this.repaint=!0,oe.preventDefault())}else{this.overedObject&&this.outObject();let wt=[];de.tb.enableSelectingFeatures&&(wt=this.queryRenderedFeatures(oe.point)),wt.length>0&&(this.outFeature(wt[0]),wt[0].layer.type=="fill-extrusion"&&typeof wt[0].id<"u"&&(!this.selectedFeature||this.selectedFeature.id!=wt[0].id)&&(this.getCanvasContainer().style.cursor="pointer",this.overedFeature=wt[0],this.setFeatureState({source:this.overedFeature.source,sourceLayer:this.overedFeature.sourceLayer,id:this.overedFeature.id},{hover:!0}),this.overedFeature=de.queryRenderedFeatures({layers:[this.overedFeature.layer.id],filter:["==",["id"],this.overedFeature.id]})[0],this.addTooltip(this.overedFeature)))}},this.onMouseDown=function(oe){(oe.originalEvent.shiftKey||oe.originalEvent.altKey||oe.originalEvent.ctrlKey)&&oe.originalEvent.button===0&&this.selectedObject&&(!de.tb.enableDraggingObjects&&!de.tb.enableRotatingObjects||(oe.preventDefault(),de.getCanvasContainer().style.cursor="move",de.once("mouseup",this.onMouseUp),this.draggedObject=this.selectedObject,Q=L(oe),Y=this.draggedObject.coordinates,v=ue.degreeify(this.draggedObject.rotation),Be=Y[0]-oe.lngLat.lng,yt=Y[1]-oe.lngLat.lat,He=-this.draggedObject.modelHeight-oe.point.y*this.tb.altitudeStep))},this.onMouseUp=function(oe){this.getCanvasContainer().style.cursor=this.tb.defaultCursor,this.off("mouseup",this.onMouseUp),this.off("mouseout",this.onMouseUp),this.dragPan.enable(),this.draggedObject&&(this.draggedObject.dispatchEvent({type:"ObjectDragged",detail:{draggedObject:this.draggedObject,draggedAction:gt}}),this.draggedObject.removeHelp(),this.draggedObject=null,gt=null)},this.onMouseOut=function(oe){if(this.overedFeature){let be=this.queryRenderedFeatures(oe.point);be.length>0&&this.overedFeature.id!=be[0].id&&(this.getCanvasContainer().style.cursor=this.tb.defaultCursor,this.outFeature(be[0]))}},this.onZoom=function(oe){this.tb.zoomLayers.forEach(be=>{this.tb.toggleLayer(be)}),this.tb.setObjectsScale()};let R=!1,D=17,N=91,re=16,ne=83;function ae(oe){oe.which===D||oe.which,oe.which===re&&(R=!0);let be=this.selectedObject;if(R&&oe.which===ne&&be){let ot=ue.toDecimal;if(be.help)be.removeHelp();else{let ct=be.modelSize,wt=1;be.userData.units!=="meters"&&(wt=ue.projectedUnitsPerMeter(be.coordinates[1]),wt||(wt=1),wt=ot(wt,7)),de.tb.enableHelpTooltips&&be.addHelp("size(m): "+ot(ct.x/wt,3)+" W, "+ot(ct.y/wt,3)+" L, "+ot(ct.z/wt,3)+" H"),this.repaint=!0}return!1}}function Me(oe){oe.which==D||oe.which==N,oe.which===re&&(R=!1)}this.on("click",this.onClick),this.on("mousemove",this.onMouseMove),this.on("mouseout",this.onMouseOut),this.on("mousedown",this.onMouseDown),this.on("zoom",this.onZoom),this.on("zoomend",this.onZoom),document.addEventListener("keydown",ae.bind(this),!0),document.addEventListener("keyup",Me.bind(this))})},get sky(){return this.options.sky},set sky(de){de?this.createSkyLayer():this.removeLayer(this.skyLayerName),this.options.sky=de},get terrain(){return this.options.terrain},set terrain(de){if(this.terrainLayerName="",de)this.createTerrainLayer();else{if(this.mapboxVersion<2){console.warn("Terrain layer are only supported by Mapbox-gl-js > v2.0");return}this.map.getTerrain()&&(this.map.setTerrain(null),this.map.removeSource(this.terrainSourceName))}this.options.terrain=de},get fov(){return this.options.fov},set fov(de){this.camera instanceof u.PerspectiveCamera&&this.options.fov!==de&&(this.map.transform.fov=de,this.camera.fov=this.map.transform.fov,this.cameraSync.setupCamera(),this.map.repaint=!0,this.options.fov=de)},get orthographic(){return this.options.orthographic},set orthographic(de){const ge=this.map.getCanvas().clientHeight,Ge=this.map.getCanvas().clientWidth;de?(this.map.transform.fov=0,this.camera=new u.OrthographicCamera(Ge/-2,Ge/2,ge/2,ge/-2,.1,1e21)):(this.map.transform.fov=this.fov,this.camera=new u.PerspectiveCamera(this.map.transform.fov,Ge/ge,.1,1e21)),this.camera.layers.enable(0),this.camera.layers.enable(1),this.cameraSync=new me(this.map,this.camera,this.world),this.map.repaint=!0,this.options.orthographic=de},createSkyLayer:function(){if(this.mapboxVersion<2){console.warn("Sky layer are only supported by Mapbox-gl-js > v2.0"),this.options.sky=!1;return}this.map.getLayer(this.skyLayerName)||(this.map.addLayer({id:this.skyLayerName,type:"sky",paint:{"sky-opacity":["interpolate",["linear"],["zoom"],0,0,5,.3,8,1],"sky-type":"atmosphere","sky-atmosphere-sun":this.getSunSky(this.lightDateTime),"sky-atmosphere-sun-intensity":10}}),this.map.once("idle",()=>{this.setSunlight(),this.repaint()}))},createTerrainLayer:function(){if(this.mapboxVersion<2){console.warn("Terrain layer are only supported by Mapbox-gl-js > v2.0"),this.options.terrain=!1;return}this.map.getTerrain()||(this.map.addSource(this.terrainSourceName,{type:"raster-dem",url:"mapbox://mapbox.mapbox-terrain-dem-v1",tileSize:512,maxzoom:14}),this.map.setTerrain({source:this.terrainSourceName,exaggeration:this.terrainExaggeration}),this.map.once("idle",()=>{this.cameraSync.updateCamera(),this.repaint()}))},sphere:function(de){return this.setDefaultView(de,this.options),C(de,this.world)},line:ie,label:q,tooltip:Ie,tube:function(de){return this.setDefaultView(de,this.options),le(de,this.world)},extrusion:function(de){return this.setDefaultView(de,this.options),te(de)},Object3D:function(de){return this.setDefaultView(de,this.options),et(de)},loadObj:async function(ge,Ge){if(this.setDefaultView(ge,this.options),ge.clone===!1)return new Promise(async gt=>{De(ge,Ge,async dt=>{gt(dt)})});{let gt=this.objectsCache.get(ge.obj);gt?gt.promise.then(dt=>{Ge(dt.duplicate(ge))}).catch(dt=>{this.objectsCache.delete(ge.obj),console.error("Could not load model file: "+ge.obj)}):this.objectsCache.set(ge.obj,{promise:new Promise(async(dt,Q)=>{De(ge,Ge,async Y=>{Y.duplicate?dt(Y.duplicate()):Q(Y)})})})}},material:function(de){return G(de)},initLights:{ambientLight:null,dirLight:null,dirLightBack:null,dirLightHelper:null,hemiLight:null,pointLight:null},utils:ue,SunCalc:ve,Constants:A,projectToWorld:function(de){return this.utils.projectToWorld(de)},unprojectFromWorld:function(de){return this.utils.unprojectFromWorld(de)},projectedUnitsPerMeter:function(de){return this.utils.projectedUnitsPerMeter(de)},getFeatureCenter:function(ge,Ge,gt){return ue.getFeatureCenter(ge,Ge,gt)},getObjectHeightOnFloor:function(de,ge,Ge){return ue.getObjectHeightOnFloor(de,ge,Ge)},queryRenderedFeatures:function(de){let ge=new u.Vector2;return ge.x=de.x/this.map.transform.width*2-1,ge.y=1-de.y/this.map.transform.height*2,this.raycaster.setFromCamera(ge,this.camera),this.raycaster.intersectObjects(this.world.children,!0)},findParent3DObject:function(de){var ge;return de.object.traverseAncestors(function(Ge){Ge.parent&&Ge.parent.type=="Group"&&Ge.userData.obj&&(ge=Ge)}),ge},setLayoutProperty:function(de,ge,Ge){this.map.setLayoutProperty(de,ge,Ge),Ge!=null&&ge==="visibility"&&this.world.children.filter(gt=>gt.layer===de).forEach(gt=>{gt.visibility=Ge})},setLayerZoomRange:function(de,ge,Ge){this.map.getLayer(de)&&(this.map.setLayerZoomRange(de,ge,Ge),this.zoomLayers.includes(de)||this.zoomLayers.push(de),this.toggleLayer(de))},setLayerHeigthProperty:function(de,ge){let Ge=this.map.getLayer(de);if(Ge)if(Ge.type=="fill-extrusion"){let gt=this.map.getStyle().sources[Ge.source].data;gt.features.forEach(function(Q){Q.properties.level=ge}),this.map.getSource(Ge.source).setData(gt)}else Ge.type=="custom"&&this.world.children.forEach(function(gt){let dt=gt.userData.feature;if(dt&&dt.layer===de){let Q=this.tb.getFeatureCenter(dt,gt,ge);gt.setCoords(Q)}})},setObjectsScale:function(){this.world.children.filter(de=>de.fixedZoom!=null).forEach(de=>{de.setObjectScale(this.map.transform.scale)})},setStyle:function(de,ge){this.clear().then(()=>{this.map.setStyle(de,ge)})},toggleLayer:function(de,ge=!0){let Ge=this.map.getLayer(de);if(Ge){if(!ge){this.toggle(Ge.id,!1);return}let gt=this.map.getZoom();if(Ge.minzoom&&gt<Ge.minzoom){this.toggle(Ge.id,!1);return}if(Ge.maxzoom&&gt>=Ge.maxzoom){this.toggle(Ge.id,!1);return}this.toggle(Ge.id,!0)}},toggle:function(de,ge){this.setLayoutProperty(de,"visibility",ge?"visible":"none"),this.labelRenderer.toggleLabels(de,ge)},update:function(){this.map.repaint&&(this.map.repaint=!1);var de=Date.now();this.objects.animationManager.update(de),this.updateLightHelper(),this.renderer.resetState(),this.renderer.render(this.scene,this.camera),this.labelRenderer.render(this.scene,this.camera),this.options.passiveRendering===!1&&this.map.triggerRepaint()},add:function(de,ge,Ge){if(!this.enableTooltips&&de.tooltip&&(de.tooltip.visibility=!1),this.world.add(de),ge){de.layer=ge,de.source=Ge;let gt=this.map.getLayer(ge);if(gt){let dt=gt.visibility,Q=typeof dt>"u";de.visibility=!!(Q||dt==="visible")}}},removeByName:function(de){let ge=this.world.getObjectByName(de);ge&&this.remove(ge)},remove:function(de){this.map.selectedObject&&de.uuid==this.map.selectedObject.uuid&&this.map.unselectObject(),this.map.draggedObject&&de.uuid==this.map.draggedObject.uuid&&(this.map.draggedObject=null),de.dispose&&de.dispose(),this.world.remove(de),de=null},clear:async function(de=null,ge=!1){return new Promise((Ge,gt)=>{let dt=[];this.world.children.forEach(function(Q){dt.push(Q)});for(let Q=0;Q<dt.length;Q++){let Y=dt[Q];(Y.layer===de||!de)&&this.remove(Y)}ge&&this.objectsCache.forEach(Q=>{Q.promise.then(Y=>{Y.dispose(),Y=null})}),Ge("clear")})},removeLayer:function(de){this.clear(de,!0).then(()=>{this.map.removeLayer(de)})},getSunPosition:function(de,ge){return ve.getPosition(de||Date.now(),ge[1],ge[0])},getSunTimes:function(de,ge){return ve.getTimes(de,ge[1],ge[0],ge[2]?ge[2]:0)},setBuildingShadows:function(de){if(this.map.getLayer(de.buildingsLayerId)){let ge=new xe(de,this);this.map.addLayer(ge,de.buildingsLayerId)}else console.warn("The layer '"+de.buildingsLayerId+"' does not exist in the map.")},setSunlight:function(de=new Date,ge){if(!this.lights.dirLight||!this.options.realSunlight){console.warn("To use setSunlight it's required to set realSunlight : true in Threebox initial options.");return}var Ge=new Date(de.getTime());if(ge?ge.lng&&ge.lat?this.mapCenter=ge:this.mapCenter={lng:ge[0],lat:ge[1]}:this.mapCenter=this.map.getCenter(),this.lightDateTime&&this.lightDateTime.getTime()===Ge.getTime()&&this.lightLng===this.mapCenter.lng&&this.lightLat===this.mapCenter.lat)return;this.lightDateTime=Ge,this.lightLng=this.mapCenter.lng,this.lightLat=this.mapCenter.lat,this.sunPosition=this.getSunPosition(Ge,[this.mapCenter.lng,this.mapCenter.lat]);let gt=this.sunPosition.altitude,dt=Math.PI+this.sunPosition.azimuth,Q=A.WORLD_SIZE/2,Y=Math.sin(gt),Be=Math.cos(gt),yt=Math.cos(dt)*Be,He=Math.sin(dt)*Be;this.lights.dirLight.position.set(He,yt,Y),this.lights.dirLight.position.multiplyScalar(Q),this.lights.dirLight.intensity=Math.max(Y,0),this.lights.hemiLight.intensity=Math.max(Y*1,.1),this.lights.dirLight.updateMatrixWorld(),this.updateLightHelper(),this.map.loaded()&&(this.updateSunGround(this.sunPosition),this.map.setLight({anchor:"map",position:[3,180+this.sunPosition.azimuth*180/Math.PI,90-this.sunPosition.altitude*180/Math.PI],intensity:Math.cos(this.sunPosition.altitude),color:`hsl(40, ${50*Math.cos(this.sunPosition.altitude)}%, ${Math.max(20,20+96*Math.sin(this.sunPosition.altitude))}%)`},{duration:0}),this.sky&&this.updateSunSky(this.getSunSky(Ge,this.sunPosition)))},getSunSky:function(de,ge){if(!ge){var Ge=this.map.getCenter();ge=this.getSunPosition(de||Date.now(),[Ge.lng,Ge.lat])}var gt=180+ge.azimuth*180/Math.PI,dt=90-ge.altitude*180/Math.PI;return[gt,dt]},updateSunSky:function(de){this.sky&&this.map.setPaintProperty(this.skyLayerName,"sky-atmosphere-sun",de)},updateSunGround:function(de){this.terrainLayerName!=""&&this.map.setPaintProperty(this.terrainLayerName,"raster-opacity",Math.max(Math.min(1,de.altitude*4),.25))},updateLightHelper:function(){this.lights.dirLightHelper&&(this.lights.dirLightHelper.position.setFromMatrixPosition(this.lights.dirLight.matrixWorld),this.lights.dirLightHelper.updateMatrix(),this.lights.dirLightHelper.update())},dispose:async function(){return console.log(this.memory()),new Promise(de=>{de(this.clear(null,!0).then(ge=>(this.map.remove(),this.map={},this.scene.remove(this.world),this.world.children=[],this.world=null,this.objectsCache.clear(),this.labelRenderer.dispose(),console.log(this.memory()),this.renderer.dispose(),ge)))})},defaultLights:function(){this.lights.ambientLight=new u.AmbientLight(new u.Color("hsl(0, 0%, 100%)"),.75),this.scene.add(this.lights.ambientLight),this.lights.dirLightBack=new u.DirectionalLight(new u.Color("hsl(0, 0%, 100%)"),.25),this.lights.dirLightBack.position.set(30,100,100),this.scene.add(this.lights.dirLightBack),this.lights.dirLight=new u.DirectionalLight(new u.Color("hsl(0, 0%, 100%)"),.25),this.lights.dirLight.position.set(-30,100,-100),this.scene.add(this.lights.dirLight)},realSunlight:function(de=!1){this.renderer.shadowMap.enabled=!0,this.lights.dirLight=new u.DirectionalLight(16777215,1),this.scene.add(this.lights.dirLight),de&&(this.lights.dirLightHelper=new u.DirectionalLightHelper(this.lights.dirLight,5),this.scene.add(this.lights.dirLightHelper));let ge=1e3,Ge=2,gt=8192;this.lights.dirLight.castShadow=!0,this.lights.dirLight.shadow.radius=Ge,this.lights.dirLight.shadow.mapSize.width=gt,this.lights.dirLight.shadow.mapSize.height=gt,this.lights.dirLight.shadow.camera.top=this.lights.dirLight.shadow.camera.right=ge,this.lights.dirLight.shadow.camera.bottom=this.lights.dirLight.shadow.camera.left=-ge,this.lights.dirLight.shadow.camera.near=1,this.lights.dirLight.shadow.camera.visible=!0,this.lights.dirLight.shadow.camera.far=4e8,this.lights.hemiLight=new u.HemisphereLight(new u.Color(16777215),new u.Color(16777215),.6),this.lights.hemiLight.color.setHSL(.661,.96,.12),this.lights.hemiLight.groundColor.setHSL(.11,.96,.14),this.lights.hemiLight.position.set(0,0,50),this.scene.add(this.lights.hemiLight),this.setSunlight(),this.map.once("idle",()=>{this.setSunlight(),this.repaint()})},setDefaultView:function(de,ge){de.bbox=(de.bbox||de.bbox==null)&&ge.enableSelectingObjects,de.tooltip=(de.tooltip||de.tooltip==null)&&ge.enableTooltips,de.mapScale=this.map.transform.scale},memory:function(){return this.renderer.info.memory},programs:function(){return this.renderer.info.programs.length},version:"2.2.7"};var bt={defaultLights:!1,realSunlight:!1,realSunlightHelper:!1,passiveRendering:!0,preserveDrawingBuffer:!1,enableSelectingFeatures:!1,enableSelectingObjects:!1,enableDraggingObjects:!1,enableRotatingObjects:!1,enableTooltips:!1,enableHelpTooltips:!1,multiLayer:!1,orthographic:!1,fov:A.FOV_DEGREES,sky:!1,terrain:!1};Yt.exports=tt})(oh);var lf=oh.exports;(function(Yt,Mn){Yt.exports={Threebox:lf,THREE:si}})(ah);var cf=ah.exports;const hf=Hp(cf);export{hf as t};
